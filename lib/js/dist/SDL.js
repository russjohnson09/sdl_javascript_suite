(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.SDL = factory());
}(this, (function () { 'use strict';

  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  /*
  * Copyright (c) 2019, Livio, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
  * Redistributions of source code must retain the above copyright notice, this
  * list of conditions and the following disclaimer.
  *
  * Redistributions in binary form must reproduce the above copyright notice,
  * this list of conditions and the following
  * disclaimer in the documentation and/or other materials provided with the
  * distribution.
  *
  * Neither the name of the Livio Inc. nor the names of its contributors
  * may be used to endorse or promote products derived from this software
  * without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
  var LifecycleManager = function LifecycleManager() {
    _classCallCheck(this, LifecycleManager);
  };

  /*
  * Copyright (c) 2019, Livio, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
  * Redistributions of source code must retain the above copyright notice, this
  * list of conditions and the following disclaimer.
  *
  * Redistributions in binary form must reproduce the above copyright notice,
  * this list of conditions and the following
  * disclaimer in the documentation and/or other materials provided with the
  * distribution.
  *
  * Neither the name of the Livio Inc. nor the names of its contributors
  * may be used to endorse or promote products derived from this software
  * without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
  var BitConverter =
  /*#__PURE__*/
  function () {
    function BitConverter() {
      _classCallCheck(this, BitConverter);
    }

    _createClass(BitConverter, [{
      key: "arrayBufferToHex",

      /**
      * @param {ArrayBuffer} bytes - byte array that will be converted to hex
      * @param {Number} offset - int optional, representing the offset to begin conversion at
      * @param {Number} length - int optional, representing number of bytes in array to convert
      * @return {String} the String containing converted hex values or null if byte array is null
      */
      value: function arrayBufferToHex(bytes) {
      } // TODO

      /**
      * @param {String} hexString - the String containing converted hex values
      * @return {ArrayBuffer} byte array converted from input String or null if String is null
      */

    }, {
      key: "hexToArrayBuffer",
      value: function hexToArrayBuffer(hexString) {} // TODO

      /**
      * @param {ArrayBuffer} buffer - buffer that will be converted to int
       * @param {Number} offset - int optional, the offset shift
      * @return {Number} int converted from buffer or -1 if buffer is null
      */

    }, {
      key: "arrayBufferToInt32",
      value: function arrayBufferToInt32(buffer) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        // TODO
        if (!buffer) return -1;
        var view = new DataView(buffer);
        return view.getUint32(offset);
      }
      /**
      * @param {Number} value - the integer to be converted
      * @return {ArrayBuffer} buffer converted from input value
      */

    }, {
      key: "int32ToArrayBuffer",
      value: function int32ToArrayBuffer(value) {
        var buffer = new ArrayBuffer(4); // Int32 has 4 bytes

        var view = new DataView(buffer);
        view.setUint32(0, value, false);
        return buffer;
      }
    }]);

    return BitConverter;
  }();

  var BinaryFrameHeader =
  /*#__PURE__*/
  function () {
    /**
    * @constructor
    * @param {RpcType} rpcType - An RPC Enum  representing the type of RPC being described (Request, Response, Notification)
    * @param {FunctionID} functionId - A FunctionID Enum representing the RPC function that is being described
    * @param {Number} correlationId - A number representing an ID to correlate a request and response pair
    * @param {Number} jsonSize - A number representing the size of a JSON object
    */
    function BinaryFrameHeader(rpcType, functionId, correlationId, jsonSize) {
      _classCallCheck(this, BinaryFrameHeader);

      this._rpcType = rpcType;
      this._functionId = functionId;
      this._correlationId = correlationId;
      this._jsonSize = jsonSize; // TODO

      this._jsonData = null;
      this._bulkData = null;
      return this;
    }
    /**
    * Takes in a byte array and transforms it to an instance of this class
    * @param {Uint8Array} binHeader
    * @return {BinaryFrameHeader} an instance of this class from parsing the supplied Uint8Array 
    */


    _createClass(BinaryFrameHeader, [{
      key: "fromBinaryHeader",
      value: function fromBinaryHeader(binHeader) {} // TODO

      /**
      * Uses the private members of this class to construct a byte array header
      * @return {Uint8Array} - A byte array
      */

    }, {
      key: "assembleHeaderBytes",
      value: function assembleHeaderBytes() {} // TODO

      /**
      * @param {RpcType} rpcType - An RPC Enum  representing the type of RPC being described (Request, Response, Notification)
      */

    }, {
      key: "setRPCType",
      value: function setRPCType(type) {
        this._rpcType = type;
      }
      /**
      * @return {RpcType} rpcType - An RPC Enum  representing the type of RPC being described (Request, Response, Notification)
      */

    }, {
      key: "getRPCType",
      value: function getRPCType() {
        return this._rpcType;
      }
      /**
      * @param {FunctionID} functionId - A FunctionID Enum representing the RPC function that is being described
       */

    }, {
      key: "setFunctionId",
      value: function setFunctionId(id) {
        this._functionId = id;
      }
      /**
      * @return {FunctionID} functionId - A FunctionID Enum representing the RPC function that is being described
      */

    }, {
      key: "getFunctionId",
      value: function getFunctionId() {
        return this._functionId;
      }
      /**
      * @param {Number} correlationId - A number representing an ID to correlate a request and response pair
      */

    }, {
      key: "setCorrelationId",
      value: function setCorrelationId(id) {
        this._correlationId = id;
      }
      /**
      * @return {Number} correlationId - A number representing an ID to correlate a request and response pair
       */

    }, {
      key: "getCorrelationId",
      value: function getCorrelationId() {
        return this._correlationId;
      }
      /**
      * @param {Number} size - A number representing the size of a JSON object
      */

    }, {
      key: "setJSONSize",
      value: function setJSONSize(size) {
        this._jsonSize = size;
      }
      /**
      * @return {Number} - A number representing the size of a JSON object
      */

    }, {
      key: "getJSONSize",
      value: function getJSONSize() {
        return _jsonSize;
      }
      /**
      * @param {Number} data - A byte array representing JSON data
      */

    }, {
      key: "setJSONData",
      value: function setJSONData(data) {} // TODO

      /**
      * @return {Uint8Array} - A byte array representing JSON data
      */

    }, {
      key: "getJSONData",
      value: function getJSONData() {
        return this._jsonData;
      }
      /**
      * @param {Uint8Array} data - A byte array representing bulk data
      */

    }, {
      key: "setBulkData",
      value: function setBulkData(data) {
        this._bulkData = data;
      }
      /**
      * @return {Uint8Array} - A byte array representing bulk data
      */

    }, {
      key: "getBulkData",
      value: function getBulkData() {
        return this._bulkData;
      }
    }]);

    return BinaryFrameHeader;
  }();

  /*
  * Copyright (c) 2019, Livio, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
  * Redistributions of source code must retain the above copyright notice, this
  * list of conditions and the following disclaimer.
  *
  * Redistributions in binary form must reproduce the above copyright notice,
  * this list of conditions and the following
  * disclaimer in the documentation and/or other materials provided with the
  * distribution.
  *
  * Neither the name of the Livio Inc. nor the names of its contributors
  * may be used to endorse or promote products derived from this software
  * without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */

  /**
   * This class will assemble the different types of messages
   */
  var MessageFrameAssembler =
  /*#__PURE__*/
  function () {
    /**
    * @constructor
    * @param {Number} headerSize
    * @param {Function} callback
    */
    function MessageFrameAssembler() {
      var headerSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;
      var callback = arguments.length > 1 ? arguments[1] : undefined;

      _classCallCheck(this, MessageFrameAssembler);

      if (callback == null) {
        throw "Callback can't be null for MessageFrameAssembler";
      }

      this._accumulator = null; //TODO byte array output stream

      this._headersize = headerSize;
      this._totalSize = 0;
      this._callback = callback;
    }
    /**
    * @param {SdlPacket} sdlPacket
    */


    _createClass(MessageFrameAssembler, [{
      key: "handleFrame",
      value: function handleFrame(sdlPacket) {}
      /**
      * @param {SdlPacket} sdlPacket
      */

    }, {
      key: "handleMultiFrameMessageFrame",
      value: function handleMultiFrameMessageFrame(sdlPacket) {}
      /**
      * @param {SdlPacket} sdlPacket
      */

    }, {
      key: "handleFirstDataFrame",
      value: function handleFirstDataFrame(sdlPacket) {}
      /**
      * @param {SdlPacket} sdlPacket
      */

    }, {
      key: "handleRemainingFrame",
      value: function handleRemainingFrame(sdlPacket) {}
    }]);

    return MessageFrameAssembler;
  }();

  /*
  * Copyright (c) 2019, Livio, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
  * Redistributions of source code must retain the above copyright notice, this
  * list of conditions and the following disclaimer.
  *
  * Redistributions in binary form must reproduce the above copyright notice,
  * this list of conditions and the following
  * disclaimer in the documentation and/or other materials provided with the
  * distribution.
  *
  * Neither the name of the Livio Inc. nor the names of its contributors
  * may be used to endorse or promote products derived from this software
  * without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
  var Enum =
  /*#__PURE__*/
  function () {
    /**
    * @constructor
    */
    function Enum() {
      _classCallCheck(this, Enum);
    } // intentionally empty

    /**
    * Returns the key for a given value if the value is found within the key:value map
    * @param value - A primitive value to find in the map
    * @param map {Object} - An map of string properties to primitive values 
    * @return {null|String} - Returns null if not found
    */


    _createClass(Enum, [{
      key: "valueForString",

      /**
      * A method for subclasses to implement that does what keyForValueInternal does
      * @param value - A primitive value to find in the map of the subclass
      * @return {*} - Returns a value if found, or null if not found
      */
      value: function valueForString(value) {
        throw "method must be overridden";
      }
    }], [{
      key: "keyForValueInternal",
      value: function keyForValueInternal(value, map) {
        for (var key in map) {
          if (map[key] === value) {
            return key;
          }
        }

        return null;
      }
      /**
      * Returns the given value if the value is found within the key:value map
      * @param value - A primitive value to find in the map
      * @param map {Object} - An map of string properties to primitive values 
      * @return {*} - Returns a value if found, or null if not found
      */

    }, {
      key: "valueForStringInternal",
      value: function valueForStringInternal(value, map) {
        for (var key in map) {
          if (map[key] === value) {
            return map[key];
          }
        }

        return null;
      }
    }]);

    return Enum;
  }();

  /**
   * @typedef {Enum} FrameType
   * @property {Object} MAP
   */

  var FrameType =
  /*#__PURE__*/
  function (_Enum) {
    _inherits(FrameType, _Enum);

    /**
    * @constructor
    */
    function FrameType() {
      _classCallCheck(this, FrameType);

      return _possibleConstructorReturn(this, _getPrototypeOf(FrameType).call(this));
    }
    /**
    * @return {Number}
    */


    _createClass(FrameType, null, [{
      key: "valueForString",

      /**
      * Confirms whether the value passed in exists in the Enums of this class
      * @param {Number} value
      * @return {null|Number} - Returns null if the enum value doesn't exist
      */
      value: function valueForString(value) {
        for (var key in FrameType.MAP) {
          if (FrameType.MAP[key] === value) {
            return FrameType.MAP[key];
          }
        }

        return null;
      }
    }, {
      key: "CONTROL",
      get: function get() {
        return FrameType.MAP.CONTROL;
      }
      /**
      * @return {Number}
      */

    }, {
      key: "FIRST",
      get: function get() {
        return FrameType.MAP.FIRST;
      }
      /**
      * @return {Number}
      */

    }, {
      key: "CONSECUTIVE",
      get: function get() {
        return FrameType.MAP.CONSECUTIVE;
      }
      /**
      * @return {Number}
      */

    }, {
      key: "SINGLE",
      get: function get() {
        return FrameType.MAP.SINGLE;
      }
    }]);

    return FrameType;
  }(Enum);

  FrameType.MAP = Object.freeze({
    'CONTROL': 0x00,
    'FIRST': 0x02,
    'CONSECUTIVE': 0x03,
    'SINGLE': 0x01
  });

  function unwrapExports (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var bson_common = createCommonjsModule(function (module, exports) {
    exports["bson"] =
    /******/
    function (modules) {
      // webpackBootstrap

      /******/
      // The module cache

      /******/
      var installedModules = {};
      /******/

      /******/
      // The require function

      /******/

      function __webpack_require__(moduleId) {
        /******/

        /******/
        // Check if module is in cache

        /******/
        if (installedModules[moduleId]) {
          /******/
          return installedModules[moduleId].exports;
          /******/
        }
        /******/
        // Create a new module (and put it into the cache)

        /******/


        var module = installedModules[moduleId] = {
          /******/
          i: moduleId,

          /******/
          l: false,

          /******/
          exports: {}
          /******/

        };
        /******/

        /******/
        // Execute the module function

        /******/

        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/

        /******/
        // Flag the module as loaded

        /******/

        module.l = true;
        /******/

        /******/
        // Return the exports of the module

        /******/

        return module.exports;
        /******/
      }
      /******/

      /******/

      /******/
      // expose the modules object (__webpack_modules__)

      /******/


      __webpack_require__.m = modules;
      /******/

      /******/
      // expose the module cache

      /******/

      __webpack_require__.c = installedModules;
      /******/

      /******/
      // define getter function for harmony exports

      /******/

      __webpack_require__.d = function (exports, name, getter) {
        /******/
        if (!__webpack_require__.o(exports, name)) {
          /******/
          Object.defineProperty(exports, name, {
            /******/
            configurable: false,

            /******/
            enumerable: true,

            /******/
            get: getter
            /******/

          });
          /******/
        }
        /******/

      };
      /******/

      /******/
      // getDefaultExport function for compatibility with non-harmony modules

      /******/


      __webpack_require__.n = function (module) {
        /******/
        var getter = module && module.__esModule ?
        /******/
        function getDefault() {
          return module['default'];
        } :
        /******/
        function getModuleExports() {
          return module;
        };
        /******/

        __webpack_require__.d(getter, 'a', getter);
        /******/


        return getter;
        /******/
      };
      /******/

      /******/
      // Object.prototype.hasOwnProperty.call

      /******/


      __webpack_require__.o = function (object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      /******/

      /******/
      // __webpack_public_path__

      /******/


      __webpack_require__.p = "";
      /******/

      /******/
      // Load entry module and return exports

      /******/

      return __webpack_require__(__webpack_require__.s = 2);
      /******/
    }(
    /************************************************************************/

    /******/
    [
    /* 0 */

    /***/
    function (module, exports) {
      var g; // This works in non-strict mode

      g = function () {
        return this;
      }();

      try {
        // This works if eval is allowed (see CSP)
        g = g || Function("return this")() || (1, eval)("this");
      } catch (e) {
        // This works if the window reference is available
        if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
      } // g can still be undefined, but nothing to do about it...
      // We return undefined, instead of nothing here, so it's
      // easier to handle this case. if(!global) { ...}


      module.exports = g;
      /***/
    },
    /* 1 */

    /***/
    function (module, exports, __webpack_require__) {
      /* WEBPACK VAR INJECTION */

      (function (global) {
        /*!
        * The buffer module from node.js, for the browser.
        *
        * @author   Feross Aboukhadijeh <http://feross.org>
        * @license  MIT
        */

        /* eslint-disable no-proto */
        var base64 = __webpack_require__(3);

        var ieee754 = __webpack_require__(4);

        var isArray = __webpack_require__(5);

        exports.Buffer = Buffer;
        exports.SlowBuffer = SlowBuffer;
        exports.INSPECT_MAX_BYTES = 50;
        /**
         * If `Buffer.TYPED_ARRAY_SUPPORT`:
         *   === true    Use Uint8Array implementation (fastest)
         *   === false   Use Object implementation (most compatible, even IE6)
         *
         * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
         * Opera 11.6+, iOS 4.2+.
         *
         * Due to various browser bugs, sometimes the Object implementation will be used even
         * when the browser supports typed arrays.
         *
         * Note:
         *
         *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
         *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
         *
         *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
         *
         *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
         *     incorrect length in some situations.
        
         * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
         * get the Object implementation, which is slower but behaves correctly.
         */

        Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();
        /*
         * Export kMaxLength after typed array support is determined.
         */

        exports.kMaxLength = kMaxLength();

        function typedArraySupport() {
          try {
            var arr = new Uint8Array(1);
            arr.__proto__ = {
              __proto__: Uint8Array.prototype,
              foo: function foo() {
                return 42;
              }
            };
            return arr.foo() === 42 && // typed array instances can be augmented
            typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
            arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
          } catch (e) {
            return false;
          }
        }

        function kMaxLength() {
          return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
        }

        function createBuffer(that, length) {
          if (kMaxLength() < length) {
            throw new RangeError('Invalid typed array length');
          }

          if (Buffer.TYPED_ARRAY_SUPPORT) {
            // Return an augmented `Uint8Array` instance, for best performance
            that = new Uint8Array(length);
            that.__proto__ = Buffer.prototype;
          } else {
            // Fallback: Return an object instance of the Buffer class
            if (that === null) {
              that = new Buffer(length);
            }

            that.length = length;
          }

          return that;
        }
        /**
         * The Buffer constructor returns instances of `Uint8Array` that have their
         * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
         * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
         * and the `Uint8Array` methods. Square bracket notation works as expected -- it
         * returns a single octet.
         *
         * The `Uint8Array` prototype remains unmodified.
         */


        function Buffer(arg, encodingOrOffset, length) {
          if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
            return new Buffer(arg, encodingOrOffset, length);
          } // Common case.


          if (typeof arg === 'number') {
            if (typeof encodingOrOffset === 'string') {
              throw new Error('If encoding is specified then the first argument must be a string');
            }

            return allocUnsafe(this, arg);
          }

          return from(this, arg, encodingOrOffset, length);
        }

        Buffer.poolSize = 8192; // not used by this implementation
        // TODO: Legacy, not needed anymore. Remove in next major version.

        Buffer._augment = function (arr) {
          arr.__proto__ = Buffer.prototype;
          return arr;
        };

        function from(that, value, encodingOrOffset, length) {
          if (typeof value === 'number') {
            throw new TypeError('"value" argument must not be a number');
          }

          if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
            return fromArrayBuffer(that, value, encodingOrOffset, length);
          }

          if (typeof value === 'string') {
            return fromString(that, value, encodingOrOffset);
          }

          return fromObject(that, value);
        }
        /**
         * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
         * if value is a number.
         * Buffer.from(str[, encoding])
         * Buffer.from(array)
         * Buffer.from(buffer)
         * Buffer.from(arrayBuffer[, byteOffset[, length]])
         **/


        Buffer.from = function (value, encodingOrOffset, length) {
          return from(null, value, encodingOrOffset, length);
        };

        if (Buffer.TYPED_ARRAY_SUPPORT) {
          Buffer.prototype.__proto__ = Uint8Array.prototype;
          Buffer.__proto__ = Uint8Array;

          if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
            // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
            Object.defineProperty(Buffer, Symbol.species, {
              value: null,
              configurable: true
            });
          }
        }

        function assertSize(size) {
          if (typeof size !== 'number') {
            throw new TypeError('"size" argument must be a number');
          } else if (size < 0) {
            throw new RangeError('"size" argument must not be negative');
          }
        }

        function alloc(that, size, fill, encoding) {
          assertSize(size);

          if (size <= 0) {
            return createBuffer(that, size);
          }

          if (fill !== undefined) {
            // Only pay attention to encoding if it's a string. This
            // prevents accidentally sending in a number that would
            // be interpretted as a start offset.
            return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
          }

          return createBuffer(that, size);
        }
        /**
         * Creates a new filled Buffer instance.
         * alloc(size[, fill[, encoding]])
         **/


        Buffer.alloc = function (size, fill, encoding) {
          return alloc(null, size, fill, encoding);
        };

        function allocUnsafe(that, size) {
          assertSize(size);
          that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);

          if (!Buffer.TYPED_ARRAY_SUPPORT) {
            for (var i = 0; i < size; ++i) {
              that[i] = 0;
            }
          }

          return that;
        }
        /**
         * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
         * */


        Buffer.allocUnsafe = function (size) {
          return allocUnsafe(null, size);
        };
        /**
         * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
         */


        Buffer.allocUnsafeSlow = function (size) {
          return allocUnsafe(null, size);
        };

        function fromString(that, string, encoding) {
          if (typeof encoding !== 'string' || encoding === '') {
            encoding = 'utf8';
          }

          if (!Buffer.isEncoding(encoding)) {
            throw new TypeError('"encoding" must be a valid string encoding');
          }

          var length = byteLength(string, encoding) | 0;
          that = createBuffer(that, length);
          var actual = that.write(string, encoding);

          if (actual !== length) {
            // Writing a hex string, for example, that contains invalid characters will
            // cause everything after the first invalid character to be ignored. (e.g.
            // 'abxxcd' will be treated as 'ab')
            that = that.slice(0, actual);
          }

          return that;
        }

        function fromArrayLike(that, array) {
          var length = array.length < 0 ? 0 : checked(array.length) | 0;
          that = createBuffer(that, length);

          for (var i = 0; i < length; i += 1) {
            that[i] = array[i] & 255;
          }

          return that;
        }

        function fromArrayBuffer(that, array, byteOffset, length) {
          array.byteLength; // this throws if `array` is not a valid ArrayBuffer

          if (byteOffset < 0 || array.byteLength < byteOffset) {
            throw new RangeError('\'offset\' is out of bounds');
          }

          if (array.byteLength < byteOffset + (length || 0)) {
            throw new RangeError('\'length\' is out of bounds');
          }

          if (byteOffset === undefined && length === undefined) {
            array = new Uint8Array(array);
          } else if (length === undefined) {
            array = new Uint8Array(array, byteOffset);
          } else {
            array = new Uint8Array(array, byteOffset, length);
          }

          if (Buffer.TYPED_ARRAY_SUPPORT) {
            // Return an augmented `Uint8Array` instance, for best performance
            that = array;
            that.__proto__ = Buffer.prototype;
          } else {
            // Fallback: Return an object instance of the Buffer class
            that = fromArrayLike(that, array);
          }

          return that;
        }

        function fromObject(that, obj) {
          if (Buffer.isBuffer(obj)) {
            var len = checked(obj.length) | 0;
            that = createBuffer(that, len);

            if (that.length === 0) {
              return that;
            }

            obj.copy(that, 0, 0, len);
            return that;
          }

          if (obj) {
            if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
              if (typeof obj.length !== 'number' || isnan(obj.length)) {
                return createBuffer(that, 0);
              }

              return fromArrayLike(that, obj);
            }

            if (obj.type === 'Buffer' && isArray(obj.data)) {
              return fromArrayLike(that, obj.data);
            }
          }

          throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
        }

        function checked(length) {
          // Note: cannot use `length < kMaxLength()` here because that fails when
          // length is NaN (which is otherwise coerced to zero.)
          if (length >= kMaxLength()) {
            throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
          }

          return length | 0;
        }

        function SlowBuffer(length) {
          if (+length != length) {
            // eslint-disable-line eqeqeq
            length = 0;
          }

          return Buffer.alloc(+length);
        }

        Buffer.isBuffer = function isBuffer(b) {
          return !!(b != null && b._isBuffer);
        };

        Buffer.compare = function compare(a, b) {
          if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
            throw new TypeError('Arguments must be Buffers');
          }

          if (a === b) return 0;
          var x = a.length;
          var y = b.length;

          for (var i = 0, len = Math.min(x, y); i < len; ++i) {
            if (a[i] !== b[i]) {
              x = a[i];
              y = b[i];
              break;
            }
          }

          if (x < y) return -1;
          if (y < x) return 1;
          return 0;
        };

        Buffer.isEncoding = function isEncoding(encoding) {
          switch (String(encoding).toLowerCase()) {
            case 'hex':
            case 'utf8':
            case 'utf-8':
            case 'ascii':
            case 'latin1':
            case 'binary':
            case 'base64':
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return true;

            default:
              return false;
          }
        };

        Buffer.concat = function concat(list, length) {
          if (!isArray(list)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          }

          if (list.length === 0) {
            return Buffer.alloc(0);
          }

          var i;

          if (length === undefined) {
            length = 0;

            for (i = 0; i < list.length; ++i) {
              length += list[i].length;
            }
          }

          var buffer = Buffer.allocUnsafe(length);
          var pos = 0;

          for (i = 0; i < list.length; ++i) {
            var buf = list[i];

            if (!Buffer.isBuffer(buf)) {
              throw new TypeError('"list" argument must be an Array of Buffers');
            }

            buf.copy(buffer, pos);
            pos += buf.length;
          }

          return buffer;
        };

        function byteLength(string, encoding) {
          if (Buffer.isBuffer(string)) {
            return string.length;
          }

          if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
            return string.byteLength;
          }

          if (typeof string !== 'string') {
            string = '' + string;
          }

          var len = string.length;
          if (len === 0) return 0; // Use a for loop to avoid recursion

          var loweredCase = false;

          for (;;) {
            switch (encoding) {
              case 'ascii':
              case 'latin1':
              case 'binary':
                return len;

              case 'utf8':
              case 'utf-8':
              case undefined:
                return utf8ToBytes(string).length;

              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return len * 2;

              case 'hex':
                return len >>> 1;

              case 'base64':
                return base64ToBytes(string).length;

              default:
                if (loweredCase) return utf8ToBytes(string).length; // assume utf8

                encoding = ('' + encoding).toLowerCase();
                loweredCase = true;
            }
          }
        }

        Buffer.byteLength = byteLength;

        function slowToString(encoding, start, end) {
          var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
          // property of a typed array.
          // This behaves neither like String nor Uint8Array in that we set start/end
          // to their upper/lower bounds if the value passed is out of range.
          // undefined is handled specially as per ECMA-262 6th Edition,
          // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

          if (start === undefined || start < 0) {
            start = 0;
          } // Return early if start > this.length. Done here to prevent potential uint32
          // coercion fail below.


          if (start > this.length) {
            return '';
          }

          if (end === undefined || end > this.length) {
            end = this.length;
          }

          if (end <= 0) {
            return '';
          } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.


          end >>>= 0;
          start >>>= 0;

          if (end <= start) {
            return '';
          }

          if (!encoding) encoding = 'utf8';

          while (true) {
            switch (encoding) {
              case 'hex':
                return hexSlice(this, start, end);

              case 'utf8':
              case 'utf-8':
                return utf8Slice(this, start, end);

              case 'ascii':
                return asciiSlice(this, start, end);

              case 'latin1':
              case 'binary':
                return latin1Slice(this, start, end);

              case 'base64':
                return base64Slice(this, start, end);

              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return utf16leSlice(this, start, end);

              default:
                if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
                encoding = (encoding + '').toLowerCase();
                loweredCase = true;
            }
          }
        } // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
        // Buffer instances.


        Buffer.prototype._isBuffer = true;

        function swap(b, n, m) {
          var i = b[n];
          b[n] = b[m];
          b[m] = i;
        }

        Buffer.prototype.swap16 = function swap16() {
          var len = this.length;

          if (len % 2 !== 0) {
            throw new RangeError('Buffer size must be a multiple of 16-bits');
          }

          for (var i = 0; i < len; i += 2) {
            swap(this, i, i + 1);
          }

          return this;
        };

        Buffer.prototype.swap32 = function swap32() {
          var len = this.length;

          if (len % 4 !== 0) {
            throw new RangeError('Buffer size must be a multiple of 32-bits');
          }

          for (var i = 0; i < len; i += 4) {
            swap(this, i, i + 3);
            swap(this, i + 1, i + 2);
          }

          return this;
        };

        Buffer.prototype.swap64 = function swap64() {
          var len = this.length;

          if (len % 8 !== 0) {
            throw new RangeError('Buffer size must be a multiple of 64-bits');
          }

          for (var i = 0; i < len; i += 8) {
            swap(this, i, i + 7);
            swap(this, i + 1, i + 6);
            swap(this, i + 2, i + 5);
            swap(this, i + 3, i + 4);
          }

          return this;
        };

        Buffer.prototype.toString = function toString() {
          var length = this.length | 0;
          if (length === 0) return '';
          if (arguments.length === 0) return utf8Slice(this, 0, length);
          return slowToString.apply(this, arguments);
        };

        Buffer.prototype.equals = function equals(b) {
          if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
          if (this === b) return true;
          return Buffer.compare(this, b) === 0;
        };

        Buffer.prototype.inspect = function inspect() {
          var str = '';
          var max = exports.INSPECT_MAX_BYTES;

          if (this.length > 0) {
            str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
            if (this.length > max) str += ' ... ';
          }

          return '<Buffer ' + str + '>';
        };

        Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
          if (!Buffer.isBuffer(target)) {
            throw new TypeError('Argument must be a Buffer');
          }

          if (start === undefined) {
            start = 0;
          }

          if (end === undefined) {
            end = target ? target.length : 0;
          }

          if (thisStart === undefined) {
            thisStart = 0;
          }

          if (thisEnd === undefined) {
            thisEnd = this.length;
          }

          if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
            throw new RangeError('out of range index');
          }

          if (thisStart >= thisEnd && start >= end) {
            return 0;
          }

          if (thisStart >= thisEnd) {
            return -1;
          }

          if (start >= end) {
            return 1;
          }

          start >>>= 0;
          end >>>= 0;
          thisStart >>>= 0;
          thisEnd >>>= 0;
          if (this === target) return 0;
          var x = thisEnd - thisStart;
          var y = end - start;
          var len = Math.min(x, y);
          var thisCopy = this.slice(thisStart, thisEnd);
          var targetCopy = target.slice(start, end);

          for (var i = 0; i < len; ++i) {
            if (thisCopy[i] !== targetCopy[i]) {
              x = thisCopy[i];
              y = targetCopy[i];
              break;
            }
          }

          if (x < y) return -1;
          if (y < x) return 1;
          return 0;
        }; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
        // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
        //
        // Arguments:
        // - buffer - a Buffer to search
        // - val - a string, Buffer, or number
        // - byteOffset - an index into `buffer`; will be clamped to an int32
        // - encoding - an optional encoding, relevant is val is a string
        // - dir - true for indexOf, false for lastIndexOf


        function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
          // Empty buffer means no match
          if (buffer.length === 0) return -1; // Normalize byteOffset

          if (typeof byteOffset === 'string') {
            encoding = byteOffset;
            byteOffset = 0;
          } else if (byteOffset > 0x7fffffff) {
            byteOffset = 0x7fffffff;
          } else if (byteOffset < -0x80000000) {
            byteOffset = -0x80000000;
          }

          byteOffset = +byteOffset; // Coerce to Number.

          if (isNaN(byteOffset)) {
            // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
            byteOffset = dir ? 0 : buffer.length - 1;
          } // Normalize byteOffset: negative offsets start from the end of the buffer


          if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

          if (byteOffset >= buffer.length) {
            if (dir) return -1;else byteOffset = buffer.length - 1;
          } else if (byteOffset < 0) {
            if (dir) byteOffset = 0;else return -1;
          } // Normalize val


          if (typeof val === 'string') {
            val = Buffer.from(val, encoding);
          } // Finally, search either indexOf (if dir is true) or lastIndexOf


          if (Buffer.isBuffer(val)) {
            // Special case: looking for empty string/buffer always fails
            if (val.length === 0) {
              return -1;
            }

            return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
          } else if (typeof val === 'number') {
            val = val & 0xFF; // Search for a byte value [0-255]

            if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
              if (dir) {
                return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
              } else {
                return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
              }
            }

            return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
          }

          throw new TypeError('val must be string, number or Buffer');
        }

        function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
          var indexSize = 1;
          var arrLength = arr.length;
          var valLength = val.length;

          if (encoding !== undefined) {
            encoding = String(encoding).toLowerCase();

            if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
              if (arr.length < 2 || val.length < 2) {
                return -1;
              }

              indexSize = 2;
              arrLength /= 2;
              valLength /= 2;
              byteOffset /= 2;
            }
          }

          function read(buf, i) {
            if (indexSize === 1) {
              return buf[i];
            } else {
              return buf.readUInt16BE(i * indexSize);
            }
          }

          var i;

          if (dir) {
            var foundIndex = -1;

            for (i = byteOffset; i < arrLength; i++) {
              if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                if (foundIndex === -1) foundIndex = i;
                if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
              } else {
                if (foundIndex !== -1) i -= i - foundIndex;
                foundIndex = -1;
              }
            }
          } else {
            if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

            for (i = byteOffset; i >= 0; i--) {
              var found = true;

              for (var j = 0; j < valLength; j++) {
                if (read(arr, i + j) !== read(val, j)) {
                  found = false;
                  break;
                }
              }

              if (found) return i;
            }
          }

          return -1;
        }

        Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
          return this.indexOf(val, byteOffset, encoding) !== -1;
        };

        Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
          return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
        };

        Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
          return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
        };

        function hexWrite(buf, string, offset, length) {
          offset = Number(offset) || 0;
          var remaining = buf.length - offset;

          if (!length) {
            length = remaining;
          } else {
            length = Number(length);

            if (length > remaining) {
              length = remaining;
            }
          } // must be an even number of digits


          var strLen = string.length;
          if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

          if (length > strLen / 2) {
            length = strLen / 2;
          }

          for (var i = 0; i < length; ++i) {
            var parsed = parseInt(string.substr(i * 2, 2), 16);
            if (isNaN(parsed)) return i;
            buf[offset + i] = parsed;
          }

          return i;
        }

        function utf8Write(buf, string, offset, length) {
          return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
        }

        function asciiWrite(buf, string, offset, length) {
          return blitBuffer(asciiToBytes(string), buf, offset, length);
        }

        function latin1Write(buf, string, offset, length) {
          return asciiWrite(buf, string, offset, length);
        }

        function base64Write(buf, string, offset, length) {
          return blitBuffer(base64ToBytes(string), buf, offset, length);
        }

        function ucs2Write(buf, string, offset, length) {
          return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
        }

        Buffer.prototype.write = function write(string, offset, length, encoding) {
          // Buffer#write(string)
          if (offset === undefined) {
            encoding = 'utf8';
            length = this.length;
            offset = 0; // Buffer#write(string, encoding)
          } else if (length === undefined && typeof offset === 'string') {
            encoding = offset;
            length = this.length;
            offset = 0; // Buffer#write(string, offset[, length][, encoding])
          } else if (isFinite(offset)) {
            offset = offset | 0;

            if (isFinite(length)) {
              length = length | 0;
              if (encoding === undefined) encoding = 'utf8';
            } else {
              encoding = length;
              length = undefined;
            } // legacy write(string, encoding, offset, length) - remove in v0.13

          } else {
            throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
          }

          var remaining = this.length - offset;
          if (length === undefined || length > remaining) length = remaining;

          if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
            throw new RangeError('Attempt to write outside buffer bounds');
          }

          if (!encoding) encoding = 'utf8';
          var loweredCase = false;

          for (;;) {
            switch (encoding) {
              case 'hex':
                return hexWrite(this, string, offset, length);

              case 'utf8':
              case 'utf-8':
                return utf8Write(this, string, offset, length);

              case 'ascii':
                return asciiWrite(this, string, offset, length);

              case 'latin1':
              case 'binary':
                return latin1Write(this, string, offset, length);

              case 'base64':
                // Warning: maxLength not taken into account in base64Write
                return base64Write(this, string, offset, length);

              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return ucs2Write(this, string, offset, length);

              default:
                if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
                encoding = ('' + encoding).toLowerCase();
                loweredCase = true;
            }
          }
        };

        Buffer.prototype.toJSON = function toJSON() {
          return {
            type: 'Buffer',
            data: Array.prototype.slice.call(this._arr || this, 0)
          };
        };

        function base64Slice(buf, start, end) {
          if (start === 0 && end === buf.length) {
            return base64.fromByteArray(buf);
          } else {
            return base64.fromByteArray(buf.slice(start, end));
          }
        }

        function utf8Slice(buf, start, end) {
          end = Math.min(buf.length, end);
          var res = [];
          var i = start;

          while (i < end) {
            var firstByte = buf[i];
            var codePoint = null;
            var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

            if (i + bytesPerSequence <= end) {
              var secondByte, thirdByte, fourthByte, tempCodePoint;

              switch (bytesPerSequence) {
                case 1:
                  if (firstByte < 0x80) {
                    codePoint = firstByte;
                  }

                  break;

                case 2:
                  secondByte = buf[i + 1];

                  if ((secondByte & 0xC0) === 0x80) {
                    tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

                    if (tempCodePoint > 0x7F) {
                      codePoint = tempCodePoint;
                    }
                  }

                  break;

                case 3:
                  secondByte = buf[i + 1];
                  thirdByte = buf[i + 2];

                  if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                    tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

                    if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                      codePoint = tempCodePoint;
                    }
                  }

                  break;

                case 4:
                  secondByte = buf[i + 1];
                  thirdByte = buf[i + 2];
                  fourthByte = buf[i + 3];

                  if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                    tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

                    if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                      codePoint = tempCodePoint;
                    }
                  }

              }
            }

            if (codePoint === null) {
              // we did not generate a valid codePoint so insert a
              // replacement char (U+FFFD) and advance only 1 byte
              codePoint = 0xFFFD;
              bytesPerSequence = 1;
            } else if (codePoint > 0xFFFF) {
              // encode to utf16 (surrogate pair dance)
              codePoint -= 0x10000;
              res.push(codePoint >>> 10 & 0x3FF | 0xD800);
              codePoint = 0xDC00 | codePoint & 0x3FF;
            }

            res.push(codePoint);
            i += bytesPerSequence;
          }

          return decodeCodePointsArray(res);
        } // Based on http://stackoverflow.com/a/22747272/680742, the browser with
        // the lowest limit is Chrome, with 0x10000 args.
        // We go 1 magnitude less, for safety


        var MAX_ARGUMENTS_LENGTH = 0x1000;

        function decodeCodePointsArray(codePoints) {
          var len = codePoints.length;

          if (len <= MAX_ARGUMENTS_LENGTH) {
            return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
          } // Decode in chunks to avoid "call stack size exceeded".


          var res = '';
          var i = 0;

          while (i < len) {
            res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
          }

          return res;
        }

        function asciiSlice(buf, start, end) {
          var ret = '';
          end = Math.min(buf.length, end);

          for (var i = start; i < end; ++i) {
            ret += String.fromCharCode(buf[i] & 0x7F);
          }

          return ret;
        }

        function latin1Slice(buf, start, end) {
          var ret = '';
          end = Math.min(buf.length, end);

          for (var i = start; i < end; ++i) {
            ret += String.fromCharCode(buf[i]);
          }

          return ret;
        }

        function hexSlice(buf, start, end) {
          var len = buf.length;
          if (!start || start < 0) start = 0;
          if (!end || end < 0 || end > len) end = len;
          var out = '';

          for (var i = start; i < end; ++i) {
            out += toHex(buf[i]);
          }

          return out;
        }

        function utf16leSlice(buf, start, end) {
          var bytes = buf.slice(start, end);
          var res = '';

          for (var i = 0; i < bytes.length; i += 2) {
            res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
          }

          return res;
        }

        Buffer.prototype.slice = function slice(start, end) {
          var len = this.length;
          start = ~~start;
          end = end === undefined ? len : ~~end;

          if (start < 0) {
            start += len;
            if (start < 0) start = 0;
          } else if (start > len) {
            start = len;
          }

          if (end < 0) {
            end += len;
            if (end < 0) end = 0;
          } else if (end > len) {
            end = len;
          }

          if (end < start) end = start;
          var newBuf;

          if (Buffer.TYPED_ARRAY_SUPPORT) {
            newBuf = this.subarray(start, end);
            newBuf.__proto__ = Buffer.prototype;
          } else {
            var sliceLen = end - start;
            newBuf = new Buffer(sliceLen, undefined);

            for (var i = 0; i < sliceLen; ++i) {
              newBuf[i] = this[i + start];
            }
          }

          return newBuf;
        };
        /*
         * Need to make sure that buffer isn't trying to write out of bounds.
         */


        function checkOffset(offset, ext, length) {
          if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
          if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
        }

        Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
          offset = offset | 0;
          byteLength = byteLength | 0;
          if (!noAssert) checkOffset(offset, byteLength, this.length);
          var val = this[offset];
          var mul = 1;
          var i = 0;

          while (++i < byteLength && (mul *= 0x100)) {
            val += this[offset + i] * mul;
          }

          return val;
        };

        Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
          offset = offset | 0;
          byteLength = byteLength | 0;

          if (!noAssert) {
            checkOffset(offset, byteLength, this.length);
          }

          var val = this[offset + --byteLength];
          var mul = 1;

          while (byteLength > 0 && (mul *= 0x100)) {
            val += this[offset + --byteLength] * mul;
          }

          return val;
        };

        Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 1, this.length);
          return this[offset];
        };

        Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 2, this.length);
          return this[offset] | this[offset + 1] << 8;
        };

        Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 2, this.length);
          return this[offset] << 8 | this[offset + 1];
        };

        Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);
          return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
        };

        Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);
          return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
        };

        Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
          offset = offset | 0;
          byteLength = byteLength | 0;
          if (!noAssert) checkOffset(offset, byteLength, this.length);
          var val = this[offset];
          var mul = 1;
          var i = 0;

          while (++i < byteLength && (mul *= 0x100)) {
            val += this[offset + i] * mul;
          }

          mul *= 0x80;
          if (val >= mul) val -= Math.pow(2, 8 * byteLength);
          return val;
        };

        Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
          offset = offset | 0;
          byteLength = byteLength | 0;
          if (!noAssert) checkOffset(offset, byteLength, this.length);
          var i = byteLength;
          var mul = 1;
          var val = this[offset + --i];

          while (i > 0 && (mul *= 0x100)) {
            val += this[offset + --i] * mul;
          }

          mul *= 0x80;
          if (val >= mul) val -= Math.pow(2, 8 * byteLength);
          return val;
        };

        Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 1, this.length);
          if (!(this[offset] & 0x80)) return this[offset];
          return (0xff - this[offset] + 1) * -1;
        };

        Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 2, this.length);
          var val = this[offset] | this[offset + 1] << 8;
          return val & 0x8000 ? val | 0xFFFF0000 : val;
        };

        Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 2, this.length);
          var val = this[offset + 1] | this[offset] << 8;
          return val & 0x8000 ? val | 0xFFFF0000 : val;
        };

        Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);
          return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
        };

        Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);
          return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
        };

        Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);
          return ieee754.read(this, offset, true, 23, 4);
        };

        Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);
          return ieee754.read(this, offset, false, 23, 4);
        };

        Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 8, this.length);
          return ieee754.read(this, offset, true, 52, 8);
        };

        Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 8, this.length);
          return ieee754.read(this, offset, false, 52, 8);
        };

        function checkInt(buf, value, offset, ext, max, min) {
          if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
          if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
          if (offset + ext > buf.length) throw new RangeError('Index out of range');
        }

        Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
          value = +value;
          offset = offset | 0;
          byteLength = byteLength | 0;

          if (!noAssert) {
            var maxBytes = Math.pow(2, 8 * byteLength) - 1;
            checkInt(this, value, offset, byteLength, maxBytes, 0);
          }

          var mul = 1;
          var i = 0;
          this[offset] = value & 0xFF;

          while (++i < byteLength && (mul *= 0x100)) {
            this[offset + i] = value / mul & 0xFF;
          }

          return offset + byteLength;
        };

        Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
          value = +value;
          offset = offset | 0;
          byteLength = byteLength | 0;

          if (!noAssert) {
            var maxBytes = Math.pow(2, 8 * byteLength) - 1;
            checkInt(this, value, offset, byteLength, maxBytes, 0);
          }

          var i = byteLength - 1;
          var mul = 1;
          this[offset + i] = value & 0xFF;

          while (--i >= 0 && (mul *= 0x100)) {
            this[offset + i] = value / mul & 0xFF;
          }

          return offset + byteLength;
        };

        Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
          if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
          this[offset] = value & 0xff;
          return offset + 1;
        };

        function objectWriteUInt16(buf, value, offset, littleEndian) {
          if (value < 0) value = 0xffff + value + 1;

          for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
            buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
          }
        }

        Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value & 0xff;
            this[offset + 1] = value >>> 8;
          } else {
            objectWriteUInt16(this, value, offset, true);
          }

          return offset + 2;
        };

        Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 8;
            this[offset + 1] = value & 0xff;
          } else {
            objectWriteUInt16(this, value, offset, false);
          }

          return offset + 2;
        };

        function objectWriteUInt32(buf, value, offset, littleEndian) {
          if (value < 0) value = 0xffffffff + value + 1;

          for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
            buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
          }
        }

        Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset + 3] = value >>> 24;
            this[offset + 2] = value >>> 16;
            this[offset + 1] = value >>> 8;
            this[offset] = value & 0xff;
          } else {
            objectWriteUInt32(this, value, offset, true);
          }

          return offset + 4;
        };

        Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 0xff;
          } else {
            objectWriteUInt32(this, value, offset, false);
          }

          return offset + 4;
        };

        Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
          value = +value;
          offset = offset | 0;

          if (!noAssert) {
            var limit = Math.pow(2, 8 * byteLength - 1);
            checkInt(this, value, offset, byteLength, limit - 1, -limit);
          }

          var i = 0;
          var mul = 1;
          var sub = 0;
          this[offset] = value & 0xFF;

          while (++i < byteLength && (mul *= 0x100)) {
            if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
              sub = 1;
            }

            this[offset + i] = (value / mul >> 0) - sub & 0xFF;
          }

          return offset + byteLength;
        };

        Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
          value = +value;
          offset = offset | 0;

          if (!noAssert) {
            var limit = Math.pow(2, 8 * byteLength - 1);
            checkInt(this, value, offset, byteLength, limit - 1, -limit);
          }

          var i = byteLength - 1;
          var mul = 1;
          var sub = 0;
          this[offset + i] = value & 0xFF;

          while (--i >= 0 && (mul *= 0x100)) {
            if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
              sub = 1;
            }

            this[offset + i] = (value / mul >> 0) - sub & 0xFF;
          }

          return offset + byteLength;
        };

        Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
          if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
          if (value < 0) value = 0xff + value + 1;
          this[offset] = value & 0xff;
          return offset + 1;
        };

        Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value & 0xff;
            this[offset + 1] = value >>> 8;
          } else {
            objectWriteUInt16(this, value, offset, true);
          }

          return offset + 2;
        };

        Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 8;
            this[offset + 1] = value & 0xff;
          } else {
            objectWriteUInt16(this, value, offset, false);
          }

          return offset + 2;
        };

        Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);

          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value & 0xff;
            this[offset + 1] = value >>> 8;
            this[offset + 2] = value >>> 16;
            this[offset + 3] = value >>> 24;
          } else {
            objectWriteUInt32(this, value, offset, true);
          }

          return offset + 4;
        };

        Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
          if (value < 0) value = 0xffffffff + value + 1;

          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 0xff;
          } else {
            objectWriteUInt32(this, value, offset, false);
          }

          return offset + 4;
        };

        function checkIEEE754(buf, value, offset, ext, max, min) {
          if (offset + ext > buf.length) throw new RangeError('Index out of range');
          if (offset < 0) throw new RangeError('Index out of range');
        }

        function writeFloat(buf, value, offset, littleEndian, noAssert) {
          if (!noAssert) {
            checkIEEE754(buf, value, offset, 4);
          }

          ieee754.write(buf, value, offset, littleEndian, 23, 4);
          return offset + 4;
        }

        Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
          return writeFloat(this, value, offset, true, noAssert);
        };

        Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
          return writeFloat(this, value, offset, false, noAssert);
        };

        function writeDouble(buf, value, offset, littleEndian, noAssert) {
          if (!noAssert) {
            checkIEEE754(buf, value, offset, 8);
          }

          ieee754.write(buf, value, offset, littleEndian, 52, 8);
          return offset + 8;
        }

        Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
          return writeDouble(this, value, offset, true, noAssert);
        };

        Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
          return writeDouble(this, value, offset, false, noAssert);
        }; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


        Buffer.prototype.copy = function copy(target, targetStart, start, end) {
          if (!start) start = 0;
          if (!end && end !== 0) end = this.length;
          if (targetStart >= target.length) targetStart = target.length;
          if (!targetStart) targetStart = 0;
          if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

          if (end === start) return 0;
          if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

          if (targetStart < 0) {
            throw new RangeError('targetStart out of bounds');
          }

          if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
          if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

          if (end > this.length) end = this.length;

          if (target.length - targetStart < end - start) {
            end = target.length - targetStart + start;
          }

          var len = end - start;
          var i;

          if (this === target && start < targetStart && targetStart < end) {
            // descending copy from end
            for (i = len - 1; i >= 0; --i) {
              target[i + targetStart] = this[i + start];
            }
          } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
            // ascending copy from start
            for (i = 0; i < len; ++i) {
              target[i + targetStart] = this[i + start];
            }
          } else {
            Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
          }

          return len;
        }; // Usage:
        //    buffer.fill(number[, offset[, end]])
        //    buffer.fill(buffer[, offset[, end]])
        //    buffer.fill(string[, offset[, end]][, encoding])


        Buffer.prototype.fill = function fill(val, start, end, encoding) {
          // Handle string cases:
          if (typeof val === 'string') {
            if (typeof start === 'string') {
              encoding = start;
              start = 0;
              end = this.length;
            } else if (typeof end === 'string') {
              encoding = end;
              end = this.length;
            }

            if (val.length === 1) {
              var code = val.charCodeAt(0);

              if (code < 256) {
                val = code;
              }
            }

            if (encoding !== undefined && typeof encoding !== 'string') {
              throw new TypeError('encoding must be a string');
            }

            if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
              throw new TypeError('Unknown encoding: ' + encoding);
            }
          } else if (typeof val === 'number') {
            val = val & 255;
          } // Invalid ranges are not set to a default, so can range check early.


          if (start < 0 || this.length < start || this.length < end) {
            throw new RangeError('Out of range index');
          }

          if (end <= start) {
            return this;
          }

          start = start >>> 0;
          end = end === undefined ? this.length : end >>> 0;
          if (!val) val = 0;
          var i;

          if (typeof val === 'number') {
            for (i = start; i < end; ++i) {
              this[i] = val;
            }
          } else {
            var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
            var len = bytes.length;

            for (i = 0; i < end - start; ++i) {
              this[i + start] = bytes[i % len];
            }
          }

          return this;
        }; // HELPER FUNCTIONS
        // ================


        var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

        function base64clean(str) {
          // Node strips out invalid characters like \n and \t from the string, base64-js does not
          str = stringtrim(str).replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

          if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

          while (str.length % 4 !== 0) {
            str = str + '=';
          }

          return str;
        }

        function stringtrim(str) {
          if (str.trim) return str.trim();
          return str.replace(/^\s+|\s+$/g, '');
        }

        function toHex(n) {
          if (n < 16) return '0' + n.toString(16);
          return n.toString(16);
        }

        function utf8ToBytes(string, units) {
          units = units || Infinity;
          var codePoint;
          var length = string.length;
          var leadSurrogate = null;
          var bytes = [];

          for (var i = 0; i < length; ++i) {
            codePoint = string.charCodeAt(i); // is surrogate component

            if (codePoint > 0xD7FF && codePoint < 0xE000) {
              // last char was a lead
              if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                  // unexpected trail
                  if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                  continue;
                } else if (i + 1 === length) {
                  // unpaired lead
                  if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                  continue;
                } // valid lead


                leadSurrogate = codePoint;
                continue;
              } // 2 leads in a row


              if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                leadSurrogate = codePoint;
                continue;
              } // valid surrogate pair


              codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
            } else if (leadSurrogate) {
              // valid bmp char, but last char was a lead
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            }

            leadSurrogate = null; // encode utf8

            if (codePoint < 0x80) {
              if ((units -= 1) < 0) break;
              bytes.push(codePoint);
            } else if (codePoint < 0x800) {
              if ((units -= 2) < 0) break;
              bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
            } else if (codePoint < 0x10000) {
              if ((units -= 3) < 0) break;
              bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
            } else if (codePoint < 0x110000) {
              if ((units -= 4) < 0) break;
              bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
            } else {
              throw new Error('Invalid code point');
            }
          }

          return bytes;
        }

        function asciiToBytes(str) {
          var byteArray = [];

          for (var i = 0; i < str.length; ++i) {
            // Node's code seems to be doing this and not & 0x7F..
            byteArray.push(str.charCodeAt(i) & 0xFF);
          }

          return byteArray;
        }

        function utf16leToBytes(str, units) {
          var c, hi, lo;
          var byteArray = [];

          for (var i = 0; i < str.length; ++i) {
            if ((units -= 2) < 0) break;
            c = str.charCodeAt(i);
            hi = c >> 8;
            lo = c % 256;
            byteArray.push(lo);
            byteArray.push(hi);
          }

          return byteArray;
        }

        function base64ToBytes(str) {
          return base64.toByteArray(base64clean(str));
        }

        function blitBuffer(src, dst, offset, length) {
          for (var i = 0; i < length; ++i) {
            if (i + offset >= dst.length || i >= src.length) break;
            dst[i + offset] = src[i];
          }

          return i;
        }

        function isnan(val) {
          return val !== val; // eslint-disable-line no-self-compare
        }
        /* WEBPACK VAR INJECTION */

      }).call(exports, __webpack_require__(0));
      /***/
    },
    /* 2 */

    /***/
    function (module, exports, __webpack_require__) {
      /* WEBPACK VAR INJECTION */
      (function (global, Buffer) {
        (function (global, factory) {
           factory(exports, __webpack_require__(6), __webpack_require__(1)) ;
        })(this, function (exports, _long, buffer) {

          _long = _long && _long.hasOwnProperty('default') ? _long['default'] : _long;
          buffer = buffer && buffer.hasOwnProperty('default') ? buffer['default'] : buffer;
          var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

          function createCommonjsModule(fn, module) {
            return module = {
              exports: {}
            }, fn(module, module.exports), module.exports;
          }

          function getCjsExportFromNamespace(n) {
            return n && n["default"] || n;
          }

          var map = createCommonjsModule(function (module) {
            if (typeof commonjsGlobal.Map !== 'undefined') {
              module.exports = commonjsGlobal.Map;
              module.exports.Map = commonjsGlobal.Map;
            } else {
              // We will return a polyfill
              var Map = function Map(array) {
                this._keys = [];
                this._values = {};

                for (var i = 0; i < array.length; i++) {
                  if (array[i] == null) continue; // skip null and undefined

                  var entry = array[i];
                  var key = entry[0];
                  var value = entry[1]; // Add the key to the list of keys in order

                  this._keys.push(key); // Add the key and value to the values dictionary with a point
                  // to the location in the ordered keys list


                  this._values[key] = {
                    v: value,
                    i: this._keys.length - 1
                  };
                }
              };

              Map.prototype.clear = function () {
                this._keys = [];
                this._values = {};
              };

              Map.prototype["delete"] = function (key) {
                var value = this._values[key];
                if (value == null) return false; // Delete entry

                delete this._values[key]; // Remove the key from the ordered keys list

                this._keys.splice(value.i, 1);

                return true;
              };

              Map.prototype.entries = function () {
                var self = this;
                var index = 0;
                return {
                  next: function next() {
                    var key = self._keys[index++];
                    return {
                      value: key !== undefined ? [key, self._values[key].v] : undefined,
                      done: key !== undefined ? false : true
                    };
                  }
                };
              };

              Map.prototype.forEach = function (callback, self) {
                self = self || this;

                for (var i = 0; i < this._keys.length; i++) {
                  var key = this._keys[i]; // Call the forEach callback

                  callback.call(self, this._values[key].v, key, self);
                }
              };

              Map.prototype.get = function (key) {
                return this._values[key] ? this._values[key].v : undefined;
              };

              Map.prototype.has = function (key) {
                return this._values[key] != null;
              };

              Map.prototype.keys = function () {
                var self = this;
                var index = 0;
                return {
                  next: function next() {
                    var key = self._keys[index++];
                    return {
                      value: key !== undefined ? key : undefined,
                      done: key !== undefined ? false : true
                    };
                  }
                };
              };

              Map.prototype.set = function (key, value) {
                if (this._values[key]) {
                  this._values[key].v = value;
                  return this;
                } // Add the key to the list of keys in order


                this._keys.push(key); // Add the key and value to the values dictionary with a point
                // to the location in the ordered keys list


                this._values[key] = {
                  v: value,
                  i: this._keys.length - 1
                };
                return this;
              };

              Map.prototype.values = function () {
                var self = this;
                var index = 0;
                return {
                  next: function next() {
                    var key = self._keys[index++];
                    return {
                      value: key !== undefined ? self._values[key].v : undefined,
                      done: key !== undefined ? false : true
                    };
                  }
                };
              }; // Last ismaster


              Object.defineProperty(Map.prototype, 'size', {
                enumerable: true,
                get: function get() {
                  return this._keys.length;
                }
              });
              module.exports = Map;
            }
          });
          var map_1 = map.Map;
          /**
           * @ignore
           */

          _long.prototype.toExtendedJSON = function (options) {
            if (options && options.relaxed) return this.toNumber();
            return {
              $numberLong: this.toString()
            };
          };
          /**
           * @ignore
           */


          _long.fromExtendedJSON = function (doc, options) {
            var result = _long.fromString(doc.$numberLong);

            return options && options.relaxed ? result.toNumber() : result;
          };

          Object.defineProperty(_long.prototype, '_bsontype', {
            value: 'Long'
          });
          var long_1 = _long;
          /**
           * A class representation of the BSON Double type.
           */

          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);
            if (staticProps) _defineProperties(Constructor, staticProps);
            return Constructor;
          }

          var Double =
          /*#__PURE__*/
          function () {
            /**
             * Create a Double type
             *
             * @param {number} value the number we want to represent as a double.
             * @return {Double}
             */
            function Double(value) {
              _classCallCheck(this, Double);

              this.value = value;
            }
            /**
             * Access the number value.
             *
             * @method
             * @return {number} returns the wrapped double number.
             */


            _createClass(Double, [{
              key: "valueOf",
              value: function valueOf() {
                return this.value;
              }
              /**
               * @ignore
               */

            }, {
              key: "toJSON",
              value: function toJSON() {
                return this.value;
              }
              /**
               * @ignore
               */

            }, {
              key: "toExtendedJSON",
              value: function toExtendedJSON(options) {
                if (options && options.relaxed && isFinite(this.value)) return this.value;
                return {
                  $numberDouble: this.value.toString()
                };
              }
              /**
               * @ignore
               */

            }], [{
              key: "fromExtendedJSON",
              value: function fromExtendedJSON(doc, options) {
                return options && options.relaxed ? parseFloat(doc.$numberDouble) : new Double(parseFloat(doc.$numberDouble));
              }
            }]);

            return Double;
          }();

          Object.defineProperty(Double.prototype, '_bsontype', {
            value: 'Double'
          });
          var double_1 = Double;

          function _typeof$1(obj) {
            if (typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol") {
              _typeof$1 = function _typeof$1(obj) {
                return _typeof(obj);
              };
            } else {
              _typeof$1 = function _typeof$1(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof(obj);
              };
            }

            return _typeof$1(obj);
          }

          function _classCallCheck$1(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties$1(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass$1(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
            if (staticProps) _defineProperties$1(Constructor, staticProps);
            return Constructor;
          }

          function _possibleConstructorReturn(self, call) {
            if (call && (_typeof$1(call) === "object" || typeof call === "function")) {
              return call;
            }

            return _assertThisInitialized(self);
          }

          function _assertThisInitialized(self) {
            if (self === void 0) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }

            return self;
          }

          function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
              return o.__proto__ || Object.getPrototypeOf(o);
            };
            return _getPrototypeOf(o);
          }

          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function");
            }

            subClass.prototype = Object.create(superClass && superClass.prototype, {
              constructor: {
                value: subClass,
                writable: true,
                configurable: true
              }
            });
            if (superClass) _setPrototypeOf(subClass, superClass);
          }

          function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
              o.__proto__ = p;
              return o;
            };

            return _setPrototypeOf(o, p);
          }
          /**
           * @class
           * @param {number} low  the low (signed) 32 bits of the Timestamp.
           * @param {number} high the high (signed) 32 bits of the Timestamp.
           * @return {Timestamp}
           */


          var Timestamp =
          /*#__PURE__*/
          function (_Long) {
            _inherits(Timestamp, _Long);

            function Timestamp(low, high) {
              var _this;

              _classCallCheck$1(this, Timestamp);

              if (long_1.isLong(low)) {
                _this = _possibleConstructorReturn(this, _getPrototypeOf(Timestamp).call(this, low.low, low.high));
              } else {
                _this = _possibleConstructorReturn(this, _getPrototypeOf(Timestamp).call(this, low, high));
              }

              return _possibleConstructorReturn(_this);
            }
            /**
             * Return the JSON value.
             *
             * @method
             * @return {String} the JSON representation.
             */


            _createClass$1(Timestamp, [{
              key: "toJSON",
              value: function toJSON() {
                return {
                  $timestamp: this.toString()
                };
              }
              /**
               * Returns a Timestamp represented by the given (32-bit) integer value.
               *
               * @method
               * @param {number} value the 32-bit integer in question.
               * @return {Timestamp} the timestamp.
               */

            }, {
              key: "toExtendedJSON",

              /**
               * @ignore
               */
              value: function toExtendedJSON() {
                return {
                  $timestamp: {
                    t: this.high,
                    i: this.low
                  }
                };
              }
              /**
               * @ignore
               */

            }], [{
              key: "fromInt",
              value: function fromInt(value) {
                return new Timestamp(long_1.fromInt(value));
              }
              /**
               * Returns a Timestamp representing the given number value, provided that it is a finite number. Otherwise, zero is returned.
               *
               * @method
               * @param {number} value the number in question.
               * @return {Timestamp} the timestamp.
               */

            }, {
              key: "fromNumber",
              value: function fromNumber(value) {
                return new Timestamp(long_1.fromNumber(value));
              }
              /**
               * Returns a Timestamp for the given high and low bits. Each is assumed to use 32 bits.
               *
               * @method
               * @param {number} lowBits the low 32-bits.
               * @param {number} highBits the high 32-bits.
               * @return {Timestamp} the timestamp.
               */

            }, {
              key: "fromBits",
              value: function fromBits(lowBits, highBits) {
                return new Timestamp(lowBits, highBits);
              }
              /**
               * Returns a Timestamp from the given string, optionally using the given radix.
               *
               * @method
               * @param {String} str the textual representation of the Timestamp.
               * @param {number} [opt_radix] the radix in which the text is written.
               * @return {Timestamp} the timestamp.
               */

            }, {
              key: "fromString",
              value: function fromString(str, opt_radix) {
                return new Timestamp(long_1.fromString(str, opt_radix));
              }
            }, {
              key: "fromExtendedJSON",
              value: function fromExtendedJSON(doc) {
                return new Timestamp(doc.$timestamp.i, doc.$timestamp.t);
              }
            }]);

            return Timestamp;
          }(long_1);

          Object.defineProperty(Timestamp.prototype, '_bsontype', {
            value: 'Timestamp'
          });
          var timestamp = Timestamp;
          var empty = {};
          var empty$1 =
          /*#__PURE__*/
          Object.freeze({
            "default": empty
          });
          var require$$0 = getCjsExportFromNamespace(empty$1);
          /* global window */

          /**
           * Normalizes our expected stringified form of a function across versions of node
           * @param {Function} fn The function to stringify
           */

          function normalizedFunctionString(fn) {
            return fn.toString().replace('function(', 'function (');
          }

          function insecureRandomBytes(size) {
            var result = new Uint8Array(size);

            for (var i = 0; i < size; ++i) {
              result[i] = Math.floor(Math.random() * 256);
            }

            return result;
          }

          var randomBytes = insecureRandomBytes;

          if (typeof window !== 'undefined' && window.crypto && window.crypto.getRandomValues) {
            randomBytes = function randomBytes(size) {
              return window.crypto.getRandomValues(new Uint8Array(size));
            };
          } else {
            try {
              randomBytes = require$$0.randomBytes;
            } catch (e) {} // keep the fallback
            // NOTE: in transpiled cases the above require might return null/undefined


            if (randomBytes == null) {
              randomBytes = insecureRandomBytes;
            }
          }

          var utils = {
            normalizedFunctionString: normalizedFunctionString,
            randomBytes: randomBytes
          }; // shim for using process in browser

          if (typeof global.setTimeout === 'function') ;

          if (typeof global.clearTimeout === 'function') ;


          var performance = global.performance || {};

          var performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function () {
            return new Date().getTime();
          }; // generate timestamp or delta
          var inherits;

          if (typeof Object.create === 'function') {
            inherits = function inherits(ctor, superCtor) {
              // implementation from standard node.js 'util' module
              ctor.super_ = superCtor;
              ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                  value: ctor,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
            };
          } else {
            inherits = function inherits(ctor, superCtor) {
              ctor.super_ = superCtor;

              var TempCtor = function TempCtor() {};

              TempCtor.prototype = superCtor.prototype;
              ctor.prototype = new TempCtor();
              ctor.prototype.constructor = ctor;
            };
          }

          var inherits$1 = inherits;

          function _typeof$1$1(obj) {
            if (typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol") {
              _typeof$1$1 = function _typeof$1(obj) {
                return _typeof(obj);
              };
            } else {
              _typeof$1$1 = function _typeof$1(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof(obj);
              };
            }

            return _typeof$1$1(obj);
          }

          var formatRegExp = /%[sdj%]/g;

          function format(f) {
            if (!isString(f)) {
              var objects = [];

              for (var i = 0; i < arguments.length; i++) {
                objects.push(inspect(arguments[i]));
              }

              return objects.join(' ');
            }

            var i = 1;
            var args = arguments;
            var len = args.length;
            var str = String(f).replace(formatRegExp, function (x) {
              if (x === '%%') return '%';
              if (i >= len) return x;

              switch (x) {
                case '%s':
                  return String(args[i++]);

                case '%d':
                  return Number(args[i++]);

                case '%j':
                  try {
                    return JSON.stringify(args[i++]);
                  } catch (_) {
                    return '[Circular]';
                  }

                default:
                  return x;
              }
            });

            for (var x = args[i]; i < len; x = args[++i]) {
              if (isNull(x) || !isObject(x)) {
                str += ' ' + x;
              } else {
                str += ' ' + inspect(x);
              }
            }

            return str;
          } // Returns a modified function which warns once by default.
          // If --no-deprecation is set, then it is a no-op.


          function deprecate(fn, msg) {
            // Allow for deprecating things in the process of starting up.
            if (isUndefined(global.process)) {
              return function () {
                return deprecate(fn, msg).apply(this, arguments);
              };
            }

            var warned = false;

            function deprecated() {
              if (!warned) {
                {
                  console.error(msg);
                }
                warned = true;
              }

              return fn.apply(this, arguments);
            }

            return deprecated;
          }

          var debugs = {};
          var debugEnviron;

          function debuglog(set) {
            if (isUndefined(debugEnviron)) debugEnviron =  '';
            set = set.toUpperCase();

            if (!debugs[set]) {
              if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
                var pid = 0;

                debugs[set] = function () {
                  var msg = format.apply(null, arguments);
                  console.error('%s %d: %s', set, pid, msg);
                };
              } else {
                debugs[set] = function () {};
              }
            }

            return debugs[set];
          }
          /**
           * Echos the value of a value. Trys to print the value out
           * in the best way possible given the different types.
           *
           * @param {Object} obj The object to print out.
           * @param {Object} opts Optional options object that alters the output.
           */

          /* legacy: obj, showHidden, depth, colors*/


          function inspect(obj, opts) {
            // default options
            var ctx = {
              seen: [],
              stylize: stylizeNoColor
            }; // legacy...

            if (arguments.length >= 3) ctx.depth = arguments[2];
            if (arguments.length >= 4) ctx.colors = arguments[3];

            if (isBoolean(opts)) {
              // legacy...
              ctx.showHidden = opts;
            } else if (opts) {
              // got an "options" object
              _extend(ctx, opts);
            } // set default options


            if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
            if (isUndefined(ctx.depth)) ctx.depth = 2;
            if (isUndefined(ctx.colors)) ctx.colors = false;
            if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
            if (ctx.colors) ctx.stylize = stylizeWithColor;
            return formatValue(ctx, obj, ctx.depth);
          } // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics


          inspect.colors = {
            'bold': [1, 22],
            'italic': [3, 23],
            'underline': [4, 24],
            'inverse': [7, 27],
            'white': [37, 39],
            'grey': [90, 39],
            'black': [30, 39],
            'blue': [34, 39],
            'cyan': [36, 39],
            'green': [32, 39],
            'magenta': [35, 39],
            'red': [31, 39],
            'yellow': [33, 39]
          }; // Don't use 'blue' not visible on cmd.exe

          inspect.styles = {
            'special': 'cyan',
            'number': 'yellow',
            'boolean': 'yellow',
            'undefined': 'grey',
            'null': 'bold',
            'string': 'green',
            'date': 'magenta',
            // "name": intentionally not styling
            'regexp': 'red'
          };

          function stylizeWithColor(str, styleType) {
            var style = inspect.styles[styleType];

            if (style) {
              return "\x1B[" + inspect.colors[style][0] + 'm' + str + "\x1B[" + inspect.colors[style][1] + 'm';
            } else {
              return str;
            }
          }

          function stylizeNoColor(str, styleType) {
            return str;
          }

          function arrayToHash(array) {
            var hash = {};
            array.forEach(function (val, idx) {
              hash[val] = true;
            });
            return hash;
          }

          function formatValue(ctx, value, recurseTimes) {
            // Provide a hook for user-specified inspect functions.
            // Check that value is an object with an inspect function on it
            if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
            value.inspect !== inspect && // Also filter out any prototype objects using the circular check.
            !(value.constructor && value.constructor.prototype === value)) {
              var ret = value.inspect(recurseTimes, ctx);

              if (!isString(ret)) {
                ret = formatValue(ctx, ret, recurseTimes);
              }

              return ret;
            } // Primitive types cannot have properties


            var primitive = formatPrimitive(ctx, value);

            if (primitive) {
              return primitive;
            } // Look up the keys of the object.


            var keys = Object.keys(value);
            var visibleKeys = arrayToHash(keys);

            if (ctx.showHidden) {
              keys = Object.getOwnPropertyNames(value);
            } // IE doesn't make error fields non-enumerable
            // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx


            if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
              return formatError(value);
            } // Some type of object without properties can be shortcutted.


            if (keys.length === 0) {
              if (isFunction(value)) {
                var name = value.name ? ': ' + value.name : '';
                return ctx.stylize('[Function' + name + ']', 'special');
              }

              if (isRegExp(value)) {
                return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
              }

              if (isDate(value)) {
                return ctx.stylize(Date.prototype.toString.call(value), 'date');
              }

              if (isError(value)) {
                return formatError(value);
              }
            }

            var base = '',
                array = false,
                braces = ['{', '}']; // Make Array say that they are Array

            if (isArray(value)) {
              array = true;
              braces = ['[', ']'];
            } // Make functions say that they are functions


            if (isFunction(value)) {
              var n = value.name ? ': ' + value.name : '';
              base = ' [Function' + n + ']';
            } // Make RegExps say that they are RegExps


            if (isRegExp(value)) {
              base = ' ' + RegExp.prototype.toString.call(value);
            } // Make dates with properties first say the date


            if (isDate(value)) {
              base = ' ' + Date.prototype.toUTCString.call(value);
            } // Make error with message first say the error


            if (isError(value)) {
              base = ' ' + formatError(value);
            }

            if (keys.length === 0 && (!array || value.length == 0)) {
              return braces[0] + base + braces[1];
            }

            if (recurseTimes < 0) {
              if (isRegExp(value)) {
                return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
              } else {
                return ctx.stylize('[Object]', 'special');
              }
            }

            ctx.seen.push(value);
            var output;

            if (array) {
              output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
            } else {
              output = keys.map(function (key) {
                return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
              });
            }

            ctx.seen.pop();
            return reduceToSingleString(output, base, braces);
          }

          function formatPrimitive(ctx, value) {
            if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');

            if (isString(value)) {
              var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
              return ctx.stylize(simple, 'string');
            }

            if (isNumber(value)) return ctx.stylize('' + value, 'number');
            if (isBoolean(value)) return ctx.stylize('' + value, 'boolean'); // For some reason typeof null is "object", so special case here.

            if (isNull(value)) return ctx.stylize('null', 'null');
          }

          function formatError(value) {
            return '[' + Error.prototype.toString.call(value) + ']';
          }

          function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
            var output = [];

            for (var i = 0, l = value.length; i < l; ++i) {
              if (hasOwnProperty(value, String(i))) {
                output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
              } else {
                output.push('');
              }
            }

            keys.forEach(function (key) {
              if (!key.match(/^\d+$/)) {
                output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
              }
            });
            return output;
          }

          function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
            var name, str, desc;
            desc = Object.getOwnPropertyDescriptor(value, key) || {
              value: value[key]
            };

            if (desc.get) {
              if (desc.set) {
                str = ctx.stylize('[Getter/Setter]', 'special');
              } else {
                str = ctx.stylize('[Getter]', 'special');
              }
            } else {
              if (desc.set) {
                str = ctx.stylize('[Setter]', 'special');
              }
            }

            if (!hasOwnProperty(visibleKeys, key)) {
              name = '[' + key + ']';
            }

            if (!str) {
              if (ctx.seen.indexOf(desc.value) < 0) {
                if (isNull(recurseTimes)) {
                  str = formatValue(ctx, desc.value, null);
                } else {
                  str = formatValue(ctx, desc.value, recurseTimes - 1);
                }

                if (str.indexOf('\n') > -1) {
                  if (array) {
                    str = str.split('\n').map(function (line) {
                      return '  ' + line;
                    }).join('\n').substr(2);
                  } else {
                    str = '\n' + str.split('\n').map(function (line) {
                      return '   ' + line;
                    }).join('\n');
                  }
                }
              } else {
                str = ctx.stylize('[Circular]', 'special');
              }
            }

            if (isUndefined(name)) {
              if (array && key.match(/^\d+$/)) {
                return str;
              }

              name = JSON.stringify('' + key);

              if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                name = name.substr(1, name.length - 2);
                name = ctx.stylize(name, 'name');
              } else {
                name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                name = ctx.stylize(name, 'string');
              }
            }

            return name + ': ' + str;
          }

          function reduceToSingleString(output, base, braces) {
            var length = output.reduce(function (prev, cur) {
              if (cur.indexOf('\n') >= 0) ;
              return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
            }, 0);

            if (length > 60) {
              return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
            }

            return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
          } // NOTE: These type checking functions intentionally don't use `instanceof`
          // because it is fragile and can be easily faked with `Object.create()`.


          function isArray(ar) {
            return Array.isArray(ar);
          }

          function isBoolean(arg) {
            return typeof arg === 'boolean';
          }

          function isNull(arg) {
            return arg === null;
          }

          function isNullOrUndefined(arg) {
            return arg == null;
          }

          function isNumber(arg) {
            return typeof arg === 'number';
          }

          function isString(arg) {
            return typeof arg === 'string';
          }

          function isSymbol(arg) {
            return _typeof$1$1(arg) === 'symbol';
          }

          function isUndefined(arg) {
            return arg === void 0;
          }

          function isRegExp(re) {
            return isObject(re) && objectToString(re) === '[object RegExp]';
          }

          function isObject(arg) {
            return _typeof$1$1(arg) === 'object' && arg !== null;
          }

          function isDate(d) {
            return isObject(d) && objectToString(d) === '[object Date]';
          }

          function isError(e) {
            return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
          }

          function isFunction(arg) {
            return typeof arg === 'function';
          }

          function isPrimitive(arg) {
            return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || _typeof$1$1(arg) === 'symbol' || // ES6 symbol
            typeof arg === 'undefined';
          }

          function isBuffer(maybeBuf) {
            return Buffer.isBuffer(maybeBuf);
          }

          function objectToString(o) {
            return Object.prototype.toString.call(o);
          }

          function pad(n) {
            return n < 10 ? '0' + n.toString(10) : n.toString(10);
          }

          var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']; // 26 Feb 16:19:34

          function timestamp$1() {
            var d = new Date();
            var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
            return [d.getDate(), months[d.getMonth()], time].join(' ');
          } // log is just a thin wrapper to console.log that prepends a timestamp


          function log() {
            console.log('%s - %s', timestamp$1(), format.apply(null, arguments));
          }

          function _extend(origin, add) {
            // Don't do anything if add isn't an object
            if (!add || !isObject(add)) return origin;
            var keys = Object.keys(add);
            var i = keys.length;

            while (i--) {
              origin[keys[i]] = add[keys[i]];
            }

            return origin;
          }

          function hasOwnProperty(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
          }

          var util = {
            inherits: inherits$1,
            _extend: _extend,
            log: log,
            isBuffer: isBuffer,
            isPrimitive: isPrimitive,
            isFunction: isFunction,
            isError: isError,
            isDate: isDate,
            isObject: isObject,
            isRegExp: isRegExp,
            isUndefined: isUndefined,
            isSymbol: isSymbol,
            isString: isString,
            isNumber: isNumber,
            isNullOrUndefined: isNullOrUndefined,
            isNull: isNull,
            isBoolean: isBoolean,
            isArray: isArray,
            inspect: inspect,
            deprecate: deprecate,
            format: format,
            debuglog: debuglog
          };
          var util$1 =
          /*#__PURE__*/
          Object.freeze({
            format: format,
            deprecate: deprecate,
            debuglog: debuglog,
            inspect: inspect,
            isArray: isArray,
            isBoolean: isBoolean,
            isNull: isNull,
            isNullOrUndefined: isNullOrUndefined,
            isNumber: isNumber,
            isString: isString,
            isSymbol: isSymbol,
            isUndefined: isUndefined,
            isRegExp: isRegExp,
            isObject: isObject,
            isDate: isDate,
            isError: isError,
            isFunction: isFunction,
            isPrimitive: isPrimitive,
            isBuffer: isBuffer,
            log: log,
            inherits: inherits$1,
            _extend: _extend,
            "default": util
          });
          var util$2 = getCjsExportFromNamespace(util$1);

          function _classCallCheck$2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties$2(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass$2(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties$2(Constructor.prototype, protoProps);
            if (staticProps) _defineProperties$2(Constructor, staticProps);
            return Constructor;
          }

          var Buffer$1 = buffer.Buffer;
          var randomBytes$1 = utils.randomBytes;
          var deprecate$1 = util$2.deprecate; // constants

          var PROCESS_UNIQUE = randomBytes$1(5); // Regular expression that checks for hex value

          var checkForHexRegExp = new RegExp('^[0-9a-fA-F]{24}$');
          var hasBufferType = false; // Check if buffer exists

          try {
            if (Buffer$1 && Buffer$1.from) hasBufferType = true;
          } catch (err) {
            hasBufferType = false;
          } // Precomputed hex table enables speedy hex string conversion


          var hexTable = [];

          for (var _i = 0; _i < 256; _i++) {
            hexTable[_i] = (_i <= 15 ? '0' : '') + _i.toString(16);
          } // Lookup tables


          var decodeLookup = [];
          var i = 0;

          while (i < 10) {
            decodeLookup[0x30 + i] = i++;
          }

          while (i < 16) {
            decodeLookup[0x41 - 10 + i] = decodeLookup[0x61 - 10 + i] = i++;
          }

          var _Buffer = Buffer$1;

          function convertToHex(bytes) {
            return bytes.toString('hex');
          }

          function makeObjectIdError(invalidString, index) {
            var invalidCharacter = invalidString[index];
            return new TypeError("ObjectId string \"".concat(invalidString, "\" contains invalid character \"").concat(invalidCharacter, "\" with character code (").concat(invalidString.charCodeAt(index), "). All character codes for a non-hex string must be less than 256."));
          }
          /**
           * A class representation of the BSON ObjectId type.
           */


          var ObjectId =
          /*#__PURE__*/
          function () {
            /**
             * Create an ObjectId type
             *
             * @param {(string|Buffer|number)} id Can be a 24 byte hex string, 12 byte binary Buffer, or a Number.
             * @property {number} generationTime The generation time of this ObjectId instance
             * @return {ObjectId} instance of ObjectId.
             */
            function ObjectId(id) {
              _classCallCheck$2(this, ObjectId); // Duck-typing to support ObjectId from different npm packages


              if (id instanceof ObjectId) return id; // The most common usecase (blank id, new objectId instance)

              if (id == null || typeof id === 'number') {
                // Generate a new id
                this.id = ObjectId.generate(id); // If we are caching the hex string

                if (ObjectId.cacheHexString) this.__id = this.toString('hex'); // Return the object

                return;
              } // Check if the passed in id is valid


              var valid = ObjectId.isValid(id); // Throw an error if it's not a valid setup

              if (!valid && id != null) {
                throw new TypeError('Argument passed in must be a single String of 12 bytes or a string of 24 hex characters');
              } else if (valid && typeof id === 'string' && id.length === 24 && hasBufferType) {
                return new ObjectId(Buffer$1.from(id, 'hex'));
              } else if (valid && typeof id === 'string' && id.length === 24) {
                return ObjectId.createFromHexString(id);
              } else if (id != null && id.length === 12) {
                // assume 12 byte string
                this.id = id;
              } else if (id != null && id.toHexString) {
                // Duck-typing to support ObjectId from different npm packages
                return ObjectId.createFromHexString(id.toHexString());
              } else {
                throw new TypeError('Argument passed in must be a single String of 12 bytes or a string of 24 hex characters');
              }

              if (ObjectId.cacheHexString) this.__id = this.toString('hex');
            }
            /**
             * Return the ObjectId id as a 24 byte hex string representation
             *
             * @method
             * @return {string} return the 24 byte hex string representation.
             */


            _createClass$2(ObjectId, [{
              key: "toHexString",
              value: function toHexString() {
                if (ObjectId.cacheHexString && this.__id) return this.__id;
                var hexString = '';

                if (!this.id || !this.id.length) {
                  throw new TypeError('invalid ObjectId, ObjectId.id must be either a string or a Buffer, but is [' + JSON.stringify(this.id) + ']');
                }

                if (this.id instanceof _Buffer) {
                  hexString = convertToHex(this.id);
                  if (ObjectId.cacheHexString) this.__id = hexString;
                  return hexString;
                }

                for (var _i2 = 0; _i2 < this.id.length; _i2++) {
                  var hexChar = hexTable[this.id.charCodeAt(_i2)];

                  if (typeof hexChar !== 'string') {
                    throw makeObjectIdError(this.id, _i2);
                  }

                  hexString += hexChar;
                }

                if (ObjectId.cacheHexString) this.__id = hexString;
                return hexString;
              }
              /**
               * Update the ObjectId index used in generating new ObjectId's on the driver
               *
               * @method
               * @return {number} returns next index value.
               * @ignore
               */

            }, {
              key: "toString",

              /**
               * Converts the id into a 24 byte hex string for printing
               *
               * @param {String} format The Buffer toString format parameter.
               * @return {String} return the 24 byte hex string representation.
               * @ignore
               */
              value: function toString(format) {
                // Is the id a buffer then use the buffer toString method to return the format
                if (this.id && this.id.copy) {
                  return this.id.toString(typeof format === 'string' ? format : 'hex');
                }

                return this.toHexString();
              }
              /**
               * Converts to its JSON representation.
               *
               * @return {String} return the 24 byte hex string representation.
               * @ignore
               */

            }, {
              key: "toJSON",
              value: function toJSON() {
                return this.toHexString();
              }
              /**
               * Compares the equality of this ObjectId with `otherID`.
               *
               * @method
               * @param {object} otherId ObjectId instance to compare against.
               * @return {boolean} the result of comparing two ObjectId's
               */

            }, {
              key: "equals",
              value: function equals(otherId) {
                if (otherId instanceof ObjectId) {
                  return this.toString() === otherId.toString();
                }

                if (typeof otherId === 'string' && ObjectId.isValid(otherId) && otherId.length === 12 && this.id instanceof _Buffer) {
                  return otherId === this.id.toString('binary');
                }

                if (typeof otherId === 'string' && ObjectId.isValid(otherId) && otherId.length === 24) {
                  return otherId.toLowerCase() === this.toHexString();
                }

                if (typeof otherId === 'string' && ObjectId.isValid(otherId) && otherId.length === 12) {
                  return otherId === this.id;
                }

                if (otherId != null && (otherId instanceof ObjectId || otherId.toHexString)) {
                  return otherId.toHexString() === this.toHexString();
                }

                return false;
              }
              /**
               * Returns the generation date (accurate up to the second) that this ID was generated.
               *
               * @method
               * @return {Date} the generation date
               */

            }, {
              key: "getTimestamp",
              value: function getTimestamp() {
                var timestamp = new Date();
                var time = this.id.readUInt32BE(0);
                timestamp.setTime(Math.floor(time) * 1000);
                return timestamp;
              }
              /**
               * @ignore
               */

            }, {
              key: "toExtendedJSON",

              /**
               * @ignore
               */
              value: function toExtendedJSON() {
                if (this.toHexString) return {
                  $oid: this.toHexString()
                };
                return {
                  $oid: this.toString('hex')
                };
              }
              /**
               * @ignore
               */

            }], [{
              key: "getInc",
              value: function getInc() {
                return ObjectId.index = (ObjectId.index + 1) % 0xffffff;
              }
              /**
               * Generate a 12 byte id buffer used in ObjectId's
               *
               * @method
               * @param {number} [time] optional parameter allowing to pass in a second based timestamp.
               * @return {Buffer} return the 12 byte id buffer string.
               */

            }, {
              key: "generate",
              value: function generate(time) {
                if ('number' !== typeof time) {
                  time = ~~(Date.now() / 1000);
                }

                var inc = ObjectId.getInc();
                var buffer$$1 = Buffer$1.alloc(12); // 4-byte timestamp

                buffer$$1[3] = time & 0xff;
                buffer$$1[2] = time >> 8 & 0xff;
                buffer$$1[1] = time >> 16 & 0xff;
                buffer$$1[0] = time >> 24 & 0xff; // 5-byte process unique

                buffer$$1[4] = PROCESS_UNIQUE[0];
                buffer$$1[5] = PROCESS_UNIQUE[1];
                buffer$$1[6] = PROCESS_UNIQUE[2];
                buffer$$1[7] = PROCESS_UNIQUE[3];
                buffer$$1[8] = PROCESS_UNIQUE[4]; // 3-byte counter

                buffer$$1[11] = inc & 0xff;
                buffer$$1[10] = inc >> 8 & 0xff;
                buffer$$1[9] = inc >> 16 & 0xff;
                return buffer$$1;
              }
            }, {
              key: "createPk",
              value: function createPk() {
                return new ObjectId();
              }
              /**
               * Creates an ObjectId from a second based number, with the rest of the ObjectId zeroed out. Used for comparisons or sorting the ObjectId.
               *
               * @method
               * @param {number} time an integer number representing a number of seconds.
               * @return {ObjectId} return the created ObjectId
               */

            }, {
              key: "createFromTime",
              value: function createFromTime(time) {
                var buffer$$1 = Buffer$1.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]); // Encode time into first 4 bytes

                buffer$$1[3] = time & 0xff;
                buffer$$1[2] = time >> 8 & 0xff;
                buffer$$1[1] = time >> 16 & 0xff;
                buffer$$1[0] = time >> 24 & 0xff; // Return the new objectId

                return new ObjectId(buffer$$1);
              }
              /**
               * Creates an ObjectId from a hex string representation of an ObjectId.
               *
               * @method
               * @param {string} hexString create a ObjectId from a passed in 24 byte hexstring.
               * @return {ObjectId} return the created ObjectId
               */

            }, {
              key: "createFromHexString",
              value: function createFromHexString(string) {
                // Throw an error if it's not a valid setup
                if (typeof string === 'undefined' || string != null && string.length !== 24) {
                  throw new TypeError('Argument passed in must be a single String of 12 bytes or a string of 24 hex characters');
                } // Use Buffer.from method if available


                if (hasBufferType) return new ObjectId(Buffer$1.from(string, 'hex')); // Calculate lengths

                var array = new _Buffer(12);
                var n = 0;
                var i = 0;

                while (i < 24) {
                  array[n++] = decodeLookup[string.charCodeAt(i++)] << 4 | decodeLookup[string.charCodeAt(i++)];
                }

                return new ObjectId(array);
              }
              /**
               * Checks if a value is a valid bson ObjectId
               *
               * @method
               * @return {boolean} return true if the value is a valid bson ObjectId, return false otherwise.
               */

            }, {
              key: "isValid",
              value: function isValid(id) {
                if (id == null) return false;

                if (typeof id === 'number') {
                  return true;
                }

                if (typeof id === 'string') {
                  return id.length === 12 || id.length === 24 && checkForHexRegExp.test(id);
                }

                if (id instanceof ObjectId) {
                  return true;
                }

                if (id instanceof _Buffer && id.length === 12) {
                  return true;
                } // Duck-Typing detection of ObjectId like objects


                if (id.toHexString) {
                  return id.id.length === 12 || id.id.length === 24 && checkForHexRegExp.test(id.id);
                }

                return false;
              }
            }, {
              key: "fromExtendedJSON",
              value: function fromExtendedJSON(doc) {
                return new ObjectId(doc.$oid);
              }
            }]);

            return ObjectId;
          }(); // Deprecated methods


          ObjectId.get_inc = deprecate$1(function () {
            return ObjectId.getInc();
          }, 'Please use the static `ObjectId.getInc()` instead');
          ObjectId.prototype.get_inc = deprecate$1(function () {
            return ObjectId.getInc();
          }, 'Please use the static `ObjectId.getInc()` instead');
          ObjectId.prototype.getInc = deprecate$1(function () {
            return ObjectId.getInc();
          }, 'Please use the static `ObjectId.getInc()` instead');
          ObjectId.prototype.generate = deprecate$1(function (time) {
            return ObjectId.generate(time);
          }, 'Please use the static `ObjectId.generate(time)` instead');
          /**
           * @ignore
           */

          Object.defineProperty(ObjectId.prototype, 'generationTime', {
            enumerable: true,
            get: function get() {
              return this.id[3] | this.id[2] << 8 | this.id[1] << 16 | this.id[0] << 24;
            },
            set: function set(value) {
              // Encode time into first 4 bytes
              this.id[3] = value & 0xff;
              this.id[2] = value >> 8 & 0xff;
              this.id[1] = value >> 16 & 0xff;
              this.id[0] = value >> 24 & 0xff;
            }
          });
          /**
           * Converts to a string representation of this Id.
           *
           * @return {String} return the 24 byte hex string representation.
           * @ignore
           */

          ObjectId.prototype[util$2.inspect.custom || 'inspect'] = ObjectId.prototype.toString;
          /**
           * @ignore
           */

          ObjectId.index = ~~(Math.random() * 0xffffff); // In 4.0.0 and 4.0.1, this property name was changed to ObjectId to match the class name.
          // This caused interoperability problems with previous versions of the library, so in
          // later builds we changed it back to ObjectID (capital D) to match legacy implementations.

          Object.defineProperty(ObjectId.prototype, '_bsontype', {
            value: 'ObjectID'
          });
          var objectid = ObjectId;

          function _classCallCheck$3(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties$3(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass$3(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties$3(Constructor.prototype, protoProps);
            if (staticProps) _defineProperties$3(Constructor, staticProps);
            return Constructor;
          }

          function alphabetize(str) {
            return str.split('').sort().join('');
          }
          /**
           * A class representation of the BSON RegExp type.
           */


          var BSONRegExp =
          /*#__PURE__*/
          function () {
            /**
             * Create a RegExp type
             *
             * @param {string} pattern The regular expression pattern to match
             * @param {string} options The regular expression options
             */
            function BSONRegExp(pattern, options) {
              _classCallCheck$3(this, BSONRegExp); // Execute


              this.pattern = pattern || '';
              this.options = options ? alphabetize(options) : ''; // Validate options

              for (var i = 0; i < this.options.length; i++) {
                if (!(this.options[i] === 'i' || this.options[i] === 'm' || this.options[i] === 'x' || this.options[i] === 'l' || this.options[i] === 's' || this.options[i] === 'u')) {
                  throw new Error("The regular expression option [".concat(this.options[i], "] is not supported"));
                }
              }
            }
            /**
             * @ignore
             */


            _createClass$3(BSONRegExp, [{
              key: "toExtendedJSON",
              value: function toExtendedJSON() {
                return {
                  $regularExpression: {
                    pattern: this.pattern,
                    options: this.options
                  }
                };
              }
              /**
               * @ignore
               */

            }], [{
              key: "fromExtendedJSON",
              value: function fromExtendedJSON(doc) {
                return new BSONRegExp(doc.$regularExpression.pattern, doc.$regularExpression.options.split('').sort().join(''));
              }
            }]);

            return BSONRegExp;
          }();

          Object.defineProperty(BSONRegExp.prototype, '_bsontype', {
            value: 'BSONRegExp'
          });
          var regexp = BSONRegExp;
          /**
           * A class representation of the BSON Symbol type.
           */

          function _classCallCheck$4(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties$4(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass$4(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties$4(Constructor.prototype, protoProps);
            if (staticProps) _defineProperties$4(Constructor, staticProps);
            return Constructor;
          }

          var BSONSymbol =
          /*#__PURE__*/
          function () {
            /**
             * Create a Symbol type
             *
             * @param {string} value the string representing the symbol.
             */
            function BSONSymbol(value) {
              _classCallCheck$4(this, BSONSymbol);

              this.value = value;
            }
            /**
             * Access the wrapped string value.
             *
             * @method
             * @return {String} returns the wrapped string.
             */


            _createClass$4(BSONSymbol, [{
              key: "valueOf",
              value: function valueOf() {
                return this.value;
              }
              /**
               * @ignore
               */

            }, {
              key: "toString",
              value: function toString() {
                return this.value;
              }
              /**
               * @ignore
               */

            }, {
              key: "inspect",
              value: function inspect() {
                return this.value;
              }
              /**
               * @ignore
               */

            }, {
              key: "toJSON",
              value: function toJSON() {
                return this.value;
              }
              /**
               * @ignore
               */

            }, {
              key: "toExtendedJSON",
              value: function toExtendedJSON() {
                return {
                  $symbol: this.value
                };
              }
              /**
               * @ignore
               */

            }], [{
              key: "fromExtendedJSON",
              value: function fromExtendedJSON(doc) {
                return new BSONSymbol(doc.$symbol);
              }
            }]);

            return BSONSymbol;
          }();

          Object.defineProperty(BSONSymbol.prototype, '_bsontype', {
            value: 'Symbol'
          });
          var symbol = BSONSymbol;
          /**
           * A class representation of a BSON Int32 type.
           */

          function _classCallCheck$5(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties$5(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass$5(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties$5(Constructor.prototype, protoProps);
            if (staticProps) _defineProperties$5(Constructor, staticProps);
            return Constructor;
          }

          var Int32 =
          /*#__PURE__*/
          function () {
            /**
             * Create an Int32 type
             *
             * @param {number} value the number we want to represent as an int32.
             * @return {Int32}
             */
            function Int32(value) {
              _classCallCheck$5(this, Int32);

              this.value = value;
            }
            /**
             * Access the number value.
             *
             * @method
             * @return {number} returns the wrapped int32 number.
             */


            _createClass$5(Int32, [{
              key: "valueOf",
              value: function valueOf() {
                return this.value;
              }
              /**
               * @ignore
               */

            }, {
              key: "toJSON",
              value: function toJSON() {
                return this.value;
              }
              /**
               * @ignore
               */

            }, {
              key: "toExtendedJSON",
              value: function toExtendedJSON(options) {
                if (options && options.relaxed) return this.value;
                return {
                  $numberInt: this.value.toString()
                };
              }
              /**
               * @ignore
               */

            }], [{
              key: "fromExtendedJSON",
              value: function fromExtendedJSON(doc, options) {
                return options && options.relaxed ? parseInt(doc.$numberInt, 10) : new Int32(doc.$numberInt);
              }
            }]);

            return Int32;
          }();

          Object.defineProperty(Int32.prototype, '_bsontype', {
            value: 'Int32'
          });
          var int_32 = Int32;
          /**
           * A class representation of the BSON Code type.
           */

          function _classCallCheck$6(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties$6(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass$6(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties$6(Constructor.prototype, protoProps);
            if (staticProps) _defineProperties$6(Constructor, staticProps);
            return Constructor;
          }

          var Code =
          /*#__PURE__*/
          function () {
            /**
             * Create a Code type
             *
             * @param {(string|function)} code a string or function.
             * @param {Object} [scope] an optional scope for the function.
             * @return {Code}
             */
            function Code(code, scope) {
              _classCallCheck$6(this, Code);

              this.code = code;
              this.scope = scope;
            }
            /**
             * @ignore
             */


            _createClass$6(Code, [{
              key: "toJSON",
              value: function toJSON() {
                return {
                  scope: this.scope,
                  code: this.code
                };
              }
              /**
               * @ignore
               */

            }, {
              key: "toExtendedJSON",
              value: function toExtendedJSON() {
                if (this.scope) {
                  return {
                    $code: this.code,
                    $scope: this.scope
                  };
                }

                return {
                  $code: this.code
                };
              }
              /**
               * @ignore
               */

            }], [{
              key: "fromExtendedJSON",
              value: function fromExtendedJSON(doc) {
                return new Code(doc.$code, doc.$scope);
              }
            }]);

            return Code;
          }();

          Object.defineProperty(Code.prototype, '_bsontype', {
            value: 'Code'
          });
          var code = Code;
          var Buffer$2 = buffer.Buffer;
          var PARSE_STRING_REGEXP = /^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/;
          var PARSE_INF_REGEXP = /^(\+|-)?(Infinity|inf)$/i;
          var PARSE_NAN_REGEXP = /^(\+|-)?NaN$/i;
          var EXPONENT_MAX = 6111;
          var EXPONENT_MIN = -6176;
          var EXPONENT_BIAS = 6176;
          var MAX_DIGITS = 34; // Nan value bits as 32 bit values (due to lack of longs)

          var NAN_BUFFER = [0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00].reverse(); // Infinity value bits 32 bit values (due to lack of longs)

          var INF_NEGATIVE_BUFFER = [0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00].reverse();
          var INF_POSITIVE_BUFFER = [0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00].reverse();
          var EXPONENT_REGEX = /^([-+])?(\d+)?$/; // Detect if the value is a digit

          function isDigit(value) {
            return !isNaN(parseInt(value, 10));
          } // Divide two uint128 values


          function divideu128(value) {
            var DIVISOR = long_1.fromNumber(1000 * 1000 * 1000);

            var _rem = long_1.fromNumber(0);

            if (!value.parts[0] && !value.parts[1] && !value.parts[2] && !value.parts[3]) {
              return {
                quotient: value,
                rem: _rem
              };
            }

            for (var i = 0; i <= 3; i++) {
              // Adjust remainder to match value of next dividend
              _rem = _rem.shiftLeft(32); // Add the divided to _rem

              _rem = _rem.add(new long_1(value.parts[i], 0));
              value.parts[i] = _rem.div(DIVISOR).low;
              _rem = _rem.modulo(DIVISOR);
            }

            return {
              quotient: value,
              rem: _rem
            };
          } // Multiply two Long values and return the 128 bit value


          function multiply64x2(left, right) {
            if (!left && !right) {
              return {
                high: long_1.fromNumber(0),
                low: long_1.fromNumber(0)
              };
            }

            var leftHigh = left.shiftRightUnsigned(32);
            var leftLow = new long_1(left.getLowBits(), 0);
            var rightHigh = right.shiftRightUnsigned(32);
            var rightLow = new long_1(right.getLowBits(), 0);
            var productHigh = leftHigh.multiply(rightHigh);
            var productMid = leftHigh.multiply(rightLow);
            var productMid2 = leftLow.multiply(rightHigh);
            var productLow = leftLow.multiply(rightLow);
            productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
            productMid = new long_1(productMid.getLowBits(), 0).add(productMid2).add(productLow.shiftRightUnsigned(32));
            productHigh = productHigh.add(productMid.shiftRightUnsigned(32));
            productLow = productMid.shiftLeft(32).add(new long_1(productLow.getLowBits(), 0)); // Return the 128 bit result

            return {
              high: productHigh,
              low: productLow
            };
          }

          function lessThan(left, right) {
            // Make values unsigned
            var uhleft = left.high >>> 0;
            var uhright = right.high >>> 0; // Compare high bits first

            if (uhleft < uhright) {
              return true;
            } else if (uhleft === uhright) {
              var ulleft = left.low >>> 0;
              var ulright = right.low >>> 0;
              if (ulleft < ulright) return true;
            }

            return false;
          }

          function invalidErr(string, message) {
            throw new TypeError("\"".concat(string, "\" is not a valid Decimal128 string - ").concat(message));
          }
          /**
           * A class representation of the BSON Decimal128 type.
           *
           * @class
           * @param {Buffer} bytes a buffer containing the raw Decimal128 bytes.
           * @return {Double}
           */


          function Decimal128(bytes) {
            this.bytes = bytes;
          }
          /**
           * Create a Decimal128 instance from a string representation
           *
           * @method
           * @param {string} string a numeric string representation.
           * @return {Decimal128} returns a Decimal128 instance.
           */


          Decimal128.fromString = function (string) {
            // Parse state tracking
            var isNegative = false;
            var sawRadix = false;
            var foundNonZero = false; // Total number of significant digits (no leading or trailing zero)

            var significantDigits = 0; // Total number of significand digits read

            var nDigitsRead = 0; // Total number of digits (no leading zeros)

            var nDigits = 0; // The number of the digits after radix

            var radixPosition = 0; // The index of the first non-zero in *str*

            var firstNonZero = 0; // Digits Array

            var digits = [0]; // The number of digits in digits

            var nDigitsStored = 0; // Insertion pointer for digits

            var digitsInsert = 0; // The index of the first non-zero digit

            var firstDigit = 0; // The index of the last digit

            var lastDigit = 0; // Exponent

            var exponent = 0; // loop index over array

            var i = 0; // The high 17 digits of the significand

            var significandHigh = [0, 0]; // The low 17 digits of the significand

            var significandLow = [0, 0]; // The biased exponent

            var biasedExponent = 0; // Read index

            var index = 0; // Naively prevent against REDOS attacks.
            // TODO: implementing a custom parsing for this, or refactoring the regex would yield
            //       further gains.

            if (string.length >= 7000) {
              throw new TypeError('' + string + ' not a valid Decimal128 string');
            } // Results


            var stringMatch = string.match(PARSE_STRING_REGEXP);
            var infMatch = string.match(PARSE_INF_REGEXP);
            var nanMatch = string.match(PARSE_NAN_REGEXP); // Validate the string

            if (!stringMatch && !infMatch && !nanMatch || string.length === 0) {
              throw new TypeError('' + string + ' not a valid Decimal128 string');
            }

            if (stringMatch) {
              // full_match = stringMatch[0]
              // sign = stringMatch[1]
              var unsignedNumber = stringMatch[2]; // stringMatch[3] is undefined if a whole number (ex "1", 12")
              // but defined if a number w/ decimal in it (ex "1.0, 12.2")

              var e = stringMatch[4];
              var expSign = stringMatch[5];
              var expNumber = stringMatch[6]; // they provided e, but didn't give an exponent number. for ex "1e"

              if (e && expNumber === undefined) invalidErr(string, 'missing exponent power'); // they provided e, but didn't give a number before it. for ex "e1"

              if (e && unsignedNumber === undefined) invalidErr(string, 'missing exponent base');

              if (e === undefined && (expSign || expNumber)) {
                invalidErr(string, 'missing e before exponent');
              }
            } // Get the negative or positive sign


            if (string[index] === '+' || string[index] === '-') {
              isNegative = string[index++] === '-';
            } // Check if user passed Infinity or NaN


            if (!isDigit(string[index]) && string[index] !== '.') {
              if (string[index] === 'i' || string[index] === 'I') {
                return new Decimal128(Buffer$2.from(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
              } else if (string[index] === 'N') {
                return new Decimal128(Buffer$2.from(NAN_BUFFER));
              }
            } // Read all the digits


            while (isDigit(string[index]) || string[index] === '.') {
              if (string[index] === '.') {
                if (sawRadix) invalidErr(string, 'contains multiple periods');
                sawRadix = true;
                index = index + 1;
                continue;
              }

              if (nDigitsStored < 34) {
                if (string[index] !== '0' || foundNonZero) {
                  if (!foundNonZero) {
                    firstNonZero = nDigitsRead;
                  }

                  foundNonZero = true; // Only store 34 digits

                  digits[digitsInsert++] = parseInt(string[index], 10);
                  nDigitsStored = nDigitsStored + 1;
                }
              }

              if (foundNonZero) nDigits = nDigits + 1;
              if (sawRadix) radixPosition = radixPosition + 1;
              nDigitsRead = nDigitsRead + 1;
              index = index + 1;
            }

            if (sawRadix && !nDigitsRead) throw new TypeError('' + string + ' not a valid Decimal128 string'); // Read exponent if exists

            if (string[index] === 'e' || string[index] === 'E') {
              // Read exponent digits
              var match = string.substr(++index).match(EXPONENT_REGEX); // No digits read

              if (!match || !match[2]) return new Decimal128(Buffer$2.from(NAN_BUFFER)); // Get exponent

              exponent = parseInt(match[0], 10); // Adjust the index

              index = index + match[0].length;
            } // Return not a number


            if (string[index]) return new Decimal128(Buffer$2.from(NAN_BUFFER)); // Done reading input
            // Find first non-zero digit in digits

            firstDigit = 0;

            if (!nDigitsStored) {
              firstDigit = 0;
              lastDigit = 0;
              digits[0] = 0;
              nDigits = 1;
              nDigitsStored = 1;
              significantDigits = 0;
            } else {
              lastDigit = nDigitsStored - 1;
              significantDigits = nDigits;

              if (significantDigits !== 1) {
                while (string[firstNonZero + significantDigits - 1] === '0') {
                  significantDigits = significantDigits - 1;
                }
              }
            } // Normalization of exponent
            // Correct exponent based on radix position, and shift significand as needed
            // to represent user input
            // Overflow prevention


            if (exponent <= radixPosition && radixPosition - exponent > 1 << 14) {
              exponent = EXPONENT_MIN;
            } else {
              exponent = exponent - radixPosition;
            } // Attempt to normalize the exponent


            while (exponent > EXPONENT_MAX) {
              // Shift exponent to significand and decrease
              lastDigit = lastDigit + 1;

              if (lastDigit - firstDigit > MAX_DIGITS) {
                // Check if we have a zero then just hard clamp, otherwise fail
                var digitsString = digits.join('');

                if (digitsString.match(/^0+$/)) {
                  exponent = EXPONENT_MAX;
                  break;
                }

                invalidErr(string, 'overflow');
              }

              exponent = exponent - 1;
            }

            while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {
              // Shift last digit. can only do this if < significant digits than # stored.
              if (lastDigit === 0 && significantDigits < nDigitsStored) {
                exponent = EXPONENT_MIN;
                significantDigits = 0;
                break;
              }

              if (nDigitsStored < nDigits) {
                // adjust to match digits not stored
                nDigits = nDigits - 1;
              } else {
                // adjust to round
                lastDigit = lastDigit - 1;
              }

              if (exponent < EXPONENT_MAX) {
                exponent = exponent + 1;
              } else {
                // Check if we have a zero then just hard clamp, otherwise fail
                var _digitsString = digits.join('');

                if (_digitsString.match(/^0+$/)) {
                  exponent = EXPONENT_MAX;
                  break;
                }

                invalidErr(string, 'overflow');
              }
            } // Round
            // We've normalized the exponent, but might still need to round.


            if (lastDigit - firstDigit + 1 < significantDigits) {
              var endOfString = nDigitsRead; // If we have seen a radix point, 'string' is 1 longer than we have
              // documented with ndigits_read, so inc the position of the first nonzero
              // digit and the position that digits are read to.

              if (sawRadix) {
                firstNonZero = firstNonZero + 1;
                endOfString = endOfString + 1;
              } // if negative, we need to increment again to account for - sign at start.


              if (isNegative) {
                firstNonZero = firstNonZero + 1;
                endOfString = endOfString + 1;
              }

              var roundDigit = parseInt(string[firstNonZero + lastDigit + 1], 10);
              var roundBit = 0;

              if (roundDigit >= 5) {
                roundBit = 1;

                if (roundDigit === 5) {
                  roundBit = digits[lastDigit] % 2 === 1;

                  for (i = firstNonZero + lastDigit + 2; i < endOfString; i++) {
                    if (parseInt(string[i], 10)) {
                      roundBit = 1;
                      break;
                    }
                  }
                }
              }

              if (roundBit) {
                var dIdx = lastDigit;

                for (; dIdx >= 0; dIdx--) {
                  if (++digits[dIdx] > 9) {
                    digits[dIdx] = 0; // overflowed most significant digit

                    if (dIdx === 0) {
                      if (exponent < EXPONENT_MAX) {
                        exponent = exponent + 1;
                        digits[dIdx] = 1;
                      } else {
                        return new Decimal128(Buffer$2.from(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER));
                      }
                    }
                  }
                }
              }
            } // Encode significand
            // The high 17 digits of the significand


            significandHigh = long_1.fromNumber(0); // The low 17 digits of the significand

            significandLow = long_1.fromNumber(0); // read a zero

            if (significantDigits === 0) {
              significandHigh = long_1.fromNumber(0);
              significandLow = long_1.fromNumber(0);
            } else if (lastDigit - firstDigit < 17) {
              var _dIdx = firstDigit;
              significandLow = long_1.fromNumber(digits[_dIdx++]);
              significandHigh = new long_1(0, 0);

              for (; _dIdx <= lastDigit; _dIdx++) {
                significandLow = significandLow.multiply(long_1.fromNumber(10));
                significandLow = significandLow.add(long_1.fromNumber(digits[_dIdx]));
              }
            } else {
              var _dIdx2 = firstDigit;
              significandHigh = long_1.fromNumber(digits[_dIdx2++]);

              for (; _dIdx2 <= lastDigit - 17; _dIdx2++) {
                significandHigh = significandHigh.multiply(long_1.fromNumber(10));
                significandHigh = significandHigh.add(long_1.fromNumber(digits[_dIdx2]));
              }

              significandLow = long_1.fromNumber(digits[_dIdx2++]);

              for (; _dIdx2 <= lastDigit; _dIdx2++) {
                significandLow = significandLow.multiply(long_1.fromNumber(10));
                significandLow = significandLow.add(long_1.fromNumber(digits[_dIdx2]));
              }
            }

            var significand = multiply64x2(significandHigh, long_1.fromString('100000000000000000'));
            significand.low = significand.low.add(significandLow);

            if (lessThan(significand.low, significandLow)) {
              significand.high = significand.high.add(long_1.fromNumber(1));
            } // Biased exponent


            biasedExponent = exponent + EXPONENT_BIAS;
            var dec = {
              low: long_1.fromNumber(0),
              high: long_1.fromNumber(0)
            }; // Encode combination, exponent, and significand.

            if (significand.high.shiftRightUnsigned(49).and(long_1.fromNumber(1)).equals(long_1.fromNumber(1))) {
              // Encode '11' into bits 1 to 3
              dec.high = dec.high.or(long_1.fromNumber(0x3).shiftLeft(61));
              dec.high = dec.high.or(long_1.fromNumber(biasedExponent).and(long_1.fromNumber(0x3fff).shiftLeft(47)));
              dec.high = dec.high.or(significand.high.and(long_1.fromNumber(0x7fffffffffff)));
            } else {
              dec.high = dec.high.or(long_1.fromNumber(biasedExponent & 0x3fff).shiftLeft(49));
              dec.high = dec.high.or(significand.high.and(long_1.fromNumber(0x1ffffffffffff)));
            }

            dec.low = significand.low; // Encode sign

            if (isNegative) {
              dec.high = dec.high.or(long_1.fromString('9223372036854775808'));
            } // Encode into a buffer


            var buffer$$1 = Buffer$2.alloc(16);
            index = 0; // Encode the low 64 bits of the decimal
            // Encode low bits

            buffer$$1[index++] = dec.low.low & 0xff;
            buffer$$1[index++] = dec.low.low >> 8 & 0xff;
            buffer$$1[index++] = dec.low.low >> 16 & 0xff;
            buffer$$1[index++] = dec.low.low >> 24 & 0xff; // Encode high bits

            buffer$$1[index++] = dec.low.high & 0xff;
            buffer$$1[index++] = dec.low.high >> 8 & 0xff;
            buffer$$1[index++] = dec.low.high >> 16 & 0xff;
            buffer$$1[index++] = dec.low.high >> 24 & 0xff; // Encode the high 64 bits of the decimal
            // Encode low bits

            buffer$$1[index++] = dec.high.low & 0xff;
            buffer$$1[index++] = dec.high.low >> 8 & 0xff;
            buffer$$1[index++] = dec.high.low >> 16 & 0xff;
            buffer$$1[index++] = dec.high.low >> 24 & 0xff; // Encode high bits

            buffer$$1[index++] = dec.high.high & 0xff;
            buffer$$1[index++] = dec.high.high >> 8 & 0xff;
            buffer$$1[index++] = dec.high.high >> 16 & 0xff;
            buffer$$1[index++] = dec.high.high >> 24 & 0xff; // Return the new Decimal128

            return new Decimal128(buffer$$1);
          }; // Extract least significant 5 bits


          var COMBINATION_MASK = 0x1f; // Extract least significant 14 bits

          var EXPONENT_MASK = 0x3fff; // Value of combination field for Inf

          var COMBINATION_INFINITY = 30; // Value of combination field for NaN

          var COMBINATION_NAN = 31;
          /**
           * Create a string representation of the raw Decimal128 value
           *
           * @method
           * @return {string} returns a Decimal128 string representation.
           */

          Decimal128.prototype.toString = function () {
            // Note: bits in this routine are referred to starting at 0,
            // from the sign bit, towards the coefficient.
            // bits 0 - 31
            var high; // bits 32 - 63

            var midh; // bits 64 - 95

            var midl; // bits 96 - 127

            var low; // bits 1 - 5

            var combination; // decoded biased exponent (14 bits)

            var biased_exponent; // the number of significand digits

            var significand_digits = 0; // the base-10 digits in the significand

            var significand = new Array(36);

            for (var i = 0; i < significand.length; i++) {
              significand[i] = 0;
            } // read pointer into significand


            var index = 0; // unbiased exponent

            var exponent; // the exponent if scientific notation is used

            var scientific_exponent; // true if the number is zero

            var is_zero = false; // the most signifcant significand bits (50-46)

            var significand_msb; // temporary storage for significand decoding

            var significand128 = {
              parts: new Array(4)
            }; // indexing variables

            var j, k; // Output string

            var string = []; // Unpack index

            index = 0; // Buffer reference

            var buffer$$1 = this.bytes; // Unpack the low 64bits into a long

            low = buffer$$1[index++] | buffer$$1[index++] << 8 | buffer$$1[index++] << 16 | buffer$$1[index++] << 24;
            midl = buffer$$1[index++] | buffer$$1[index++] << 8 | buffer$$1[index++] << 16 | buffer$$1[index++] << 24; // Unpack the high 64bits into a long

            midh = buffer$$1[index++] | buffer$$1[index++] << 8 | buffer$$1[index++] << 16 | buffer$$1[index++] << 24;
            high = buffer$$1[index++] | buffer$$1[index++] << 8 | buffer$$1[index++] << 16 | buffer$$1[index++] << 24; // Unpack index

            index = 0; // Create the state of the decimal

            var dec = {
              low: new long_1(low, midl),
              high: new long_1(midh, high)
            };

            if (dec.high.lessThan(long_1.ZERO)) {
              string.push('-');
            } // Decode combination field and exponent


            combination = high >> 26 & COMBINATION_MASK;

            if (combination >> 3 === 3) {
              // Check for 'special' values
              if (combination === COMBINATION_INFINITY) {
                return string.join('') + 'Infinity';
              } else if (combination === COMBINATION_NAN) {
                return 'NaN';
              } else {
                biased_exponent = high >> 15 & EXPONENT_MASK;
                significand_msb = 0x08 + (high >> 14 & 0x01);
              }
            } else {
              significand_msb = high >> 14 & 0x07;
              biased_exponent = high >> 17 & EXPONENT_MASK;
            }

            exponent = biased_exponent - EXPONENT_BIAS; // Create string of significand digits
            // Convert the 114-bit binary number represented by
            // (significand_high, significand_low) to at most 34 decimal
            // digits through modulo and division.

            significand128.parts[0] = (high & 0x3fff) + ((significand_msb & 0xf) << 14);
            significand128.parts[1] = midh;
            significand128.parts[2] = midl;
            significand128.parts[3] = low;

            if (significand128.parts[0] === 0 && significand128.parts[1] === 0 && significand128.parts[2] === 0 && significand128.parts[3] === 0) {
              is_zero = true;
            } else {
              for (k = 3; k >= 0; k--) {
                var least_digits = 0; // Peform the divide

                var result = divideu128(significand128);
                significand128 = result.quotient;
                least_digits = result.rem.low; // We now have the 9 least significant digits (in base 2).
                // Convert and output to string.

                if (!least_digits) continue;

                for (j = 8; j >= 0; j--) {
                  // significand[k * 9 + j] = Math.round(least_digits % 10);
                  significand[k * 9 + j] = least_digits % 10; // least_digits = Math.round(least_digits / 10);

                  least_digits = Math.floor(least_digits / 10);
                }
              }
            } // Output format options:
            // Scientific - [-]d.dddE(+/-)dd or [-]dE(+/-)dd
            // Regular    - ddd.ddd


            if (is_zero) {
              significand_digits = 1;
              significand[index] = 0;
            } else {
              significand_digits = 36;

              while (!significand[index]) {
                significand_digits = significand_digits - 1;
                index = index + 1;
              }
            }

            scientific_exponent = significand_digits - 1 + exponent; // The scientific exponent checks are dictated by the string conversion
            // specification and are somewhat arbitrary cutoffs.
            //
            // We must check exponent > 0, because if this is the case, the number
            // has trailing zeros.  However, we *cannot* output these trailing zeros,
            // because doing so would change the precision of the value, and would
            // change stored data if the string converted number is round tripped.

            if (scientific_exponent >= 34 || scientific_exponent <= -7 || exponent > 0) {
              // Scientific format
              // if there are too many significant digits, we should just be treating numbers
              // as + or - 0 and using the non-scientific exponent (this is for the "invalid
              // representation should be treated as 0/-0" spec cases in decimal128-1.json)
              if (significand_digits > 34) {
                string.push(0);
                if (exponent > 0) string.push('E+' + exponent);else if (exponent < 0) string.push('E' + exponent);
                return string.join('');
              }

              string.push(significand[index++]);
              significand_digits = significand_digits - 1;

              if (significand_digits) {
                string.push('.');
              }

              for (var _i = 0; _i < significand_digits; _i++) {
                string.push(significand[index++]);
              } // Exponent


              string.push('E');

              if (scientific_exponent > 0) {
                string.push('+' + scientific_exponent);
              } else {
                string.push(scientific_exponent);
              }
            } else {
              // Regular format with no decimal place
              if (exponent >= 0) {
                for (var _i2 = 0; _i2 < significand_digits; _i2++) {
                  string.push(significand[index++]);
                }
              } else {
                var radix_position = significand_digits + exponent; // non-zero digits before radix

                if (radix_position > 0) {
                  for (var _i3 = 0; _i3 < radix_position; _i3++) {
                    string.push(significand[index++]);
                  }
                } else {
                  string.push('0');
                }

                string.push('.'); // add leading zeros after radix

                while (radix_position++ < 0) {
                  string.push('0');
                }

                for (var _i4 = 0; _i4 < significand_digits - Math.max(radix_position - 1, 0); _i4++) {
                  string.push(significand[index++]);
                }
              }
            }

            return string.join('');
          };

          Decimal128.prototype.toJSON = function () {
            return {
              $numberDecimal: this.toString()
            };
          };
          /**
           * @ignore
           */


          Decimal128.prototype.toExtendedJSON = function () {
            return {
              $numberDecimal: this.toString()
            };
          };
          /**
           * @ignore
           */


          Decimal128.fromExtendedJSON = function (doc) {
            return Decimal128.fromString(doc.$numberDecimal);
          };

          Object.defineProperty(Decimal128.prototype, '_bsontype', {
            value: 'Decimal128'
          });
          var decimal128 = Decimal128;
          /**
           * A class representation of the BSON MinKey type.
           */

          function _classCallCheck$7(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties$7(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass$7(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties$7(Constructor.prototype, protoProps);
            if (staticProps) _defineProperties$7(Constructor, staticProps);
            return Constructor;
          }

          var MinKey =
          /*#__PURE__*/
          function () {
            /**
             * Create a MinKey type
             *
             * @return {MinKey} A MinKey instance
             */
            function MinKey() {
              _classCallCheck$7(this, MinKey);
            }
            /**
             * @ignore
             */


            _createClass$7(MinKey, [{
              key: "toExtendedJSON",
              value: function toExtendedJSON() {
                return {
                  $minKey: 1
                };
              }
              /**
               * @ignore
               */

            }], [{
              key: "fromExtendedJSON",
              value: function fromExtendedJSON() {
                return new MinKey();
              }
            }]);

            return MinKey;
          }();

          Object.defineProperty(MinKey.prototype, '_bsontype', {
            value: 'MinKey'
          });
          var min_key = MinKey;
          /**
           * A class representation of the BSON MaxKey type.
           */

          function _classCallCheck$8(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties$8(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass$8(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties$8(Constructor.prototype, protoProps);
            if (staticProps) _defineProperties$8(Constructor, staticProps);
            return Constructor;
          }

          var MaxKey =
          /*#__PURE__*/
          function () {
            /**
             * Create a MaxKey type
             *
             * @return {MaxKey} A MaxKey instance
             */
            function MaxKey() {
              _classCallCheck$8(this, MaxKey);
            }
            /**
             * @ignore
             */


            _createClass$8(MaxKey, [{
              key: "toExtendedJSON",
              value: function toExtendedJSON() {
                return {
                  $maxKey: 1
                };
              }
              /**
               * @ignore
               */

            }], [{
              key: "fromExtendedJSON",
              value: function fromExtendedJSON() {
                return new MaxKey();
              }
            }]);

            return MaxKey;
          }();

          Object.defineProperty(MaxKey.prototype, '_bsontype', {
            value: 'MaxKey'
          });
          var max_key = MaxKey;
          /**
           * A class representation of the BSON DBRef type.
           */

          function _classCallCheck$9(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties$9(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass$9(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties$9(Constructor.prototype, protoProps);
            if (staticProps) _defineProperties$9(Constructor, staticProps);
            return Constructor;
          }

          var DBRef =
          /*#__PURE__*/
          function () {
            /**
             * Create a DBRef type
             *
             * @param {string} collection the collection name.
             * @param {ObjectId} oid the reference ObjectId.
             * @param {string} [db] optional db name, if omitted the reference is local to the current db.
             * @return {DBRef}
             */
            function DBRef(collection, oid, db, fields) {
              _classCallCheck$9(this, DBRef); // check if namespace has been provided


              var parts = collection.split('.');

              if (parts.length === 2) {
                db = parts.shift();
                collection = parts.shift();
              }

              this.collection = collection;
              this.oid = oid;
              this.db = db;
              this.fields = fields || {};
            }
            /**
             * @ignore
             * @api private
             */


            _createClass$9(DBRef, [{
              key: "toJSON",
              value: function toJSON() {
                var o = Object.assign({
                  $ref: this.collection,
                  $id: this.oid
                }, this.fields);
                if (this.db != null) o.$db = this.db;
                return o;
              }
              /**
               * @ignore
               */

            }, {
              key: "toExtendedJSON",
              value: function toExtendedJSON() {
                var o = {
                  $ref: this.collection,
                  $id: this.oid
                };
                if (this.db) o.$db = this.db;
                o = Object.assign(o, this.fields);
                return o;
              }
              /**
               * @ignore
               */

            }], [{
              key: "fromExtendedJSON",
              value: function fromExtendedJSON(doc) {
                var copy = Object.assign({}, doc);
                ['$ref', '$id', '$db'].forEach(function (k) {
                  return delete copy[k];
                });
                return new DBRef(doc.$ref, doc.$id, doc.$db, copy);
              }
            }]);

            return DBRef;
          }();

          Object.defineProperty(DBRef.prototype, '_bsontype', {
            value: 'DBRef'
          }); // the 1.x parser used a "namespace" property, while 4.x uses "collection". To ensure backwards
          // compatibility, let's expose "namespace"

          Object.defineProperty(DBRef.prototype, 'namespace', {
            get: function get() {
              return this.collection;
            },
            set: function set(val) {
              this.collection = val;
            },
            configurable: false
          });
          var db_ref = DBRef;

          function _classCallCheck$a(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }

          function _defineProperties$a(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          function _createClass$a(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties$a(Constructor.prototype, protoProps);
            if (staticProps) _defineProperties$a(Constructor, staticProps);
            return Constructor;
          }

          var Buffer$3 = buffer.Buffer;
          /**
           * A class representation of the BSON Binary type.
           */

          var Binary =
          /*#__PURE__*/
          function () {
            /**
             * Create a Binary type
             *
             * Sub types
             *  - **BSON.BSON_BINARY_SUBTYPE_DEFAULT**, default BSON type.
             *  - **BSON.BSON_BINARY_SUBTYPE_FUNCTION**, BSON function type.
             *  - **BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY**, BSON byte array type.
             *  - **BSON.BSON_BINARY_SUBTYPE_UUID**, BSON uuid type.
             *  - **BSON.BSON_BINARY_SUBTYPE_MD5**, BSON md5 type.
             *  - **BSON.BSON_BINARY_SUBTYPE_USER_DEFINED**, BSON user defined type.
             *
             * @param {Buffer} buffer a buffer object containing the binary data.
             * @param {Number} [subType] the option binary type.
             * @return {Binary}
             */
            function Binary(buffer$$1, subType) {
              _classCallCheck$a(this, Binary);

              if (buffer$$1 != null && !(typeof buffer$$1 === 'string') && !Buffer$3.isBuffer(buffer$$1) && !(buffer$$1 instanceof Uint8Array) && !Array.isArray(buffer$$1)) {
                throw new TypeError('only String, Buffer, Uint8Array or Array accepted');
              }

              this.sub_type = subType == null ? BSON_BINARY_SUBTYPE_DEFAULT : subType;
              this.position = 0;

              if (buffer$$1 != null && !(buffer$$1 instanceof Number)) {
                // Only accept Buffer, Uint8Array or Arrays
                if (typeof buffer$$1 === 'string') {
                  // Different ways of writing the length of the string for the different types
                  if (typeof Buffer$3 !== 'undefined') {
                    this.buffer = Buffer$3.from(buffer$$1);
                  } else if (typeof Uint8Array !== 'undefined' || Array.isArray(buffer$$1)) {
                    this.buffer = writeStringToArray(buffer$$1);
                  } else {
                    throw new TypeError('only String, Buffer, Uint8Array or Array accepted');
                  }
                } else {
                  this.buffer = buffer$$1;
                }

                this.position = buffer$$1.length;
              } else {
                if (typeof Buffer$3 !== 'undefined') {
                  this.buffer = Buffer$3.alloc(Binary.BUFFER_SIZE);
                } else if (typeof Uint8Array !== 'undefined') {
                  this.buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE));
                } else {
                  this.buffer = new Array(Binary.BUFFER_SIZE);
                }
              }
            }
            /**
             * Updates this binary with byte_value.
             *
             * @method
             * @param {string} byte_value a single byte we wish to write.
             */


            _createClass$a(Binary, [{
              key: "put",
              value: function put(byte_value) {
                // If it's a string and a has more than one character throw an error
                if (byte_value['length'] != null && typeof byte_value !== 'number' && byte_value.length !== 1) throw new TypeError('only accepts single character String, Uint8Array or Array');
                if (typeof byte_value !== 'number' && byte_value < 0 || byte_value > 255) throw new TypeError('only accepts number in a valid unsigned byte range 0-255'); // Decode the byte value once

                var decoded_byte = null;

                if (typeof byte_value === 'string') {
                  decoded_byte = byte_value.charCodeAt(0);
                } else if (byte_value['length'] != null) {
                  decoded_byte = byte_value[0];
                } else {
                  decoded_byte = byte_value;
                }

                if (this.buffer.length > this.position) {
                  this.buffer[this.position++] = decoded_byte;
                } else {
                  if (typeof Buffer$3 !== 'undefined' && Buffer$3.isBuffer(this.buffer)) {
                    // Create additional overflow buffer
                    var buffer$$1 = Buffer$3.alloc(Binary.BUFFER_SIZE + this.buffer.length); // Combine the two buffers together

                    this.buffer.copy(buffer$$1, 0, 0, this.buffer.length);
                    this.buffer = buffer$$1;
                    this.buffer[this.position++] = decoded_byte;
                  } else {
                    var _buffer = null; // Create a new buffer (typed or normal array)

                    if (isUint8Array(this.buffer)) {
                      _buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE + this.buffer.length));
                    } else {
                      _buffer = new Array(Binary.BUFFER_SIZE + this.buffer.length);
                    } // We need to copy all the content to the new array


                    for (var i = 0; i < this.buffer.length; i++) {
                      _buffer[i] = this.buffer[i];
                    } // Reassign the buffer


                    this.buffer = _buffer; // Write the byte

                    this.buffer[this.position++] = decoded_byte;
                  }
                }
              }
              /**
               * Writes a buffer or string to the binary.
               *
               * @method
               * @param {(Buffer|string)} string a string or buffer to be written to the Binary BSON object.
               * @param {number} offset specify the binary of where to write the content.
               * @return {null}
               */

            }, {
              key: "write",
              value: function write(string, offset) {
                offset = typeof offset === 'number' ? offset : this.position; // If the buffer is to small let's extend the buffer

                if (this.buffer.length < offset + string.length) {
                  var buffer$$1 = null; // If we are in node.js

                  if (typeof Buffer$3 !== 'undefined' && Buffer$3.isBuffer(this.buffer)) {
                    buffer$$1 = Buffer$3.alloc(this.buffer.length + string.length);
                    this.buffer.copy(buffer$$1, 0, 0, this.buffer.length);
                  } else if (isUint8Array(this.buffer)) {
                    // Create a new buffer
                    buffer$$1 = new Uint8Array(new ArrayBuffer(this.buffer.length + string.length)); // Copy the content

                    for (var i = 0; i < this.position; i++) {
                      buffer$$1[i] = this.buffer[i];
                    }
                  } // Assign the new buffer


                  this.buffer = buffer$$1;
                }

                if (typeof Buffer$3 !== 'undefined' && Buffer$3.isBuffer(string) && Buffer$3.isBuffer(this.buffer)) {
                  string.copy(this.buffer, offset, 0, string.length);
                  this.position = offset + string.length > this.position ? offset + string.length : this.position; // offset = string.length
                } else if (typeof Buffer$3 !== 'undefined' && typeof string === 'string' && Buffer$3.isBuffer(this.buffer)) {
                  this.buffer.write(string, offset, 'binary');
                  this.position = offset + string.length > this.position ? offset + string.length : this.position; // offset = string.length;
                } else if (isUint8Array(string) || Array.isArray(string) && typeof string !== 'string') {
                  for (var _i = 0; _i < string.length; _i++) {
                    this.buffer[offset++] = string[_i];
                  }

                  this.position = offset > this.position ? offset : this.position;
                } else if (typeof string === 'string') {
                  for (var _i2 = 0; _i2 < string.length; _i2++) {
                    this.buffer[offset++] = string.charCodeAt(_i2);
                  }

                  this.position = offset > this.position ? offset : this.position;
                }
              }
              /**
               * Reads **length** bytes starting at **position**.
               *
               * @method
               * @param {number} position read from the given position in the Binary.
               * @param {number} length the number of bytes to read.
               * @return {Buffer}
               */

            }, {
              key: "read",
              value: function read(position, length) {
                length = length && length > 0 ? length : this.position; // Let's return the data based on the type we have

                if (this.buffer['slice']) {
                  return this.buffer.slice(position, position + length);
                } // Create a buffer to keep the result


                var buffer$$1 = typeof Uint8Array !== 'undefined' ? new Uint8Array(new ArrayBuffer(length)) : new Array(length);

                for (var i = 0; i < length; i++) {
                  buffer$$1[i] = this.buffer[position++];
                } // Return the buffer


                return buffer$$1;
              }
              /**
               * Returns the value of this binary as a string.
               *
               * @method
               * @return {string}
               */

            }, {
              key: "value",
              value: function value(asRaw) {
                asRaw = asRaw == null ? false : asRaw; // Optimize to serialize for the situation where the data == size of buffer

                if (asRaw && typeof Buffer$3 !== 'undefined' && Buffer$3.isBuffer(this.buffer) && this.buffer.length === this.position) return this.buffer; // If it's a node.js buffer object

                if (typeof Buffer$3 !== 'undefined' && Buffer$3.isBuffer(this.buffer)) {
                  return asRaw ? this.buffer.slice(0, this.position) : this.buffer.toString('binary', 0, this.position);
                } else {
                  if (asRaw) {
                    // we support the slice command use it
                    if (this.buffer['slice'] != null) {
                      return this.buffer.slice(0, this.position);
                    } else {
                      // Create a new buffer to copy content to
                      var newBuffer = isUint8Array(this.buffer) ? new Uint8Array(new ArrayBuffer(this.position)) : new Array(this.position); // Copy content

                      for (var i = 0; i < this.position; i++) {
                        newBuffer[i] = this.buffer[i];
                      } // Return the buffer


                      return newBuffer;
                    }
                  } else {
                    return convertArraytoUtf8BinaryString(this.buffer, 0, this.position);
                  }
                }
              }
              /**
               * Length.
               *
               * @method
               * @return {number} the length of the binary.
               */

            }, {
              key: "length",
              value: function length() {
                return this.position;
              }
              /**
               * @ignore
               */

            }, {
              key: "toJSON",
              value: function toJSON() {
                return this.buffer != null ? this.buffer.toString('base64') : '';
              }
              /**
               * @ignore
               */

            }, {
              key: "toString",
              value: function toString(format) {
                return this.buffer != null ? this.buffer.slice(0, this.position).toString(format) : '';
              }
              /**
               * @ignore
               */

            }, {
              key: "toExtendedJSON",
              value: function toExtendedJSON() {
                var base64String = Buffer$3.isBuffer(this.buffer) ? this.buffer.toString('base64') : Buffer$3.from(this.buffer).toString('base64');
                var subType = Number(this.sub_type).toString(16);
                return {
                  $binary: {
                    base64: base64String,
                    subType: subType.length === 1 ? '0' + subType : subType
                  }
                };
              }
              /**
               * @ignore
               */

            }], [{
              key: "fromExtendedJSON",
              value: function fromExtendedJSON(doc) {
                var type = doc.$binary.subType ? parseInt(doc.$binary.subType, 16) : 0;
                var data = Buffer$3.from(doc.$binary.base64, 'base64');
                return new Binary(data, type);
              }
            }]);

            return Binary;
          }();
          /**
           * Binary default subtype
           * @ignore
           */


          var BSON_BINARY_SUBTYPE_DEFAULT = 0;

          function isUint8Array(obj) {
            return Object.prototype.toString.call(obj) === '[object Uint8Array]';
          }
          /**
           * @ignore
           */


          function writeStringToArray(data) {
            // Create a buffer
            var buffer$$1 = typeof Uint8Array !== 'undefined' ? new Uint8Array(new ArrayBuffer(data.length)) : new Array(data.length); // Write the content to the buffer

            for (var i = 0; i < data.length; i++) {
              buffer$$1[i] = data.charCodeAt(i);
            } // Write the string to the buffer


            return buffer$$1;
          }
          /**
           * Convert Array ot Uint8Array to Binary String
           *
           * @ignore
           */


          function convertArraytoUtf8BinaryString(byteArray, startIndex, endIndex) {
            var result = '';

            for (var i = startIndex; i < endIndex; i++) {
              result = result + String.fromCharCode(byteArray[i]);
            }

            return result;
          }

          Binary.BUFFER_SIZE = 256;
          /**
           * Default BSON type
           *
           * @classconstant SUBTYPE_DEFAULT
           **/

          Binary.SUBTYPE_DEFAULT = 0;
          /**
           * Function BSON type
           *
           * @classconstant SUBTYPE_DEFAULT
           **/

          Binary.SUBTYPE_FUNCTION = 1;
          /**
           * Byte Array BSON type
           *
           * @classconstant SUBTYPE_DEFAULT
           **/

          Binary.SUBTYPE_BYTE_ARRAY = 2;
          /**
           * OLD UUID BSON type
           *
           * @classconstant SUBTYPE_DEFAULT
           **/

          Binary.SUBTYPE_UUID_OLD = 3;
          /**
           * UUID BSON type
           *
           * @classconstant SUBTYPE_DEFAULT
           **/

          Binary.SUBTYPE_UUID = 4;
          /**
           * MD5 BSON type
           *
           * @classconstant SUBTYPE_DEFAULT
           **/

          Binary.SUBTYPE_MD5 = 5;
          /**
           * User BSON type
           *
           * @classconstant SUBTYPE_DEFAULT
           **/

          Binary.SUBTYPE_USER_DEFINED = 128;
          Object.defineProperty(Binary.prototype, '_bsontype', {
            value: 'Binary'
          });
          var binary = Binary;
          var constants = {
            // BSON MAX VALUES
            BSON_INT32_MAX: 0x7fffffff,
            BSON_INT32_MIN: -0x80000000,
            BSON_INT64_MAX: Math.pow(2, 63) - 1,
            BSON_INT64_MIN: -Math.pow(2, 63),
            // JS MAX PRECISE VALUES
            JS_INT_MAX: 0x20000000000000,
            // Any integer up to 2^53 can be precisely represented by a double.
            JS_INT_MIN: -0x20000000000000,
            // Any integer down to -2^53 can be precisely represented by a double.

            /**
             * Number BSON Type
             *
             * @classconstant BSON_DATA_NUMBER
             **/
            BSON_DATA_NUMBER: 1,

            /**
             * String BSON Type
             *
             * @classconstant BSON_DATA_STRING
             **/
            BSON_DATA_STRING: 2,

            /**
             * Object BSON Type
             *
             * @classconstant BSON_DATA_OBJECT
             **/
            BSON_DATA_OBJECT: 3,

            /**
             * Array BSON Type
             *
             * @classconstant BSON_DATA_ARRAY
             **/
            BSON_DATA_ARRAY: 4,

            /**
             * Binary BSON Type
             *
             * @classconstant BSON_DATA_BINARY
             **/
            BSON_DATA_BINARY: 5,

            /**
             * Binary BSON Type
             *
             * @classconstant BSON_DATA_UNDEFINED
             **/
            BSON_DATA_UNDEFINED: 6,

            /**
             * ObjectId BSON Type
             *
             * @classconstant BSON_DATA_OID
             **/
            BSON_DATA_OID: 7,

            /**
             * Boolean BSON Type
             *
             * @classconstant BSON_DATA_BOOLEAN
             **/
            BSON_DATA_BOOLEAN: 8,

            /**
             * Date BSON Type
             *
             * @classconstant BSON_DATA_DATE
             **/
            BSON_DATA_DATE: 9,

            /**
             * null BSON Type
             *
             * @classconstant BSON_DATA_NULL
             **/
            BSON_DATA_NULL: 10,

            /**
             * RegExp BSON Type
             *
             * @classconstant BSON_DATA_REGEXP
             **/
            BSON_DATA_REGEXP: 11,

            /**
             * Code BSON Type
             *
             * @classconstant BSON_DATA_DBPOINTER
             **/
            BSON_DATA_DBPOINTER: 12,

            /**
             * Code BSON Type
             *
             * @classconstant BSON_DATA_CODE
             **/
            BSON_DATA_CODE: 13,

            /**
             * Symbol BSON Type
             *
             * @classconstant BSON_DATA_SYMBOL
             **/
            BSON_DATA_SYMBOL: 14,

            /**
             * Code with Scope BSON Type
             *
             * @classconstant BSON_DATA_CODE_W_SCOPE
             **/
            BSON_DATA_CODE_W_SCOPE: 15,

            /**
             * 32 bit Integer BSON Type
             *
             * @classconstant BSON_DATA_INT
             **/
            BSON_DATA_INT: 16,

            /**
             * Timestamp BSON Type
             *
             * @classconstant BSON_DATA_TIMESTAMP
             **/
            BSON_DATA_TIMESTAMP: 17,

            /**
             * Long BSON Type
             *
             * @classconstant BSON_DATA_LONG
             **/
            BSON_DATA_LONG: 18,

            /**
             * Long BSON Type
             *
             * @classconstant BSON_DATA_DECIMAL128
             **/
            BSON_DATA_DECIMAL128: 19,

            /**
             * MinKey BSON Type
             *
             * @classconstant BSON_DATA_MIN_KEY
             **/
            BSON_DATA_MIN_KEY: 0xff,

            /**
             * MaxKey BSON Type
             *
             * @classconstant BSON_DATA_MAX_KEY
             **/
            BSON_DATA_MAX_KEY: 0x7f,

            /**
             * Binary Default Type
             *
             * @classconstant BSON_BINARY_SUBTYPE_DEFAULT
             **/
            BSON_BINARY_SUBTYPE_DEFAULT: 0,

            /**
             * Binary Function Type
             *
             * @classconstant BSON_BINARY_SUBTYPE_FUNCTION
             **/
            BSON_BINARY_SUBTYPE_FUNCTION: 1,

            /**
             * Binary Byte Array Type
             *
             * @classconstant BSON_BINARY_SUBTYPE_BYTE_ARRAY
             **/
            BSON_BINARY_SUBTYPE_BYTE_ARRAY: 2,

            /**
             * Binary UUID Type
             *
             * @classconstant BSON_BINARY_SUBTYPE_UUID
             **/
            BSON_BINARY_SUBTYPE_UUID: 3,

            /**
             * Binary MD5 Type
             *
             * @classconstant BSON_BINARY_SUBTYPE_MD5
             **/
            BSON_BINARY_SUBTYPE_MD5: 4,

            /**
             * Binary User Defined Type
             *
             * @classconstant BSON_BINARY_SUBTYPE_USER_DEFINED
             **/
            BSON_BINARY_SUBTYPE_USER_DEFINED: 128
          };

          function _typeof$2(obj) {
            if (typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol") {
              _typeof$2 = function _typeof$1(obj) {
                return _typeof(obj);
              };
            } else {
              _typeof$2 = function _typeof$1(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof(obj);
              };
            }

            return _typeof$2(obj);
          } // const Map = require('./map');

          /**
           * @namespace EJSON
           */
          // all the types where we don't need to do any special processing and can just pass the EJSON
          //straight to type.fromExtendedJSON


          var keysToCodecs = {
            $oid: objectid,
            $binary: binary,
            $symbol: symbol,
            $numberInt: int_32,
            $numberDecimal: decimal128,
            $numberDouble: double_1,
            $numberLong: long_1,
            $minKey: min_key,
            $maxKey: max_key,
            $regularExpression: regexp,
            $timestamp: timestamp
          };

          function deserializeValue(self, key, value, options) {
            if (typeof value === 'number') {
              if (options.relaxed) {
                return value;
              } // if it's an integer, should interpret as smallest BSON integer
              // that can represent it exactly. (if out of range, interpret as double.)


              if (Math.floor(value) === value) {
                if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) return new int_32(value);
                if (value >= BSON_INT64_MIN && value <= BSON_INT64_MAX) return new long_1.fromNumber(value);
              } // If the number is a non-integer or out of integer range, should interpret as BSON Double.


              return new double_1(value);
            } // from here on out we're looking for bson types, so bail if its not an object


            if (value == null || _typeof$2(value) !== 'object') return value; // upgrade deprecated undefined to null

            if (value.$undefined) return null;
            var keys = Object.keys(value).filter(function (k) {
              return k.startsWith('$') && value[k] != null;
            });

            for (var i = 0; i < keys.length; i++) {
              var c = keysToCodecs[keys[i]];
              if (c) return c.fromExtendedJSON(value, options);
            }

            if (value.$date != null) {
              var d = value.$date;
              var date = new Date();
              if (typeof d === 'string') date.setTime(Date.parse(d));else if (long_1.isLong(d)) date.setTime(d.toNumber());else if (typeof d === 'number' && options.relaxed) date.setTime(d);
              return date;
            }

            if (value.$code != null) {
              var copy = Object.assign({}, value);

              if (value.$scope) {
                copy.$scope = deserializeValue(self, null, value.$scope);
              }

              return code.fromExtendedJSON(value);
            }

            if (value.$ref != null || value.$dbPointer != null) {
              var v = value.$ref ? value : value.$dbPointer; // we run into this in a "degenerate EJSON" case (with $id and $ref order flipped)
              // because of the order JSON.parse goes through the document

              if (v instanceof db_ref) return v;
              var dollarKeys = Object.keys(v).filter(function (k) {
                return k.startsWith('$');
              });
              var valid = true;
              dollarKeys.forEach(function (k) {
                if (['$ref', '$id', '$db'].indexOf(k) === -1) valid = false;
              }); // only make DBRef if $ keys are all valid

              if (valid) return db_ref.fromExtendedJSON(v);
            }

            return value;
          }
          /**
           * Parse an Extended JSON string, constructing the JavaScript value or object described by that
           * string.
           *
           * @memberof EJSON
           * @param {string} text
           * @param {object} [options] Optional settings
           * @param {boolean} [options.relaxed=true] Attempt to return native JS types where possible, rather than BSON types (if true)
           * @return {object}
           *
           * @example
           * const { EJSON } = require('bson');
           * const text = '{ "int32": { "$numberInt": "10" } }';
           *
           * // prints { int32: { [String: '10'] _bsontype: 'Int32', value: '10' } }
           * console.log(EJSON.parse(text, { relaxed: false }));
           *
           * // prints { int32: 10 }
           * console.log(EJSON.parse(text));
           */


          function parse(text, options) {
            var _this = this;

            options = Object.assign({}, {
              relaxed: true
            }, options); // relaxed implies not strict

            if (typeof options.relaxed === 'boolean') options.strict = !options.relaxed;
            if (typeof options.strict === 'boolean') options.relaxed = !options.strict;
            return JSON.parse(text, function (key, value) {
              return deserializeValue(_this, key, value, options);
            });
          } //
          // Serializer
          //
          // MAX INT32 boundaries


          var BSON_INT32_MAX = 0x7fffffff,
              BSON_INT32_MIN = -0x80000000,
              BSON_INT64_MAX = 0x7fffffffffffffff,
              BSON_INT64_MIN = -0x8000000000000000;
          /**
           * Converts a BSON document to an Extended JSON string, optionally replacing values if a replacer
           * function is specified or optionally including only the specified properties if a replacer array
           * is specified.
           *
           * @memberof EJSON
           * @param {object} value The value to convert to extended JSON
           * @param {function|array} [replacer] A function that alters the behavior of the stringification process, or an array of String and Number objects that serve as a whitelist for selecting/filtering the properties of the value object to be included in the JSON string. If this value is null or not provided, all properties of the object are included in the resulting JSON string
           * @param {string|number} [space] A String or Number object that's used to insert white space into the output JSON string for readability purposes.
           * @param {object} [options] Optional settings
           * @param {boolean} [options.relaxed=true] Enabled Extended JSON's `relaxed` mode
           * @returns {string}
           *
           * @example
           * const { EJSON } = require('bson');
           * const Int32 = require('mongodb').Int32;
           * const doc = { int32: new Int32(10) };
           *
           * // prints '{"int32":{"$numberInt":"10"}}'
           * console.log(EJSON.stringify(doc, { relaxed: false }));
           *
           * // prints '{"int32":10}'
           * console.log(EJSON.stringify(doc));
           */

          function stringify(value, replacer, space, options) {
            if (space != null && _typeof$2(space) === 'object') {
              options = space;
              space = 0;
            }

            if (replacer != null && _typeof$2(replacer) === 'object' && !Array.isArray(replacer)) {
              options = replacer;
              replacer = null;
              space = 0;
            }

            options = Object.assign({}, {
              relaxed: true
            }, options);
            var doc = Array.isArray(value) ? serializeArray(value, options) : serializeDocument(value, options);
            return JSON.stringify(doc, replacer, space);
          }
          /**
           * Serializes an object to an Extended JSON string, and reparse it as a JavaScript object.
           *
           * @memberof EJSON
           * @param {object} bson The object to serialize
           * @param {object} [options] Optional settings passed to the `stringify` function
           * @return {object}
           */


          function serialize(bson, options) {
            options = options || {};
            return JSON.parse(stringify(bson, options));
          }
          /**
           * Deserializes an Extended JSON object into a plain JavaScript object with native/BSON types
           *
           * @memberof EJSON
           * @param {object} ejson The Extended JSON object to deserialize
           * @param {object} [options] Optional settings passed to the parse method
           * @return {object}
           */


          function deserialize(ejson, options) {
            options = options || {};
            return parse(JSON.stringify(ejson), options);
          }

          function serializeArray(array, options) {
            return array.map(function (v) {
              return serializeValue(v, options);
            });
          }

          function getISOString(date) {
            var isoStr = date.toISOString(); // we should only show milliseconds in timestamp if they're non-zero

            return date.getUTCMilliseconds() !== 0 ? isoStr : isoStr.slice(0, -5) + 'Z';
          }

          function serializeValue(value, options) {
            if (Array.isArray(value)) return serializeArray(value, options);
            if (value === undefined) return null;

            if (value instanceof Date) {
              var dateNum = value.getTime(),
                  // is it in year range 1970-9999?
              inRange = dateNum > -1 && dateNum < 253402318800000;
              return options.relaxed && inRange ? {
                $date: getISOString(value)
              } : {
                $date: {
                  $numberLong: value.getTime().toString()
                }
              };
            }

            if (typeof value === 'number' && !options.relaxed) {
              // it's an integer
              if (Math.floor(value) === value) {
                var int32Range = value >= BSON_INT32_MIN && value <= BSON_INT32_MAX,
                    int64Range = value >= BSON_INT64_MIN && value <= BSON_INT64_MAX; // interpret as being of the smallest BSON integer type that can represent the number exactly

                if (int32Range) return {
                  $numberInt: value.toString()
                };
                if (int64Range) return {
                  $numberLong: value.toString()
                };
              }

              return {
                $numberDouble: value.toString()
              };
            }

            if (value instanceof RegExp) {
              var flags = value.flags;

              if (flags === undefined) {
                flags = value.toString().match(/[gimuy]*$/)[0];
              }

              var rx = new regexp(value.source, flags);
              return rx.toExtendedJSON();
            }

            if (value != null && _typeof$2(value) === 'object') return serializeDocument(value, options);
            return value;
          }

          var BSON_TYPE_MAPPINGS = {
            Binary: function Binary(o) {
              return new binary(o.value(), o.subtype);
            },
            Code: function Code(o) {
              return new code(o.code, o.scope);
            },
            DBRef: function DBRef(o) {
              return new db_ref(o.collection || o.namespace, o.oid, o.db, o.fields);
            },
            // "namespace" for 1.x library backwards compat
            Decimal128: function Decimal128(o) {
              return new decimal128(o.bytes);
            },
            Double: function Double(o) {
              return new double_1(o.value);
            },
            Int32: function Int32(o) {
              return new int_32(o.value);
            },
            Long: function Long(o) {
              return long_1.fromBits( // underscore variants for 1.x backwards compatibility
              o.low != null ? o.low : o.low_, o.low != null ? o.high : o.high_, o.low != null ? o.unsigned : o.unsigned_);
            },
            MaxKey: function MaxKey() {
              return new max_key();
            },
            MinKey: function MinKey() {
              return new min_key();
            },
            ObjectID: function ObjectID(o) {
              return new objectid(o);
            },
            ObjectId: function ObjectId(o) {
              return new objectid(o);
            },
            // support 4.0.0/4.0.1 before _bsontype was reverted back to ObjectID
            BSONRegExp: function BSONRegExp(o) {
              return new regexp(o.pattern, o.options);
            },
            Symbol: function _Symbol(o) {
              return new symbol(o.value);
            },
            Timestamp: function Timestamp(o) {
              return timestamp.fromBits(o.low, o.high);
            }
          };

          function serializeDocument(doc, options) {
            if (doc == null || _typeof$2(doc) !== 'object') throw new Error('not an object instance');
            var bsontype = doc._bsontype;

            if (typeof bsontype === 'undefined') {
              // It's a regular object. Recursively serialize its property values.
              var _doc = {};

              for (var name in doc) {
                _doc[name] = serializeValue(doc[name], options);
              }

              return _doc;
            } else if (typeof bsontype === 'string') {
              // the "document" is really just a BSON type object
              var _doc2 = doc;

              if (typeof _doc2.toExtendedJSON !== 'function') {
                // There's no EJSON serialization function on the object. It's probably an
                // object created by a previous version of this library (or another library)
                // that's duck-typing objects to look like they were generated by this library).
                // Copy the object into this library's version of that type.
                var mapper = BSON_TYPE_MAPPINGS[bsontype];

                if (!mapper) {
                  throw new TypeError('Unrecognized or invalid _bsontype: ' + bsontype);
                }

                _doc2 = mapper(_doc2);
              } // Two BSON types may have nested objects that may need to be serialized too


              if (bsontype === 'Code' && _doc2.scope) {
                _doc2 = new code(_doc2.code, serializeValue(_doc2.scope, options));
              } else if (bsontype === 'DBRef' && _doc2.oid) {
                _doc2 = new db_ref(_doc2.collection, serializeValue(_doc2.oid, options), _doc2.db, _doc2.fields);
              }

              return _doc2.toExtendedJSON(options);
            } else {
              throw new Error('_bsontype must be a string, but was: ' + _typeof$2(bsontype));
            }
          }

          var extended_json = {
            parse: parse,
            deserialize: deserialize,
            serialize: serialize,
            stringify: stringify
          };
          var FIRST_BIT = 0x80;
          var FIRST_TWO_BITS = 0xc0;
          var FIRST_THREE_BITS = 0xe0;
          var FIRST_FOUR_BITS = 0xf0;
          var FIRST_FIVE_BITS = 0xf8;
          var TWO_BIT_CHAR = 0xc0;
          var THREE_BIT_CHAR = 0xe0;
          var FOUR_BIT_CHAR = 0xf0;
          var CONTINUING_CHAR = 0x80;
          /**
           * Determines if the passed in bytes are valid utf8
           * @param {Buffer|Uint8Array} bytes An array of 8-bit bytes. Must be indexable and have length property
           * @param {Number} start The index to start validating
           * @param {Number} end The index to end validating
           * @returns {boolean} True if valid utf8
           */

          function validateUtf8(bytes, start, end) {
            var continuation = 0;

            for (var i = start; i < end; i += 1) {
              var _byte = bytes[i];

              if (continuation) {
                if ((_byte & FIRST_TWO_BITS) !== CONTINUING_CHAR) {
                  return false;
                }

                continuation -= 1;
              } else if (_byte & FIRST_BIT) {
                if ((_byte & FIRST_THREE_BITS) === TWO_BIT_CHAR) {
                  continuation = 1;
                } else if ((_byte & FIRST_FOUR_BITS) === THREE_BIT_CHAR) {
                  continuation = 2;
                } else if ((_byte & FIRST_FIVE_BITS) === FOUR_BIT_CHAR) {
                  continuation = 3;
                } else {
                  return false;
                }
              }
            }

            return !continuation;
          }

          var validateUtf8_1 = validateUtf8;
          var validate_utf8 = {
            validateUtf8: validateUtf8_1
          };
          var Buffer$4 = buffer.Buffer;
          var validateUtf8$1 = validate_utf8.validateUtf8; // Internal long versions

          var JS_INT_MAX_LONG = long_1.fromNumber(constants.JS_INT_MAX);
          var JS_INT_MIN_LONG = long_1.fromNumber(constants.JS_INT_MIN);
          var functionCache = {};

          function deserialize$1(buffer$$1, options, isArray) {
            options = options == null ? {} : options;
            var index = options && options.index ? options.index : 0; // Read the document size

            var size = buffer$$1[index] | buffer$$1[index + 1] << 8 | buffer$$1[index + 2] << 16 | buffer$$1[index + 3] << 24;

            if (size < 5) {
              throw new Error("bson size must be >= 5, is ".concat(size));
            }

            if (options.allowObjectSmallerThanBufferSize && buffer$$1.length < size) {
              throw new Error("buffer length ".concat(buffer$$1.length, " must be >= bson size ").concat(size));
            }

            if (!options.allowObjectSmallerThanBufferSize && buffer$$1.length !== size) {
              throw new Error("buffer length ".concat(buffer$$1.length, " must === bson size ").concat(size));
            }

            if (size + index > buffer$$1.length) {
              throw new Error("(bson size ".concat(size, " + options.index ").concat(index, " must be <= buffer length ").concat(Buffer$4.byteLength(buffer$$1), ")"));
            } // Illegal end value


            if (buffer$$1[index + size - 1] !== 0) {
              throw new Error("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00");
            } // Start deserializtion


            return deserializeObject(buffer$$1, index, options, isArray);
          }

          function deserializeObject(buffer$$1, index, options, isArray) {
            var evalFunctions = options['evalFunctions'] == null ? false : options['evalFunctions'];
            var cacheFunctions = options['cacheFunctions'] == null ? false : options['cacheFunctions'];
            var cacheFunctionsCrc32 = options['cacheFunctionsCrc32'] == null ? false : options['cacheFunctionsCrc32'];
            if (!cacheFunctionsCrc32) var crc32 = null;
            var fieldsAsRaw = options['fieldsAsRaw'] == null ? null : options['fieldsAsRaw']; // Return raw bson buffer instead of parsing it

            var raw = options['raw'] == null ? false : options['raw']; // Return BSONRegExp objects instead of native regular expressions

            var bsonRegExp = typeof options['bsonRegExp'] === 'boolean' ? options['bsonRegExp'] : false; // Controls the promotion of values vs wrapper classes

            var promoteBuffers = options['promoteBuffers'] == null ? false : options['promoteBuffers'];
            var promoteLongs = options['promoteLongs'] == null ? true : options['promoteLongs'];
            var promoteValues = options['promoteValues'] == null ? true : options['promoteValues']; // Set the start index

            var startIndex = index; // Validate that we have at least 4 bytes of buffer

            if (buffer$$1.length < 5) throw new Error('corrupt bson message < 5 bytes long'); // Read the document size

            var size = buffer$$1[index++] | buffer$$1[index++] << 8 | buffer$$1[index++] << 16 | buffer$$1[index++] << 24; // Ensure buffer is valid size

            if (size < 5 || size > buffer$$1.length) throw new Error('corrupt bson message'); // Create holding object

            var object = isArray ? [] : {}; // Used for arrays to skip having to perform utf8 decoding

            var arrayIndex = 0;
            var done = false; // While we have more left data left keep parsing

            while (!done) {
              // Read the type
              var elementType = buffer$$1[index++]; // If we get a zero it's the last byte, exit

              if (elementType === 0) break; // Get the start search index

              var i = index; // Locate the end of the c string

              while (buffer$$1[i] !== 0x00 && i < buffer$$1.length) {
                i++;
              } // If are at the end of the buffer there is a problem with the document


              if (i >= Buffer$4.byteLength(buffer$$1)) throw new Error('Bad BSON Document: illegal CString');
              var name = isArray ? arrayIndex++ : buffer$$1.toString('utf8', index, i);
              index = i + 1;

              if (elementType === constants.BSON_DATA_STRING) {
                var stringSize = buffer$$1[index++] | buffer$$1[index++] << 8 | buffer$$1[index++] << 16 | buffer$$1[index++] << 24;
                if (stringSize <= 0 || stringSize > buffer$$1.length - index || buffer$$1[index + stringSize - 1] !== 0) throw new Error('bad string length in bson');

                if (!validateUtf8$1(buffer$$1, index, index + stringSize - 1)) {
                  throw new Error('Invalid UTF-8 string in BSON document');
                }

                var s = buffer$$1.toString('utf8', index, index + stringSize - 1);
                object[name] = s;
                index = index + stringSize;
              } else if (elementType === constants.BSON_DATA_OID) {
                var oid = Buffer$4.alloc(12);
                buffer$$1.copy(oid, 0, index, index + 12);
                object[name] = new objectid(oid);
                index = index + 12;
              } else if (elementType === constants.BSON_DATA_INT && promoteValues === false) {
                object[name] = new int_32(buffer$$1[index++] | buffer$$1[index++] << 8 | buffer$$1[index++] << 16 | buffer$$1[index++] << 24);
              } else if (elementType === constants.BSON_DATA_INT) {
                object[name] = buffer$$1[index++] | buffer$$1[index++] << 8 | buffer$$1[index++] << 16 | buffer$$1[index++] << 24;
              } else if (elementType === constants.BSON_DATA_NUMBER && promoteValues === false) {
                object[name] = new double_1(buffer$$1.readDoubleLE(index));
                index = index + 8;
              } else if (elementType === constants.BSON_DATA_NUMBER) {
                object[name] = buffer$$1.readDoubleLE(index);
                index = index + 8;
              } else if (elementType === constants.BSON_DATA_DATE) {
                var lowBits = buffer$$1[index++] | buffer$$1[index++] << 8 | buffer$$1[index++] << 16 | buffer$$1[index++] << 24;
                var highBits = buffer$$1[index++] | buffer$$1[index++] << 8 | buffer$$1[index++] << 16 | buffer$$1[index++] << 24;
                object[name] = new Date(new long_1(lowBits, highBits).toNumber());
              } else if (elementType === constants.BSON_DATA_BOOLEAN) {
                if (buffer$$1[index] !== 0 && buffer$$1[index] !== 1) throw new Error('illegal boolean type value');
                object[name] = buffer$$1[index++] === 1;
              } else if (elementType === constants.BSON_DATA_OBJECT) {
                var _index = index;
                var objectSize = buffer$$1[index] | buffer$$1[index + 1] << 8 | buffer$$1[index + 2] << 16 | buffer$$1[index + 3] << 24;
                if (objectSize <= 0 || objectSize > buffer$$1.length - index) throw new Error('bad embedded document length in bson'); // We have a raw value

                if (raw) {
                  object[name] = buffer$$1.slice(index, index + objectSize);
                } else {
                  object[name] = deserializeObject(buffer$$1, _index, options, false);
                }

                index = index + objectSize;
              } else if (elementType === constants.BSON_DATA_ARRAY) {
                var _index2 = index;

                var _objectSize = buffer$$1[index] | buffer$$1[index + 1] << 8 | buffer$$1[index + 2] << 16 | buffer$$1[index + 3] << 24;

                var arrayOptions = options; // Stop index

                var stopIndex = index + _objectSize; // All elements of array to be returned as raw bson

                if (fieldsAsRaw && fieldsAsRaw[name]) {
                  arrayOptions = {};

                  for (var n in options) {
                    arrayOptions[n] = options[n];
                  }

                  arrayOptions['raw'] = true;
                }

                object[name] = deserializeObject(buffer$$1, _index2, arrayOptions, true);
                index = index + _objectSize;
                if (buffer$$1[index - 1] !== 0) throw new Error('invalid array terminator byte');
                if (index !== stopIndex) throw new Error('corrupted array bson');
              } else if (elementType === constants.BSON_DATA_UNDEFINED) {
                object[name] = undefined;
              } else if (elementType === constants.BSON_DATA_NULL) {
                object[name] = null;
              } else if (elementType === constants.BSON_DATA_LONG) {
                // Unpack the low and high bits
                var _lowBits = buffer$$1[index++] | buffer$$1[index++] << 8 | buffer$$1[index++] << 16 | buffer$$1[index++] << 24;

                var _highBits = buffer$$1[index++] | buffer$$1[index++] << 8 | buffer$$1[index++] << 16 | buffer$$1[index++] << 24;

                var long$$1 = new long_1(_lowBits, _highBits); // Promote the long if possible

                if (promoteLongs && promoteValues === true) {
                  object[name] = long$$1.lessThanOrEqual(JS_INT_MAX_LONG) && long$$1.greaterThanOrEqual(JS_INT_MIN_LONG) ? long$$1.toNumber() : long$$1;
                } else {
                  object[name] = long$$1;
                }
              } else if (elementType === constants.BSON_DATA_DECIMAL128) {
                // Buffer to contain the decimal bytes
                var bytes = Buffer$4.alloc(16); // Copy the next 16 bytes into the bytes buffer

                buffer$$1.copy(bytes, 0, index, index + 16); // Update index

                index = index + 16; // Assign the new Decimal128 value

                var decimal128$$1 = new decimal128(bytes); // If we have an alternative mapper use that

                object[name] = decimal128$$1.toObject ? decimal128$$1.toObject() : decimal128$$1;
              } else if (elementType === constants.BSON_DATA_BINARY) {
                var binarySize = buffer$$1[index++] | buffer$$1[index++] << 8 | buffer$$1[index++] << 16 | buffer$$1[index++] << 24;
                var totalBinarySize = binarySize;
                var subType = buffer$$1[index++]; // Did we have a negative binary size, throw

                if (binarySize < 0) throw new Error('Negative binary type element size found'); // Is the length longer than the document

                if (binarySize > Buffer$4.byteLength(buffer$$1)) throw new Error('Binary type size larger than document size'); // Decode as raw Buffer object if options specifies it

                if (buffer$$1['slice'] != null) {
                  // If we have subtype 2 skip the 4 bytes for the size
                  if (subType === binary.SUBTYPE_BYTE_ARRAY) {
                    binarySize = buffer$$1[index++] | buffer$$1[index++] << 8 | buffer$$1[index++] << 16 | buffer$$1[index++] << 24;
                    if (binarySize < 0) throw new Error('Negative binary type element size found for subtype 0x02');
                    if (binarySize > totalBinarySize - 4) throw new Error('Binary type with subtype 0x02 contains to long binary size');
                    if (binarySize < totalBinarySize - 4) throw new Error('Binary type with subtype 0x02 contains to short binary size');
                  }

                  if (promoteBuffers && promoteValues) {
                    object[name] = buffer$$1.slice(index, index + binarySize);
                  } else {
                    object[name] = new binary(buffer$$1.slice(index, index + binarySize), subType);
                  }
                } else {
                  var _buffer = typeof Uint8Array !== 'undefined' ? new Uint8Array(new ArrayBuffer(binarySize)) : new Array(binarySize); // If we have subtype 2 skip the 4 bytes for the size


                  if (subType === binary.SUBTYPE_BYTE_ARRAY) {
                    binarySize = buffer$$1[index++] | buffer$$1[index++] << 8 | buffer$$1[index++] << 16 | buffer$$1[index++] << 24;
                    if (binarySize < 0) throw new Error('Negative binary type element size found for subtype 0x02');
                    if (binarySize > totalBinarySize - 4) throw new Error('Binary type with subtype 0x02 contains to long binary size');
                    if (binarySize < totalBinarySize - 4) throw new Error('Binary type with subtype 0x02 contains to short binary size');
                  } // Copy the data


                  for (i = 0; i < binarySize; i++) {
                    _buffer[i] = buffer$$1[index + i];
                  }

                  if (promoteBuffers && promoteValues) {
                    object[name] = _buffer;
                  } else {
                    object[name] = new binary(_buffer, subType);
                  }
                } // Update the index


                index = index + binarySize;
              } else if (elementType === constants.BSON_DATA_REGEXP && bsonRegExp === false) {
                // Get the start search index
                i = index; // Locate the end of the c string

                while (buffer$$1[i] !== 0x00 && i < buffer$$1.length) {
                  i++;
                } // If are at the end of the buffer there is a problem with the document


                if (i >= buffer$$1.length) throw new Error('Bad BSON Document: illegal CString'); // Return the C string

                var source = buffer$$1.toString('utf8', index, i); // Create the regexp

                index = i + 1; // Get the start search index

                i = index; // Locate the end of the c string

                while (buffer$$1[i] !== 0x00 && i < buffer$$1.length) {
                  i++;
                } // If are at the end of the buffer there is a problem with the document


                if (i >= buffer$$1.length) throw new Error('Bad BSON Document: illegal CString'); // Return the C string

                var regExpOptions = buffer$$1.toString('utf8', index, i);
                index = i + 1; // For each option add the corresponding one for javascript

                var optionsArray = new Array(regExpOptions.length); // Parse options

                for (i = 0; i < regExpOptions.length; i++) {
                  switch (regExpOptions[i]) {
                    case 'm':
                      optionsArray[i] = 'm';
                      break;

                    case 's':
                      optionsArray[i] = 'g';
                      break;

                    case 'i':
                      optionsArray[i] = 'i';
                      break;
                  }
                }

                object[name] = new RegExp(source, optionsArray.join(''));
              } else if (elementType === constants.BSON_DATA_REGEXP && bsonRegExp === true) {
                // Get the start search index
                i = index; // Locate the end of the c string

                while (buffer$$1[i] !== 0x00 && i < buffer$$1.length) {
                  i++;
                } // If are at the end of the buffer there is a problem with the document


                if (i >= buffer$$1.length) throw new Error('Bad BSON Document: illegal CString'); // Return the C string

                var _source = buffer$$1.toString('utf8', index, i);

                index = i + 1; // Get the start search index

                i = index; // Locate the end of the c string

                while (buffer$$1[i] !== 0x00 && i < buffer$$1.length) {
                  i++;
                } // If are at the end of the buffer there is a problem with the document


                if (i >= buffer$$1.length) throw new Error('Bad BSON Document: illegal CString'); // Return the C string

                var _regExpOptions = buffer$$1.toString('utf8', index, i);

                index = i + 1; // Set the object

                object[name] = new regexp(_source, _regExpOptions);
              } else if (elementType === constants.BSON_DATA_SYMBOL) {
                var _stringSize = buffer$$1[index++] | buffer$$1[index++] << 8 | buffer$$1[index++] << 16 | buffer$$1[index++] << 24;

                if (_stringSize <= 0 || _stringSize > buffer$$1.length - index || buffer$$1[index + _stringSize - 1] !== 0) throw new Error('bad string length in bson'); // symbol is deprecated - upgrade to string.

                object[name] = buffer$$1.toString('utf8', index, index + _stringSize - 1);
                index = index + _stringSize;
              } else if (elementType === constants.BSON_DATA_TIMESTAMP) {
                var _lowBits2 = buffer$$1[index++] | buffer$$1[index++] << 8 | buffer$$1[index++] << 16 | buffer$$1[index++] << 24;

                var _highBits2 = buffer$$1[index++] | buffer$$1[index++] << 8 | buffer$$1[index++] << 16 | buffer$$1[index++] << 24;

                object[name] = new timestamp(_lowBits2, _highBits2);
              } else if (elementType === constants.BSON_DATA_MIN_KEY) {
                object[name] = new min_key();
              } else if (elementType === constants.BSON_DATA_MAX_KEY) {
                object[name] = new max_key();
              } else if (elementType === constants.BSON_DATA_CODE) {
                var _stringSize2 = buffer$$1[index++] | buffer$$1[index++] << 8 | buffer$$1[index++] << 16 | buffer$$1[index++] << 24;

                if (_stringSize2 <= 0 || _stringSize2 > buffer$$1.length - index || buffer$$1[index + _stringSize2 - 1] !== 0) throw new Error('bad string length in bson');
                var functionString = buffer$$1.toString('utf8', index, index + _stringSize2 - 1); // If we are evaluating the functions

                if (evalFunctions) {
                  // If we have cache enabled let's look for the md5 of the function in the cache
                  if (cacheFunctions) {
                    var hash = cacheFunctionsCrc32 ? crc32(functionString) : functionString; // Got to do this to avoid V8 deoptimizing the call due to finding eval

                    object[name] = isolateEvalWithHash(functionCache, hash, functionString, object);
                  } else {
                    object[name] = isolateEval(functionString);
                  }
                } else {
                  object[name] = new code(functionString);
                } // Update parse index position


                index = index + _stringSize2;
              } else if (elementType === constants.BSON_DATA_CODE_W_SCOPE) {
                var totalSize = buffer$$1[index++] | buffer$$1[index++] << 8 | buffer$$1[index++] << 16 | buffer$$1[index++] << 24; // Element cannot be shorter than totalSize + stringSize + documentSize + terminator

                if (totalSize < 4 + 4 + 4 + 1) {
                  throw new Error('code_w_scope total size shorter minimum expected length');
                } // Get the code string size


                var _stringSize3 = buffer$$1[index++] | buffer$$1[index++] << 8 | buffer$$1[index++] << 16 | buffer$$1[index++] << 24; // Check if we have a valid string


                if (_stringSize3 <= 0 || _stringSize3 > buffer$$1.length - index || buffer$$1[index + _stringSize3 - 1] !== 0) throw new Error('bad string length in bson'); // Javascript function

                var _functionString = buffer$$1.toString('utf8', index, index + _stringSize3 - 1); // Update parse index position


                index = index + _stringSize3; // Parse the element

                var _index3 = index; // Decode the size of the object document

                var _objectSize2 = buffer$$1[index] | buffer$$1[index + 1] << 8 | buffer$$1[index + 2] << 16 | buffer$$1[index + 3] << 24; // Decode the scope object


                var scopeObject = deserializeObject(buffer$$1, _index3, options, false); // Adjust the index

                index = index + _objectSize2; // Check if field length is to short

                if (totalSize < 4 + 4 + _objectSize2 + _stringSize3) {
                  throw new Error('code_w_scope total size is to short, truncating scope');
                } // Check if totalSize field is to long


                if (totalSize > 4 + 4 + _objectSize2 + _stringSize3) {
                  throw new Error('code_w_scope total size is to long, clips outer document');
                } // If we are evaluating the functions


                if (evalFunctions) {
                  // If we have cache enabled let's look for the md5 of the function in the cache
                  if (cacheFunctions) {
                    var _hash = cacheFunctionsCrc32 ? crc32(_functionString) : _functionString; // Got to do this to avoid V8 deoptimizing the call due to finding eval


                    object[name] = isolateEvalWithHash(functionCache, _hash, _functionString, object);
                  } else {
                    object[name] = isolateEval(_functionString);
                  }

                  object[name].scope = scopeObject;
                } else {
                  object[name] = new code(_functionString, scopeObject);
                }
              } else if (elementType === constants.BSON_DATA_DBPOINTER) {
                // Get the code string size
                var _stringSize4 = buffer$$1[index++] | buffer$$1[index++] << 8 | buffer$$1[index++] << 16 | buffer$$1[index++] << 24; // Check if we have a valid string


                if (_stringSize4 <= 0 || _stringSize4 > buffer$$1.length - index || buffer$$1[index + _stringSize4 - 1] !== 0) throw new Error('bad string length in bson'); // Namespace

                if (!validateUtf8$1(buffer$$1, index, index + _stringSize4 - 1)) {
                  throw new Error('Invalid UTF-8 string in BSON document');
                }

                var namespace = buffer$$1.toString('utf8', index, index + _stringSize4 - 1); // Update parse index position

                index = index + _stringSize4; // Read the oid

                var oidBuffer = Buffer$4.alloc(12);
                buffer$$1.copy(oidBuffer, 0, index, index + 12);

                var _oid = new objectid(oidBuffer); // Update the index


                index = index + 12; // Upgrade to DBRef type

                object[name] = new db_ref(namespace, _oid);
              } else {
                throw new Error('Detected unknown BSON type ' + elementType.toString(16) + ' for fieldname "' + name + '", are you using the latest BSON parser?');
              }
            } // Check if the deserialization was against a valid array/object


            if (size !== index - startIndex) {
              if (isArray) throw new Error('corrupt array bson');
              throw new Error('corrupt object bson');
            } // check if object's $ keys are those of a DBRef


            var dollarKeys = Object.keys(object).filter(function (k) {
              return k.startsWith('$');
            });
            var valid = true;
            dollarKeys.forEach(function (k) {
              if (['$ref', '$id', '$db'].indexOf(k) === -1) valid = false;
            }); // if a $key not in "$ref", "$id", "$db", don't make a DBRef

            if (!valid) return object;

            if (object['$id'] != null && object['$ref'] != null) {
              var copy = Object.assign({}, object);
              delete copy.$ref;
              delete copy.$id;
              delete copy.$db;
              return new db_ref(object.$ref, object.$id, object.$db || null, copy);
            }

            return object;
          }
          /**
           * Ensure eval is isolated.
           *
           * @ignore
           * @api private
           */


          function isolateEvalWithHash(functionCache, hash, functionString, object) {
            // Contains the value we are going to set
            var value = null; // Check for cache hit, eval if missing and return cached function

            if (functionCache[hash] == null) {
              eval('value = ' + functionString);
              functionCache[hash] = value;
            } // Set the object


            return functionCache[hash].bind(object);
          }
          /**
           * Ensure eval is isolated.
           *
           * @ignore
           * @api private
           */


          function isolateEval(functionString) {
            // Contains the value we are going to set
            var value = null; // Eval the function

            eval('value = ' + functionString);
            return value;
          }

          var deserializer = deserialize$1; // All rights reserved.
          //
          // Redistribution and use in source and binary forms, with or without
          // modification, are permitted provided that the following conditions are met:
          //
          //  * Redistributions of source code must retain the above copyright notice,
          //    this list of conditions and the following disclaimer.
          //
          //  * Redistributions in binary form must reproduce the above copyright notice,
          //    this list of conditions and the following disclaimer in the documentation
          //    and/or other materials provided with the distribution.
          //
          //  * Neither the name of Fair Oaks Labs, Inc. nor the names of its contributors
          //    may be used to endorse or promote products derived from this software
          //    without specific prior written permission.
          //
          // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
          // AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
          // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
          // ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
          // LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
          // CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
          // SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
          // INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
          // CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
          // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
          // POSSIBILITY OF SUCH DAMAGE.
          //
          //
          // Modifications to writeIEEE754 to support negative zeroes made by Brian White

          function readIEEE754(buffer$$1, offset, endian, mLen, nBytes) {
            var e,
                m,
                bBE = endian === 'big',
                eLen = nBytes * 8 - mLen - 1,
                eMax = (1 << eLen) - 1,
                eBias = eMax >> 1,
                nBits = -7,
                i = bBE ? 0 : nBytes - 1,
                d = bBE ? 1 : -1,
                s = buffer$$1[offset + i];
            i += d;
            e = s & (1 << -nBits) - 1;
            s >>= -nBits;
            nBits += eLen;

            for (; nBits > 0; e = e * 256 + buffer$$1[offset + i], i += d, nBits -= 8) {}

            m = e & (1 << -nBits) - 1;
            e >>= -nBits;
            nBits += mLen;

            for (; nBits > 0; m = m * 256 + buffer$$1[offset + i], i += d, nBits -= 8) {}

            if (e === 0) {
              e = 1 - eBias;
            } else if (e === eMax) {
              return m ? NaN : (s ? -1 : 1) * Infinity;
            } else {
              m = m + Math.pow(2, mLen);
              e = e - eBias;
            }

            return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
          }

          function writeIEEE754(buffer$$1, value, offset, endian, mLen, nBytes) {
            var e,
                m,
                c,
                bBE = endian === 'big',
                eLen = nBytes * 8 - mLen - 1,
                eMax = (1 << eLen) - 1,
                eBias = eMax >> 1,
                rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
                i = bBE ? nBytes - 1 : 0,
                d = bBE ? -1 : 1,
                s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
            value = Math.abs(value);

            if (isNaN(value) || value === Infinity) {
              m = isNaN(value) ? 1 : 0;
              e = eMax;
            } else {
              e = Math.floor(Math.log(value) / Math.LN2);

              if (value * (c = Math.pow(2, -e)) < 1) {
                e--;
                c *= 2;
              }

              if (e + eBias >= 1) {
                value += rt / c;
              } else {
                value += rt * Math.pow(2, 1 - eBias);
              }

              if (value * c >= 2) {
                e++;
                c /= 2;
              }

              if (e + eBias >= eMax) {
                m = 0;
                e = eMax;
              } else if (e + eBias >= 1) {
                m = (value * c - 1) * Math.pow(2, mLen);
                e = e + eBias;
              } else {
                m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                e = 0;
              }
            }

            if (isNaN(value)) m = 0;

            while (mLen >= 8) {
              buffer$$1[offset + i] = m & 0xff;
              i += d;
              m /= 256;
              mLen -= 8;
            }

            e = e << mLen | m;
            if (isNaN(value)) e += 8;
            eLen += mLen;

            while (eLen > 0) {
              buffer$$1[offset + i] = e & 0xff;
              i += d;
              e /= 256;
              eLen -= 8;
            }

            buffer$$1[offset + i - d] |= s * 128;
          }

          var float_parser = {
            readIEEE754: readIEEE754,
            writeIEEE754: writeIEEE754
          };

          function _typeof$3(obj) {
            if (typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol") {
              _typeof$3 = function _typeof$1(obj) {
                return _typeof(obj);
              };
            } else {
              _typeof$3 = function _typeof$1(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof(obj);
              };
            }

            return _typeof$3(obj);
          }

          var Buffer$5 = buffer.Buffer;
          var writeIEEE754$1 = float_parser.writeIEEE754;
          var normalizedFunctionString$1 = utils.normalizedFunctionString;
          var regexp$1 = /\x00/; // eslint-disable-line no-control-regex

          var ignoreKeys = new Set(['$db', '$ref', '$id', '$clusterTime']); // To ensure that 0.4 of node works correctly

          var isDate$1 = function isDate(d) {
            return _typeof$3(d) === 'object' && Object.prototype.toString.call(d) === '[object Date]';
          };

          var isRegExp$1 = function isRegExp(d) {
            return Object.prototype.toString.call(d) === '[object RegExp]';
          };

          function serializeString(buffer$$1, key, value, index, isArray) {
            // Encode String type
            buffer$$1[index++] = constants.BSON_DATA_STRING; // Number of written bytes

            var numberOfWrittenBytes = !isArray ? buffer$$1.write(key, index, 'utf8') : buffer$$1.write(key, index, 'ascii'); // Encode the name

            index = index + numberOfWrittenBytes + 1;
            buffer$$1[index - 1] = 0; // Write the string

            var size = buffer$$1.write(value, index + 4, 'utf8'); // Write the size of the string to buffer

            buffer$$1[index + 3] = size + 1 >> 24 & 0xff;
            buffer$$1[index + 2] = size + 1 >> 16 & 0xff;
            buffer$$1[index + 1] = size + 1 >> 8 & 0xff;
            buffer$$1[index] = size + 1 & 0xff; // Update index

            index = index + 4 + size; // Write zero

            buffer$$1[index++] = 0;
            return index;
          }

          function serializeNumber(buffer$$1, key, value, index, isArray) {
            // We have an integer value
            if (Math.floor(value) === value && value >= constants.JS_INT_MIN && value <= constants.JS_INT_MAX) {
              // If the value fits in 32 bits encode as int, if it fits in a double
              // encode it as a double, otherwise long
              if (value >= constants.BSON_INT32_MIN && value <= constants.BSON_INT32_MAX) {
                // Set int type 32 bits or less
                buffer$$1[index++] = constants.BSON_DATA_INT; // Number of written bytes

                var numberOfWrittenBytes = !isArray ? buffer$$1.write(key, index, 'utf8') : buffer$$1.write(key, index, 'ascii'); // Encode the name

                index = index + numberOfWrittenBytes;
                buffer$$1[index++] = 0; // Write the int value

                buffer$$1[index++] = value & 0xff;
                buffer$$1[index++] = value >> 8 & 0xff;
                buffer$$1[index++] = value >> 16 & 0xff;
                buffer$$1[index++] = value >> 24 & 0xff;
              } else if (value >= constants.JS_INT_MIN && value <= constants.JS_INT_MAX) {
                // Encode as double
                buffer$$1[index++] = constants.BSON_DATA_NUMBER; // Number of written bytes

                var _numberOfWrittenBytes = !isArray ? buffer$$1.write(key, index, 'utf8') : buffer$$1.write(key, index, 'ascii'); // Encode the name


                index = index + _numberOfWrittenBytes;
                buffer$$1[index++] = 0; // Write float

                writeIEEE754$1(buffer$$1, value, index, 'little', 52, 8); // Ajust index

                index = index + 8;
              } else {
                // Set long type
                buffer$$1[index++] = constants.BSON_DATA_LONG; // Number of written bytes

                var _numberOfWrittenBytes2 = !isArray ? buffer$$1.write(key, index, 'utf8') : buffer$$1.write(key, index, 'ascii'); // Encode the name


                index = index + _numberOfWrittenBytes2;
                buffer$$1[index++] = 0;
                var longVal = long_1.fromNumber(value);
                var lowBits = longVal.getLowBits();
                var highBits = longVal.getHighBits(); // Encode low bits

                buffer$$1[index++] = lowBits & 0xff;
                buffer$$1[index++] = lowBits >> 8 & 0xff;
                buffer$$1[index++] = lowBits >> 16 & 0xff;
                buffer$$1[index++] = lowBits >> 24 & 0xff; // Encode high bits

                buffer$$1[index++] = highBits & 0xff;
                buffer$$1[index++] = highBits >> 8 & 0xff;
                buffer$$1[index++] = highBits >> 16 & 0xff;
                buffer$$1[index++] = highBits >> 24 & 0xff;
              }
            } else {
              // Encode as double
              buffer$$1[index++] = constants.BSON_DATA_NUMBER; // Number of written bytes

              var _numberOfWrittenBytes3 = !isArray ? buffer$$1.write(key, index, 'utf8') : buffer$$1.write(key, index, 'ascii'); // Encode the name


              index = index + _numberOfWrittenBytes3;
              buffer$$1[index++] = 0; // Write float

              writeIEEE754$1(buffer$$1, value, index, 'little', 52, 8); // Ajust index

              index = index + 8;
            }

            return index;
          }

          function serializeNull(buffer$$1, key, value, index, isArray) {
            // Set long type
            buffer$$1[index++] = constants.BSON_DATA_NULL; // Number of written bytes

            var numberOfWrittenBytes = !isArray ? buffer$$1.write(key, index, 'utf8') : buffer$$1.write(key, index, 'ascii'); // Encode the name

            index = index + numberOfWrittenBytes;
            buffer$$1[index++] = 0;
            return index;
          }

          function serializeBoolean(buffer$$1, key, value, index, isArray) {
            // Write the type
            buffer$$1[index++] = constants.BSON_DATA_BOOLEAN; // Number of written bytes

            var numberOfWrittenBytes = !isArray ? buffer$$1.write(key, index, 'utf8') : buffer$$1.write(key, index, 'ascii'); // Encode the name

            index = index + numberOfWrittenBytes;
            buffer$$1[index++] = 0; // Encode the boolean value

            buffer$$1[index++] = value ? 1 : 0;
            return index;
          }

          function serializeDate(buffer$$1, key, value, index, isArray) {
            // Write the type
            buffer$$1[index++] = constants.BSON_DATA_DATE; // Number of written bytes

            var numberOfWrittenBytes = !isArray ? buffer$$1.write(key, index, 'utf8') : buffer$$1.write(key, index, 'ascii'); // Encode the name

            index = index + numberOfWrittenBytes;
            buffer$$1[index++] = 0; // Write the date

            var dateInMilis = long_1.fromNumber(value.getTime());
            var lowBits = dateInMilis.getLowBits();
            var highBits = dateInMilis.getHighBits(); // Encode low bits

            buffer$$1[index++] = lowBits & 0xff;
            buffer$$1[index++] = lowBits >> 8 & 0xff;
            buffer$$1[index++] = lowBits >> 16 & 0xff;
            buffer$$1[index++] = lowBits >> 24 & 0xff; // Encode high bits

            buffer$$1[index++] = highBits & 0xff;
            buffer$$1[index++] = highBits >> 8 & 0xff;
            buffer$$1[index++] = highBits >> 16 & 0xff;
            buffer$$1[index++] = highBits >> 24 & 0xff;
            return index;
          }

          function serializeRegExp(buffer$$1, key, value, index, isArray) {
            // Write the type
            buffer$$1[index++] = constants.BSON_DATA_REGEXP; // Number of written bytes

            var numberOfWrittenBytes = !isArray ? buffer$$1.write(key, index, 'utf8') : buffer$$1.write(key, index, 'ascii'); // Encode the name

            index = index + numberOfWrittenBytes;
            buffer$$1[index++] = 0;

            if (value.source && value.source.match(regexp$1) != null) {
              throw Error('value ' + value.source + ' must not contain null bytes');
            } // Adjust the index


            index = index + buffer$$1.write(value.source, index, 'utf8'); // Write zero

            buffer$$1[index++] = 0x00; // Write the parameters

            if (value.ignoreCase) buffer$$1[index++] = 0x69; // i

            if (value.global) buffer$$1[index++] = 0x73; // s

            if (value.multiline) buffer$$1[index++] = 0x6d; // m
            // Add ending zero

            buffer$$1[index++] = 0x00;
            return index;
          }

          function serializeBSONRegExp(buffer$$1, key, value, index, isArray) {
            // Write the type
            buffer$$1[index++] = constants.BSON_DATA_REGEXP; // Number of written bytes

            var numberOfWrittenBytes = !isArray ? buffer$$1.write(key, index, 'utf8') : buffer$$1.write(key, index, 'ascii'); // Encode the name

            index = index + numberOfWrittenBytes;
            buffer$$1[index++] = 0; // Check the pattern for 0 bytes

            if (value.pattern.match(regexp$1) != null) {
              // The BSON spec doesn't allow keys with null bytes because keys are
              // null-terminated.
              throw Error('pattern ' + value.pattern + ' must not contain null bytes');
            } // Adjust the index


            index = index + buffer$$1.write(value.pattern, index, 'utf8'); // Write zero

            buffer$$1[index++] = 0x00; // Write the options

            index = index + buffer$$1.write(value.options.split('').sort().join(''), index, 'utf8'); // Add ending zero

            buffer$$1[index++] = 0x00;
            return index;
          }

          function serializeMinMax(buffer$$1, key, value, index, isArray) {
            // Write the type of either min or max key
            if (value === null) {
              buffer$$1[index++] = constants.BSON_DATA_NULL;
            } else if (value._bsontype === 'MinKey') {
              buffer$$1[index++] = constants.BSON_DATA_MIN_KEY;
            } else {
              buffer$$1[index++] = constants.BSON_DATA_MAX_KEY;
            } // Number of written bytes


            var numberOfWrittenBytes = !isArray ? buffer$$1.write(key, index, 'utf8') : buffer$$1.write(key, index, 'ascii'); // Encode the name

            index = index + numberOfWrittenBytes;
            buffer$$1[index++] = 0;
            return index;
          }

          function serializeObjectId(buffer$$1, key, value, index, isArray) {
            // Write the type
            buffer$$1[index++] = constants.BSON_DATA_OID; // Number of written bytes

            var numberOfWrittenBytes = !isArray ? buffer$$1.write(key, index, 'utf8') : buffer$$1.write(key, index, 'ascii'); // Encode the name

            index = index + numberOfWrittenBytes;
            buffer$$1[index++] = 0; // Write the objectId into the shared buffer

            if (typeof value.id === 'string') {
              buffer$$1.write(value.id, index, 'binary');
            } else if (value.id && value.id.copy) {
              value.id.copy(buffer$$1, index, 0, 12);
            } else {
              throw new TypeError('object [' + JSON.stringify(value) + '] is not a valid ObjectId');
            } // Ajust index


            return index + 12;
          }

          function serializeBuffer(buffer$$1, key, value, index, isArray) {
            // Write the type
            buffer$$1[index++] = constants.BSON_DATA_BINARY; // Number of written bytes

            var numberOfWrittenBytes = !isArray ? buffer$$1.write(key, index, 'utf8') : buffer$$1.write(key, index, 'ascii'); // Encode the name

            index = index + numberOfWrittenBytes;
            buffer$$1[index++] = 0; // Get size of the buffer (current write point)

            var size = value.length; // Write the size of the string to buffer

            buffer$$1[index++] = size & 0xff;
            buffer$$1[index++] = size >> 8 & 0xff;
            buffer$$1[index++] = size >> 16 & 0xff;
            buffer$$1[index++] = size >> 24 & 0xff; // Write the default subtype

            buffer$$1[index++] = constants.BSON_BINARY_SUBTYPE_DEFAULT; // Copy the content form the binary field to the buffer

            value.copy(buffer$$1, index, 0, size); // Adjust the index

            index = index + size;
            return index;
          }

          function serializeObject(buffer$$1, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, isArray, path) {
            for (var i = 0; i < path.length; i++) {
              if (path[i] === value) throw new Error('cyclic dependency detected');
            } // Push value to stack


            path.push(value); // Write the type

            buffer$$1[index++] = Array.isArray(value) ? constants.BSON_DATA_ARRAY : constants.BSON_DATA_OBJECT; // Number of written bytes

            var numberOfWrittenBytes = !isArray ? buffer$$1.write(key, index, 'utf8') : buffer$$1.write(key, index, 'ascii'); // Encode the name

            index = index + numberOfWrittenBytes;
            buffer$$1[index++] = 0;
            var endIndex = serializeInto(buffer$$1, value, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path); // Pop stack

            path.pop();
            return endIndex;
          }

          function serializeDecimal128(buffer$$1, key, value, index, isArray) {
            buffer$$1[index++] = constants.BSON_DATA_DECIMAL128; // Number of written bytes

            var numberOfWrittenBytes = !isArray ? buffer$$1.write(key, index, 'utf8') : buffer$$1.write(key, index, 'ascii'); // Encode the name

            index = index + numberOfWrittenBytes;
            buffer$$1[index++] = 0; // Write the data from the value

            value.bytes.copy(buffer$$1, index, 0, 16);
            return index + 16;
          }

          function serializeLong(buffer$$1, key, value, index, isArray) {
            // Write the type
            buffer$$1[index++] = value._bsontype === 'Long' ? constants.BSON_DATA_LONG : constants.BSON_DATA_TIMESTAMP; // Number of written bytes

            var numberOfWrittenBytes = !isArray ? buffer$$1.write(key, index, 'utf8') : buffer$$1.write(key, index, 'ascii'); // Encode the name

            index = index + numberOfWrittenBytes;
            buffer$$1[index++] = 0; // Write the date

            var lowBits = value.getLowBits();
            var highBits = value.getHighBits(); // Encode low bits

            buffer$$1[index++] = lowBits & 0xff;
            buffer$$1[index++] = lowBits >> 8 & 0xff;
            buffer$$1[index++] = lowBits >> 16 & 0xff;
            buffer$$1[index++] = lowBits >> 24 & 0xff; // Encode high bits

            buffer$$1[index++] = highBits & 0xff;
            buffer$$1[index++] = highBits >> 8 & 0xff;
            buffer$$1[index++] = highBits >> 16 & 0xff;
            buffer$$1[index++] = highBits >> 24 & 0xff;
            return index;
          }

          function serializeInt32(buffer$$1, key, value, index, isArray) {
            // Set int type 32 bits or less
            buffer$$1[index++] = constants.BSON_DATA_INT; // Number of written bytes

            var numberOfWrittenBytes = !isArray ? buffer$$1.write(key, index, 'utf8') : buffer$$1.write(key, index, 'ascii'); // Encode the name

            index = index + numberOfWrittenBytes;
            buffer$$1[index++] = 0; // Write the int value

            buffer$$1[index++] = value & 0xff;
            buffer$$1[index++] = value >> 8 & 0xff;
            buffer$$1[index++] = value >> 16 & 0xff;
            buffer$$1[index++] = value >> 24 & 0xff;
            return index;
          }

          function serializeDouble(buffer$$1, key, value, index, isArray) {
            // Encode as double
            buffer$$1[index++] = constants.BSON_DATA_NUMBER; // Number of written bytes

            var numberOfWrittenBytes = !isArray ? buffer$$1.write(key, index, 'utf8') : buffer$$1.write(key, index, 'ascii'); // Encode the name

            index = index + numberOfWrittenBytes;
            buffer$$1[index++] = 0; // Write float

            writeIEEE754$1(buffer$$1, value.value, index, 'little', 52, 8); // Adjust index

            index = index + 8;
            return index;
          }

          function serializeFunction(buffer$$1, key, value, index, checkKeys, depth, isArray) {
            buffer$$1[index++] = constants.BSON_DATA_CODE; // Number of written bytes

            var numberOfWrittenBytes = !isArray ? buffer$$1.write(key, index, 'utf8') : buffer$$1.write(key, index, 'ascii'); // Encode the name

            index = index + numberOfWrittenBytes;
            buffer$$1[index++] = 0; // Function string

            var functionString = normalizedFunctionString$1(value); // Write the string

            var size = buffer$$1.write(functionString, index + 4, 'utf8') + 1; // Write the size of the string to buffer

            buffer$$1[index] = size & 0xff;
            buffer$$1[index + 1] = size >> 8 & 0xff;
            buffer$$1[index + 2] = size >> 16 & 0xff;
            buffer$$1[index + 3] = size >> 24 & 0xff; // Update index

            index = index + 4 + size - 1; // Write zero

            buffer$$1[index++] = 0;
            return index;
          }

          function serializeCode(buffer$$1, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, isArray) {
            if (value.scope && _typeof$3(value.scope) === 'object') {
              // Write the type
              buffer$$1[index++] = constants.BSON_DATA_CODE_W_SCOPE; // Number of written bytes

              var numberOfWrittenBytes = !isArray ? buffer$$1.write(key, index, 'utf8') : buffer$$1.write(key, index, 'ascii'); // Encode the name

              index = index + numberOfWrittenBytes;
              buffer$$1[index++] = 0; // Starting index

              var startIndex = index; // Serialize the function
              // Get the function string

              var functionString = typeof value.code === 'string' ? value.code : value.code.toString(); // Index adjustment

              index = index + 4; // Write string into buffer

              var codeSize = buffer$$1.write(functionString, index + 4, 'utf8') + 1; // Write the size of the string to buffer

              buffer$$1[index] = codeSize & 0xff;
              buffer$$1[index + 1] = codeSize >> 8 & 0xff;
              buffer$$1[index + 2] = codeSize >> 16 & 0xff;
              buffer$$1[index + 3] = codeSize >> 24 & 0xff; // Write end 0

              buffer$$1[index + 4 + codeSize - 1] = 0; // Write the

              index = index + codeSize + 4; //
              // Serialize the scope value

              var endIndex = serializeInto(buffer$$1, value.scope, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined);
              index = endIndex - 1; // Writ the total

              var totalSize = endIndex - startIndex; // Write the total size of the object

              buffer$$1[startIndex++] = totalSize & 0xff;
              buffer$$1[startIndex++] = totalSize >> 8 & 0xff;
              buffer$$1[startIndex++] = totalSize >> 16 & 0xff;
              buffer$$1[startIndex++] = totalSize >> 24 & 0xff; // Write trailing zero

              buffer$$1[index++] = 0;
            } else {
              buffer$$1[index++] = constants.BSON_DATA_CODE; // Number of written bytes

              var _numberOfWrittenBytes4 = !isArray ? buffer$$1.write(key, index, 'utf8') : buffer$$1.write(key, index, 'ascii'); // Encode the name


              index = index + _numberOfWrittenBytes4;
              buffer$$1[index++] = 0; // Function string

              var _functionString = value.code.toString(); // Write the string


              var size = buffer$$1.write(_functionString, index + 4, 'utf8') + 1; // Write the size of the string to buffer

              buffer$$1[index] = size & 0xff;
              buffer$$1[index + 1] = size >> 8 & 0xff;
              buffer$$1[index + 2] = size >> 16 & 0xff;
              buffer$$1[index + 3] = size >> 24 & 0xff; // Update index

              index = index + 4 + size - 1; // Write zero

              buffer$$1[index++] = 0;
            }

            return index;
          }

          function serializeBinary(buffer$$1, key, value, index, isArray) {
            // Write the type
            buffer$$1[index++] = constants.BSON_DATA_BINARY; // Number of written bytes

            var numberOfWrittenBytes = !isArray ? buffer$$1.write(key, index, 'utf8') : buffer$$1.write(key, index, 'ascii'); // Encode the name

            index = index + numberOfWrittenBytes;
            buffer$$1[index++] = 0; // Extract the buffer

            var data = value.value(true); // Calculate size

            var size = value.position; // Add the deprecated 02 type 4 bytes of size to total

            if (value.sub_type === binary.SUBTYPE_BYTE_ARRAY) size = size + 4; // Write the size of the string to buffer

            buffer$$1[index++] = size & 0xff;
            buffer$$1[index++] = size >> 8 & 0xff;
            buffer$$1[index++] = size >> 16 & 0xff;
            buffer$$1[index++] = size >> 24 & 0xff; // Write the subtype to the buffer

            buffer$$1[index++] = value.sub_type; // If we have binary type 2 the 4 first bytes are the size

            if (value.sub_type === binary.SUBTYPE_BYTE_ARRAY) {
              size = size - 4;
              buffer$$1[index++] = size & 0xff;
              buffer$$1[index++] = size >> 8 & 0xff;
              buffer$$1[index++] = size >> 16 & 0xff;
              buffer$$1[index++] = size >> 24 & 0xff;
            } // Write the data to the object


            data.copy(buffer$$1, index, 0, value.position); // Adjust the index

            index = index + value.position;
            return index;
          }

          function serializeSymbol(buffer$$1, key, value, index, isArray) {
            // Write the type
            buffer$$1[index++] = constants.BSON_DATA_SYMBOL; // Number of written bytes

            var numberOfWrittenBytes = !isArray ? buffer$$1.write(key, index, 'utf8') : buffer$$1.write(key, index, 'ascii'); // Encode the name

            index = index + numberOfWrittenBytes;
            buffer$$1[index++] = 0; // Write the string

            var size = buffer$$1.write(value.value, index + 4, 'utf8') + 1; // Write the size of the string to buffer

            buffer$$1[index] = size & 0xff;
            buffer$$1[index + 1] = size >> 8 & 0xff;
            buffer$$1[index + 2] = size >> 16 & 0xff;
            buffer$$1[index + 3] = size >> 24 & 0xff; // Update index

            index = index + 4 + size - 1; // Write zero

            buffer$$1[index++] = 0x00;
            return index;
          }

          function serializeDBRef(buffer$$1, key, value, index, depth, serializeFunctions, isArray) {
            // Write the type
            buffer$$1[index++] = constants.BSON_DATA_OBJECT; // Number of written bytes

            var numberOfWrittenBytes = !isArray ? buffer$$1.write(key, index, 'utf8') : buffer$$1.write(key, index, 'ascii'); // Encode the name

            index = index + numberOfWrittenBytes;
            buffer$$1[index++] = 0;
            var startIndex = index;
            var endIndex;
            var output = {
              $ref: value.collection || value.namespace,
              // "namespace" was what library 1.x called "collection"
              $id: value.oid
            };
            if (value.db != null) output.$db = value.db;
            output = Object.assign(output, value.fields);
            endIndex = serializeInto(buffer$$1, output, false, index, depth + 1, serializeFunctions); // Calculate object size

            var size = endIndex - startIndex; // Write the size

            buffer$$1[startIndex++] = size & 0xff;
            buffer$$1[startIndex++] = size >> 8 & 0xff;
            buffer$$1[startIndex++] = size >> 16 & 0xff;
            buffer$$1[startIndex++] = size >> 24 & 0xff; // Set index

            return endIndex;
          }

          function serializeInto(buffer$$1, object, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined, path) {
            startingIndex = startingIndex || 0;
            path = path || []; // Push the object to the path

            path.push(object); // Start place to serialize into

            var index = startingIndex + 4; // Special case isArray

            if (Array.isArray(object)) {
              // Get object keys
              for (var i = 0; i < object.length; i++) {
                var key = '' + i;
                var value = object[i]; // Is there an override value

                if (value && value.toBSON) {
                  if (typeof value.toBSON !== 'function') throw new TypeError('toBSON is not a function');
                  value = value.toBSON();
                }

                var type = _typeof$3(value);

                if (type === 'string') {
                  index = serializeString(buffer$$1, key, value, index, true);
                } else if (type === 'number') {
                  index = serializeNumber(buffer$$1, key, value, index, true);
                } else if (type === 'boolean') {
                  index = serializeBoolean(buffer$$1, key, value, index, true);
                } else if (value instanceof Date || isDate$1(value)) {
                  index = serializeDate(buffer$$1, key, value, index, true);
                } else if (value === undefined) {
                  index = serializeNull(buffer$$1, key, value, index, true);
                } else if (value === null) {
                  index = serializeNull(buffer$$1, key, value, index, true);
                } else if (value['_bsontype'] === 'ObjectId' || value['_bsontype'] === 'ObjectID') {
                  index = serializeObjectId(buffer$$1, key, value, index, true);
                } else if (Buffer$5.isBuffer(value)) {
                  index = serializeBuffer(buffer$$1, key, value, index, true);
                } else if (value instanceof RegExp || isRegExp$1(value)) {
                  index = serializeRegExp(buffer$$1, key, value, index, true);
                } else if (type === 'object' && value['_bsontype'] == null) {
                  index = serializeObject(buffer$$1, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, true, path);
                } else if (type === 'object' && value['_bsontype'] === 'Decimal128') {
                  index = serializeDecimal128(buffer$$1, key, value, index, true);
                } else if (value['_bsontype'] === 'Long' || value['_bsontype'] === 'Timestamp') {
                  index = serializeLong(buffer$$1, key, value, index, true);
                } else if (value['_bsontype'] === 'Double') {
                  index = serializeDouble(buffer$$1, key, value, index, true);
                } else if (typeof value === 'function' && serializeFunctions) {
                  index = serializeFunction(buffer$$1, key, value, index, checkKeys, depth, serializeFunctions);
                } else if (value['_bsontype'] === 'Code') {
                  index = serializeCode(buffer$$1, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, true);
                } else if (value['_bsontype'] === 'Binary') {
                  index = serializeBinary(buffer$$1, key, value, index, true);
                } else if (value['_bsontype'] === 'Symbol') {
                  index = serializeSymbol(buffer$$1, key, value, index, true);
                } else if (value['_bsontype'] === 'DBRef') {
                  index = serializeDBRef(buffer$$1, key, value, index, depth, serializeFunctions, true);
                } else if (value['_bsontype'] === 'BSONRegExp') {
                  index = serializeBSONRegExp(buffer$$1, key, value, index, true);
                } else if (value['_bsontype'] === 'Int32') {
                  index = serializeInt32(buffer$$1, key, value, index, true);
                } else if (value['_bsontype'] === 'MinKey' || value['_bsontype'] === 'MaxKey') {
                  index = serializeMinMax(buffer$$1, key, value, index, true);
                } else if (typeof value['_bsontype'] !== 'undefined') {
                  throw new TypeError('Unrecognized or invalid _bsontype: ' + value['_bsontype']);
                }
              }
            } else if (object instanceof map) {
              var iterator = object.entries();
              var done = false;

              while (!done) {
                // Unpack the next entry
                var entry = iterator.next();
                done = entry.done; // Are we done, then skip and terminate

                if (done) continue; // Get the entry values

                var _key = entry.value[0];
                var _value = entry.value[1]; // Check the type of the value

                var _type = _typeof$3(_value); // Check the key and throw error if it's illegal


                if (typeof _key === 'string' && !ignoreKeys.has(_key)) {
                  if (_key.match(regexp$1) != null) {
                    // The BSON spec doesn't allow keys with null bytes because keys are
                    // null-terminated.
                    throw Error('key ' + _key + ' must not contain null bytes');
                  }

                  if (checkKeys) {
                    if ('$' === _key[0]) {
                      throw Error('key ' + _key + " must not start with '$'");
                    } else if (~_key.indexOf('.')) {
                      throw Error('key ' + _key + " must not contain '.'");
                    }
                  }
                }

                if (_type === 'string') {
                  index = serializeString(buffer$$1, _key, _value, index);
                } else if (_type === 'number') {
                  index = serializeNumber(buffer$$1, _key, _value, index);
                } else if (_type === 'boolean') {
                  index = serializeBoolean(buffer$$1, _key, _value, index);
                } else if (_value instanceof Date || isDate$1(_value)) {
                  index = serializeDate(buffer$$1, _key, _value, index);
                } else if (_value === null || _value === undefined && ignoreUndefined === false) {
                  index = serializeNull(buffer$$1, _key, _value, index);
                } else if (_value['_bsontype'] === 'ObjectId' || _value['_bsontype'] === 'ObjectID') {
                  index = serializeObjectId(buffer$$1, _key, _value, index);
                } else if (Buffer$5.isBuffer(_value)) {
                  index = serializeBuffer(buffer$$1, _key, _value, index);
                } else if (_value instanceof RegExp || isRegExp$1(_value)) {
                  index = serializeRegExp(buffer$$1, _key, _value, index);
                } else if (_type === 'object' && _value['_bsontype'] == null) {
                  index = serializeObject(buffer$$1, _key, _value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, false, path);
                } else if (_type === 'object' && _value['_bsontype'] === 'Decimal128') {
                  index = serializeDecimal128(buffer$$1, _key, _value, index);
                } else if (_value['_bsontype'] === 'Long' || _value['_bsontype'] === 'Timestamp') {
                  index = serializeLong(buffer$$1, _key, _value, index);
                } else if (_value['_bsontype'] === 'Double') {
                  index = serializeDouble(buffer$$1, _key, _value, index);
                } else if (_value['_bsontype'] === 'Code') {
                  index = serializeCode(buffer$$1, _key, _value, index, checkKeys, depth, serializeFunctions, ignoreUndefined);
                } else if (typeof _value === 'function' && serializeFunctions) {
                  index = serializeFunction(buffer$$1, _key, _value, index, checkKeys, depth, serializeFunctions);
                } else if (_value['_bsontype'] === 'Binary') {
                  index = serializeBinary(buffer$$1, _key, _value, index);
                } else if (_value['_bsontype'] === 'Symbol') {
                  index = serializeSymbol(buffer$$1, _key, _value, index);
                } else if (_value['_bsontype'] === 'DBRef') {
                  index = serializeDBRef(buffer$$1, _key, _value, index, depth, serializeFunctions);
                } else if (_value['_bsontype'] === 'BSONRegExp') {
                  index = serializeBSONRegExp(buffer$$1, _key, _value, index);
                } else if (_value['_bsontype'] === 'Int32') {
                  index = serializeInt32(buffer$$1, _key, _value, index);
                } else if (_value['_bsontype'] === 'MinKey' || _value['_bsontype'] === 'MaxKey') {
                  index = serializeMinMax(buffer$$1, _key, _value, index);
                } else if (typeof _value['_bsontype'] !== 'undefined') {
                  throw new TypeError('Unrecognized or invalid _bsontype: ' + _value['_bsontype']);
                }
              }
            } else {
              // Did we provide a custom serialization method
              if (object.toBSON) {
                if (typeof object.toBSON !== 'function') throw new TypeError('toBSON is not a function');
                object = object.toBSON();
                if (object != null && _typeof$3(object) !== 'object') throw new TypeError('toBSON function did not return an object');
              } // Iterate over all the keys


              for (var _key2 in object) {
                var _value2 = object[_key2]; // Is there an override value

                if (_value2 && _value2.toBSON) {
                  if (typeof _value2.toBSON !== 'function') throw new TypeError('toBSON is not a function');
                  _value2 = _value2.toBSON();
                } // Check the type of the value


                var _type2 = _typeof$3(_value2); // Check the key and throw error if it's illegal


                if (typeof _key2 === 'string' && !ignoreKeys.has(_key2)) {
                  if (_key2.match(regexp$1) != null) {
                    // The BSON spec doesn't allow keys with null bytes because keys are
                    // null-terminated.
                    throw Error('key ' + _key2 + ' must not contain null bytes');
                  }

                  if (checkKeys) {
                    if ('$' === _key2[0]) {
                      throw Error('key ' + _key2 + " must not start with '$'");
                    } else if (~_key2.indexOf('.')) {
                      throw Error('key ' + _key2 + " must not contain '.'");
                    }
                  }
                }

                if (_type2 === 'string') {
                  index = serializeString(buffer$$1, _key2, _value2, index);
                } else if (_type2 === 'number') {
                  index = serializeNumber(buffer$$1, _key2, _value2, index);
                } else if (_type2 === 'boolean') {
                  index = serializeBoolean(buffer$$1, _key2, _value2, index);
                } else if (_value2 instanceof Date || isDate$1(_value2)) {
                  index = serializeDate(buffer$$1, _key2, _value2, index);
                } else if (_value2 === undefined) {
                  if (ignoreUndefined === false) index = serializeNull(buffer$$1, _key2, _value2, index);
                } else if (_value2 === null) {
                  index = serializeNull(buffer$$1, _key2, _value2, index);
                } else if (_value2['_bsontype'] === 'ObjectId' || _value2['_bsontype'] === 'ObjectID') {
                  index = serializeObjectId(buffer$$1, _key2, _value2, index);
                } else if (Buffer$5.isBuffer(_value2)) {
                  index = serializeBuffer(buffer$$1, _key2, _value2, index);
                } else if (_value2 instanceof RegExp || isRegExp$1(_value2)) {
                  index = serializeRegExp(buffer$$1, _key2, _value2, index);
                } else if (_type2 === 'object' && _value2['_bsontype'] == null) {
                  index = serializeObject(buffer$$1, _key2, _value2, index, checkKeys, depth, serializeFunctions, ignoreUndefined, false, path);
                } else if (_type2 === 'object' && _value2['_bsontype'] === 'Decimal128') {
                  index = serializeDecimal128(buffer$$1, _key2, _value2, index);
                } else if (_value2['_bsontype'] === 'Long' || _value2['_bsontype'] === 'Timestamp') {
                  index = serializeLong(buffer$$1, _key2, _value2, index);
                } else if (_value2['_bsontype'] === 'Double') {
                  index = serializeDouble(buffer$$1, _key2, _value2, index);
                } else if (_value2['_bsontype'] === 'Code') {
                  index = serializeCode(buffer$$1, _key2, _value2, index, checkKeys, depth, serializeFunctions, ignoreUndefined);
                } else if (typeof _value2 === 'function' && serializeFunctions) {
                  index = serializeFunction(buffer$$1, _key2, _value2, index, checkKeys, depth, serializeFunctions);
                } else if (_value2['_bsontype'] === 'Binary') {
                  index = serializeBinary(buffer$$1, _key2, _value2, index);
                } else if (_value2['_bsontype'] === 'Symbol') {
                  index = serializeSymbol(buffer$$1, _key2, _value2, index);
                } else if (_value2['_bsontype'] === 'DBRef') {
                  index = serializeDBRef(buffer$$1, _key2, _value2, index, depth, serializeFunctions);
                } else if (_value2['_bsontype'] === 'BSONRegExp') {
                  index = serializeBSONRegExp(buffer$$1, _key2, _value2, index);
                } else if (_value2['_bsontype'] === 'Int32') {
                  index = serializeInt32(buffer$$1, _key2, _value2, index);
                } else if (_value2['_bsontype'] === 'MinKey' || _value2['_bsontype'] === 'MaxKey') {
                  index = serializeMinMax(buffer$$1, _key2, _value2, index);
                } else if (typeof _value2['_bsontype'] !== 'undefined') {
                  throw new TypeError('Unrecognized or invalid _bsontype: ' + _value2['_bsontype']);
                }
              }
            } // Remove the path


            path.pop(); // Final padding byte for object

            buffer$$1[index++] = 0x00; // Final size

            var size = index - startingIndex; // Write the size of the object

            buffer$$1[startingIndex++] = size & 0xff;
            buffer$$1[startingIndex++] = size >> 8 & 0xff;
            buffer$$1[startingIndex++] = size >> 16 & 0xff;
            buffer$$1[startingIndex++] = size >> 24 & 0xff;
            return index;
          }

          var serializer = serializeInto;

          function _typeof$4(obj) {
            if (typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol") {
              _typeof$4 = function _typeof$1(obj) {
                return _typeof(obj);
              };
            } else {
              _typeof$4 = function _typeof$1(obj) {
                return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof(obj);
              };
            }

            return _typeof$4(obj);
          }

          var Buffer$6 = buffer.Buffer;
          var normalizedFunctionString$2 = utils.normalizedFunctionString; // To ensure that 0.4 of node works correctly

          function isDate$2(d) {
            return _typeof$4(d) === 'object' && Object.prototype.toString.call(d) === '[object Date]';
          }

          function calculateObjectSize(object, serializeFunctions, ignoreUndefined) {
            var totalLength = 4 + 1;

            if (Array.isArray(object)) {
              for (var i = 0; i < object.length; i++) {
                totalLength += calculateElement(i.toString(), object[i], serializeFunctions, true, ignoreUndefined);
              }
            } else {
              // If we have toBSON defined, override the current object
              if (object.toBSON) {
                object = object.toBSON();
              } // Calculate size


              for (var key in object) {
                totalLength += calculateElement(key, object[key], serializeFunctions, false, ignoreUndefined);
              }
            }

            return totalLength;
          }
          /**
           * @ignore
           * @api private
           */


          function calculateElement(name, value, serializeFunctions, isArray, ignoreUndefined) {
            // If we have toBSON defined, override the current object
            if (value && value.toBSON) {
              value = value.toBSON();
            }

            switch (_typeof$4(value)) {
              case 'string':
                return 1 + Buffer$6.byteLength(name, 'utf8') + 1 + 4 + Buffer$6.byteLength(value, 'utf8') + 1;

              case 'number':
                if (Math.floor(value) === value && value >= constants.JS_INT_MIN && value <= constants.JS_INT_MAX) {
                  if (value >= constants.BSON_INT32_MIN && value <= constants.BSON_INT32_MAX) {
                    // 32 bit
                    return (name != null ? Buffer$6.byteLength(name, 'utf8') + 1 : 0) + (4 + 1);
                  } else {
                    return (name != null ? Buffer$6.byteLength(name, 'utf8') + 1 : 0) + (8 + 1);
                  }
                } else {
                  // 64 bit
                  return (name != null ? Buffer$6.byteLength(name, 'utf8') + 1 : 0) + (8 + 1);
                }

              case 'undefined':
                if (isArray || !ignoreUndefined) return (name != null ? Buffer$6.byteLength(name, 'utf8') + 1 : 0) + 1;
                return 0;

              case 'boolean':
                return (name != null ? Buffer$6.byteLength(name, 'utf8') + 1 : 0) + (1 + 1);

              case 'object':
                if (value == null || value['_bsontype'] === 'MinKey' || value['_bsontype'] === 'MaxKey') {
                  return (name != null ? Buffer$6.byteLength(name, 'utf8') + 1 : 0) + 1;
                } else if (value['_bsontype'] === 'ObjectId' || value['_bsontype'] === 'ObjectID') {
                  return (name != null ? Buffer$6.byteLength(name, 'utf8') + 1 : 0) + (12 + 1);
                } else if (value instanceof Date || isDate$2(value)) {
                  return (name != null ? Buffer$6.byteLength(name, 'utf8') + 1 : 0) + (8 + 1);
                } else if (typeof Buffer$6 !== 'undefined' && Buffer$6.isBuffer(value)) {
                  return (name != null ? Buffer$6.byteLength(name, 'utf8') + 1 : 0) + (1 + 4 + 1) + value.length;
                } else if (value['_bsontype'] === 'Long' || value['_bsontype'] === 'Double' || value['_bsontype'] === 'Timestamp') {
                  return (name != null ? Buffer$6.byteLength(name, 'utf8') + 1 : 0) + (8 + 1);
                } else if (value['_bsontype'] === 'Decimal128') {
                  return (name != null ? Buffer$6.byteLength(name, 'utf8') + 1 : 0) + (16 + 1);
                } else if (value['_bsontype'] === 'Code') {
                  // Calculate size depending on the availability of a scope
                  if (value.scope != null && Object.keys(value.scope).length > 0) {
                    return (name != null ? Buffer$6.byteLength(name, 'utf8') + 1 : 0) + 1 + 4 + 4 + Buffer$6.byteLength(value.code.toString(), 'utf8') + 1 + calculateObjectSize(value.scope, serializeFunctions, ignoreUndefined);
                  } else {
                    return (name != null ? Buffer$6.byteLength(name, 'utf8') + 1 : 0) + 1 + 4 + Buffer$6.byteLength(value.code.toString(), 'utf8') + 1;
                  }
                } else if (value['_bsontype'] === 'Binary') {
                  // Check what kind of subtype we have
                  if (value.sub_type === binary.SUBTYPE_BYTE_ARRAY) {
                    return (name != null ? Buffer$6.byteLength(name, 'utf8') + 1 : 0) + (value.position + 1 + 4 + 1 + 4);
                  } else {
                    return (name != null ? Buffer$6.byteLength(name, 'utf8') + 1 : 0) + (value.position + 1 + 4 + 1);
                  }
                } else if (value['_bsontype'] === 'Symbol') {
                  return (name != null ? Buffer$6.byteLength(name, 'utf8') + 1 : 0) + Buffer$6.byteLength(value.value, 'utf8') + 4 + 1 + 1;
                } else if (value['_bsontype'] === 'DBRef') {
                  // Set up correct object for serialization
                  var ordered_values = Object.assign({
                    $ref: value.collection,
                    $id: value.oid
                  }, value.fields); // Add db reference if it exists

                  if (value.db != null) {
                    ordered_values['$db'] = value.db;
                  }

                  return (name != null ? Buffer$6.byteLength(name, 'utf8') + 1 : 0) + 1 + calculateObjectSize(ordered_values, serializeFunctions, ignoreUndefined);
                } else if (value instanceof RegExp || Object.prototype.toString.call(value) === '[object RegExp]') {
                  return (name != null ? Buffer$6.byteLength(name, 'utf8') + 1 : 0) + 1 + Buffer$6.byteLength(value.source, 'utf8') + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;
                } else if (value['_bsontype'] === 'BSONRegExp') {
                  return (name != null ? Buffer$6.byteLength(name, 'utf8') + 1 : 0) + 1 + Buffer$6.byteLength(value.pattern, 'utf8') + 1 + Buffer$6.byteLength(value.options, 'utf8') + 1;
                } else {
                  return (name != null ? Buffer$6.byteLength(name, 'utf8') + 1 : 0) + calculateObjectSize(value, serializeFunctions, ignoreUndefined) + 1;
                }

              case 'function':
                // WTF for 0.4.X where typeof /someregexp/ === 'function'
                if (value instanceof RegExp || Object.prototype.toString.call(value) === '[object RegExp]' || String.call(value) === '[object RegExp]') {
                  return (name != null ? Buffer$6.byteLength(name, 'utf8') + 1 : 0) + 1 + Buffer$6.byteLength(value.source, 'utf8') + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;
                } else {
                  if (serializeFunctions && value.scope != null && Object.keys(value.scope).length > 0) {
                    return (name != null ? Buffer$6.byteLength(name, 'utf8') + 1 : 0) + 1 + 4 + 4 + Buffer$6.byteLength(normalizedFunctionString$2(value), 'utf8') + 1 + calculateObjectSize(value.scope, serializeFunctions, ignoreUndefined);
                  } else if (serializeFunctions) {
                    return (name != null ? Buffer$6.byteLength(name, 'utf8') + 1 : 0) + 1 + 4 + Buffer$6.byteLength(normalizedFunctionString$2(value), 'utf8') + 1;
                  }
                }

            }

            return 0;
          }

          var calculate_size = calculateObjectSize;
          var Buffer$7 = buffer.Buffer;
          /**
           * Makes sure that, if a Uint8Array is passed in, it is wrapped in a Buffer.
           *
           * @param {Buffer|Uint8Array} potentialBuffer The potential buffer
           * @returns {Buffer} the input if potentialBuffer is a buffer, or a buffer that
           * wraps a passed in Uint8Array
           * @throws {TypeError} If anything other than a Buffer or Uint8Array is passed in
           */

          var ensure_buffer = function ensureBuffer(potentialBuffer) {
            if (potentialBuffer instanceof Buffer$7) {
              return potentialBuffer;
            }

            if (potentialBuffer instanceof Uint8Array) {
              return Buffer$7.from(potentialBuffer.buffer);
            }

            throw new TypeError('Must use either Buffer or Uint8Array');
          };

          var Buffer$8 = buffer.Buffer; // Parts of the parser

          /**
           * @ignore
           */
          // Default Max Size

          var MAXSIZE = 1024 * 1024 * 17; // Current Internal Temporary Serialization Buffer

          var buffer$1 = Buffer$8.alloc(MAXSIZE);
          /**
           * Sets the size of the internal serialization buffer.
           *
           * @method
           * @param {number} size The desired size for the internal serialization buffer
           */

          function setInternalBufferSize(size) {
            // Resize the internal serialization buffer if needed
            if (buffer$1.length < size) {
              buffer$1 = Buffer$8.alloc(size);
            }
          }
          /**
           * Serialize a Javascript object.
           *
           * @param {Object} object the Javascript object to serialize.
           * @param {Boolean} [options.checkKeys] the serializer will check if keys are valid.
           * @param {Boolean} [options.serializeFunctions=false] serialize the javascript functions **(default:false)**.
           * @param {Boolean} [options.ignoreUndefined=true] ignore undefined fields **(default:true)**.
           * @return {Buffer} returns the Buffer object containing the serialized object.
           */


          function serialize$1(object, options) {
            options = options || {}; // Unpack the options

            var checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;
            var serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;
            var ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true;
            var minInternalBufferSize = typeof options.minInternalBufferSize === 'number' ? options.minInternalBufferSize : MAXSIZE; // Resize the internal serialization buffer if needed

            if (buffer$1.length < minInternalBufferSize) {
              buffer$1 = Buffer$8.alloc(minInternalBufferSize);
            } // Attempt to serialize


            var serializationIndex = serializer(buffer$1, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, []); // Create the final buffer

            var finishedBuffer = Buffer$8.alloc(serializationIndex); // Copy into the finished buffer

            buffer$1.copy(finishedBuffer, 0, 0, finishedBuffer.length); // Return the buffer

            return finishedBuffer;
          }
          /**
           * Serialize a Javascript object using a predefined Buffer and index into the buffer, useful when pre-allocating the space for serialization.
           *
           * @param {Object} object the Javascript object to serialize.
           * @param {Buffer} buffer the Buffer you pre-allocated to store the serialized BSON object.
           * @param {Boolean} [options.checkKeys] the serializer will check if keys are valid.
           * @param {Boolean} [options.serializeFunctions=false] serialize the javascript functions **(default:false)**.
           * @param {Boolean} [options.ignoreUndefined=true] ignore undefined fields **(default:true)**.
           * @param {Number} [options.index] the index in the buffer where we wish to start serializing into.
           * @return {Number} returns the index pointing to the last written byte in the buffer.
           */


          function serializeWithBufferAndIndex(object, finalBuffer, options) {
            options = options || {}; // Unpack the options

            var checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;
            var serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;
            var ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true;
            var startIndex = typeof options.index === 'number' ? options.index : 0; // Attempt to serialize

            var serializationIndex = serializer(buffer$1, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined);
            buffer$1.copy(finalBuffer, startIndex, 0, serializationIndex); // Return the index

            return startIndex + serializationIndex - 1;
          }
          /**
           * Deserialize data as BSON.
           *
           * @param {Buffer} buffer the buffer containing the serialized set of BSON documents.
           * @param {Object} [options.evalFunctions=false] evaluate functions in the BSON document scoped to the object deserialized.
           * @param {Object} [options.cacheFunctions=false] cache evaluated functions for reuse.
           * @param {Object} [options.cacheFunctionsCrc32=false] use a crc32 code for caching, otherwise use the string of the function.
           * @param {Object} [options.promoteLongs=true] when deserializing a Long will fit it into a Number if it's smaller than 53 bits
           * @param {Object} [options.promoteBuffers=false] when deserializing a Binary will return it as a node.js Buffer instance.
           * @param {Object} [options.promoteValues=false] when deserializing will promote BSON values to their Node.js closest equivalent types.
           * @param {Object} [options.fieldsAsRaw=null] allow to specify if there what fields we wish to return as unserialized raw buffer.
           * @param {Object} [options.bsonRegExp=false] return BSON regular expressions as BSONRegExp instances.
           * @param {boolean} [options.allowObjectSmallerThanBufferSize=false] allows the buffer to be larger than the parsed BSON object
           * @return {Object} returns the deserialized Javascript Object.
           */


          function deserialize$2(buffer$$1, options) {
            buffer$$1 = ensure_buffer(buffer$$1);
            return deserializer(buffer$$1, options);
          }
          /**
           * Calculate the bson size for a passed in Javascript object.
           *
           * @param {Object} object the Javascript object to calculate the BSON byte size for.
           * @param {Boolean} [options.serializeFunctions=false] serialize the javascript functions **(default:false)**.
           * @param {Boolean} [options.ignoreUndefined=true] ignore undefined fields **(default:true)**.
           * @return {Number} returns the number of bytes the BSON object will take up.
           */


          function calculateObjectSize$1(object, options) {
            options = options || {};
            var serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;
            var ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true;
            return calculate_size(object, serializeFunctions, ignoreUndefined);
          }
          /**
           * Deserialize stream data as BSON documents.
           *
           * @param {Buffer} data the buffer containing the serialized set of BSON documents.
           * @param {Number} startIndex the start index in the data Buffer where the deserialization is to start.
           * @param {Number} numberOfDocuments number of documents to deserialize.
           * @param {Array} documents an array where to store the deserialized documents.
           * @param {Number} docStartIndex the index in the documents array from where to start inserting documents.
           * @param {Object} [options] additional options used for the deserialization.
           * @param {Object} [options.evalFunctions=false] evaluate functions in the BSON document scoped to the object deserialized.
           * @param {Object} [options.cacheFunctions=false] cache evaluated functions for reuse.
           * @param {Object} [options.cacheFunctionsCrc32=false] use a crc32 code for caching, otherwise use the string of the function.
           * @param {Object} [options.promoteLongs=true] when deserializing a Long will fit it into a Number if it's smaller than 53 bits
           * @param {Object} [options.promoteBuffers=false] when deserializing a Binary will return it as a node.js Buffer instance.
           * @param {Object} [options.promoteValues=false] when deserializing will promote BSON values to their Node.js closest equivalent types.
           * @param {Object} [options.fieldsAsRaw=null] allow to specify if there what fields we wish to return as unserialized raw buffer.
           * @param {Object} [options.bsonRegExp=false] return BSON regular expressions as BSONRegExp instances.
           * @return {Number} returns the next index in the buffer after deserialization **x** numbers of documents.
           */


          function deserializeStream(data, startIndex, numberOfDocuments, documents, docStartIndex, options) {
            options = Object.assign({
              allowObjectSmallerThanBufferSize: true
            }, options);
            data = ensure_buffer(data);
            var index = startIndex; // Loop over all documents

            for (var i = 0; i < numberOfDocuments; i++) {
              // Find size of the document
              var size = data[index] | data[index + 1] << 8 | data[index + 2] << 16 | data[index + 3] << 24; // Update options with index

              options.index = index; // Parse the document at this point

              documents[docStartIndex + i] = deserializer(data, options); // Adjust index by the document size

              index = index + size;
            } // Return object containing end index of parsing and list of documents


            return index;
          }

          var bson = {
            // constants
            // NOTE: this is done this way because rollup can't resolve an `Object.assign`ed export
            BSON_INT32_MAX: constants.BSON_INT32_MAX,
            BSON_INT32_MIN: constants.BSON_INT32_MIN,
            BSON_INT64_MAX: constants.BSON_INT64_MAX,
            BSON_INT64_MIN: constants.BSON_INT64_MIN,
            JS_INT_MAX: constants.JS_INT_MAX,
            JS_INT_MIN: constants.JS_INT_MIN,
            BSON_DATA_NUMBER: constants.BSON_DATA_NUMBER,
            BSON_DATA_STRING: constants.BSON_DATA_STRING,
            BSON_DATA_OBJECT: constants.BSON_DATA_OBJECT,
            BSON_DATA_ARRAY: constants.BSON_DATA_ARRAY,
            BSON_DATA_BINARY: constants.BSON_DATA_BINARY,
            BSON_DATA_UNDEFINED: constants.BSON_DATA_UNDEFINED,
            BSON_DATA_OID: constants.BSON_DATA_OID,
            BSON_DATA_BOOLEAN: constants.BSON_DATA_BOOLEAN,
            BSON_DATA_DATE: constants.BSON_DATA_DATE,
            BSON_DATA_NULL: constants.BSON_DATA_NULL,
            BSON_DATA_REGEXP: constants.BSON_DATA_REGEXP,
            BSON_DATA_DBPOINTER: constants.BSON_DATA_DBPOINTER,
            BSON_DATA_CODE: constants.BSON_DATA_CODE,
            BSON_DATA_SYMBOL: constants.BSON_DATA_SYMBOL,
            BSON_DATA_CODE_W_SCOPE: constants.BSON_DATA_CODE_W_SCOPE,
            BSON_DATA_INT: constants.BSON_DATA_INT,
            BSON_DATA_TIMESTAMP: constants.BSON_DATA_TIMESTAMP,
            BSON_DATA_LONG: constants.BSON_DATA_LONG,
            BSON_DATA_DECIMAL128: constants.BSON_DATA_DECIMAL128,
            BSON_DATA_MIN_KEY: constants.BSON_DATA_MIN_KEY,
            BSON_DATA_MAX_KEY: constants.BSON_DATA_MAX_KEY,
            BSON_BINARY_SUBTYPE_DEFAULT: constants.BSON_BINARY_SUBTYPE_DEFAULT,
            BSON_BINARY_SUBTYPE_FUNCTION: constants.BSON_BINARY_SUBTYPE_FUNCTION,
            BSON_BINARY_SUBTYPE_BYTE_ARRAY: constants.BSON_BINARY_SUBTYPE_BYTE_ARRAY,
            BSON_BINARY_SUBTYPE_UUID: constants.BSON_BINARY_SUBTYPE_UUID,
            BSON_BINARY_SUBTYPE_MD5: constants.BSON_BINARY_SUBTYPE_MD5,
            BSON_BINARY_SUBTYPE_USER_DEFINED: constants.BSON_BINARY_SUBTYPE_USER_DEFINED,
            // wrapped types
            Code: code,
            Map: map,
            BSONSymbol: symbol,
            DBRef: db_ref,
            Binary: binary,
            ObjectId: objectid,
            Long: long_1,
            Timestamp: timestamp,
            Double: double_1,
            Int32: int_32,
            MinKey: min_key,
            MaxKey: max_key,
            BSONRegExp: regexp,
            Decimal128: decimal128,
            // methods
            serialize: serialize$1,
            serializeWithBufferAndIndex: serializeWithBufferAndIndex,
            deserialize: deserialize$2,
            calculateObjectSize: calculateObjectSize$1,
            deserializeStream: deserializeStream,
            setInternalBufferSize: setInternalBufferSize,
            // legacy support
            ObjectID: objectid,
            // Extended JSON
            EJSON: extended_json
          };
          var bson_1 = bson.BSON_INT32_MAX;
          var bson_2 = bson.BSON_INT32_MIN;
          var bson_3 = bson.BSON_INT64_MAX;
          var bson_4 = bson.BSON_INT64_MIN;
          var bson_5 = bson.JS_INT_MAX;
          var bson_6 = bson.JS_INT_MIN;
          var bson_7 = bson.BSON_DATA_NUMBER;
          var bson_8 = bson.BSON_DATA_STRING;
          var bson_9 = bson.BSON_DATA_OBJECT;
          var bson_10 = bson.BSON_DATA_ARRAY;
          var bson_11 = bson.BSON_DATA_BINARY;
          var bson_12 = bson.BSON_DATA_UNDEFINED;
          var bson_13 = bson.BSON_DATA_OID;
          var bson_14 = bson.BSON_DATA_BOOLEAN;
          var bson_15 = bson.BSON_DATA_DATE;
          var bson_16 = bson.BSON_DATA_NULL;
          var bson_17 = bson.BSON_DATA_REGEXP;
          var bson_18 = bson.BSON_DATA_DBPOINTER;
          var bson_19 = bson.BSON_DATA_CODE;
          var bson_20 = bson.BSON_DATA_SYMBOL;
          var bson_21 = bson.BSON_DATA_CODE_W_SCOPE;
          var bson_22 = bson.BSON_DATA_INT;
          var bson_23 = bson.BSON_DATA_TIMESTAMP;
          var bson_24 = bson.BSON_DATA_LONG;
          var bson_25 = bson.BSON_DATA_DECIMAL128;
          var bson_26 = bson.BSON_DATA_MIN_KEY;
          var bson_27 = bson.BSON_DATA_MAX_KEY;
          var bson_28 = bson.BSON_BINARY_SUBTYPE_DEFAULT;
          var bson_29 = bson.BSON_BINARY_SUBTYPE_FUNCTION;
          var bson_30 = bson.BSON_BINARY_SUBTYPE_BYTE_ARRAY;
          var bson_31 = bson.BSON_BINARY_SUBTYPE_UUID;
          var bson_32 = bson.BSON_BINARY_SUBTYPE_MD5;
          var bson_33 = bson.BSON_BINARY_SUBTYPE_USER_DEFINED;
          var bson_34 = bson.Code;
          var bson_35 = bson.BSONSymbol;
          var bson_36 = bson.DBRef;
          var bson_37 = bson.Binary;
          var bson_38 = bson.ObjectId;
          var bson_39 = bson.Long;
          var bson_40 = bson.Timestamp;
          var bson_41 = bson.Double;
          var bson_42 = bson.Int32;
          var bson_43 = bson.MinKey;
          var bson_44 = bson.MaxKey;
          var bson_45 = bson.BSONRegExp;
          var bson_46 = bson.Decimal128;
          var bson_47 = bson.serialize;
          var bson_48 = bson.serializeWithBufferAndIndex;
          var bson_49 = bson.deserialize;
          var bson_50 = bson.calculateObjectSize;
          var bson_51 = bson.deserializeStream;
          var bson_52 = bson.setInternalBufferSize;
          var bson_53 = bson.ObjectID;
          var bson_54 = bson.EJSON;
          exports["default"] = bson;
          exports.BSON_INT32_MAX = bson_1;
          exports.BSON_INT32_MIN = bson_2;
          exports.BSON_INT64_MAX = bson_3;
          exports.BSON_INT64_MIN = bson_4;
          exports.JS_INT_MAX = bson_5;
          exports.JS_INT_MIN = bson_6;
          exports.BSON_DATA_NUMBER = bson_7;
          exports.BSON_DATA_STRING = bson_8;
          exports.BSON_DATA_OBJECT = bson_9;
          exports.BSON_DATA_ARRAY = bson_10;
          exports.BSON_DATA_BINARY = bson_11;
          exports.BSON_DATA_UNDEFINED = bson_12;
          exports.BSON_DATA_OID = bson_13;
          exports.BSON_DATA_BOOLEAN = bson_14;
          exports.BSON_DATA_DATE = bson_15;
          exports.BSON_DATA_NULL = bson_16;
          exports.BSON_DATA_REGEXP = bson_17;
          exports.BSON_DATA_DBPOINTER = bson_18;
          exports.BSON_DATA_CODE = bson_19;
          exports.BSON_DATA_SYMBOL = bson_20;
          exports.BSON_DATA_CODE_W_SCOPE = bson_21;
          exports.BSON_DATA_INT = bson_22;
          exports.BSON_DATA_TIMESTAMP = bson_23;
          exports.BSON_DATA_LONG = bson_24;
          exports.BSON_DATA_DECIMAL128 = bson_25;
          exports.BSON_DATA_MIN_KEY = bson_26;
          exports.BSON_DATA_MAX_KEY = bson_27;
          exports.BSON_BINARY_SUBTYPE_DEFAULT = bson_28;
          exports.BSON_BINARY_SUBTYPE_FUNCTION = bson_29;
          exports.BSON_BINARY_SUBTYPE_BYTE_ARRAY = bson_30;
          exports.BSON_BINARY_SUBTYPE_UUID = bson_31;
          exports.BSON_BINARY_SUBTYPE_MD5 = bson_32;
          exports.BSON_BINARY_SUBTYPE_USER_DEFINED = bson_33;
          exports.Code = bson_34;
          exports.BSONSymbol = bson_35;
          exports.DBRef = bson_36;
          exports.Binary = bson_37;
          exports.ObjectId = bson_38;
          exports.Long = bson_39;
          exports.Timestamp = bson_40;
          exports.Double = bson_41;
          exports.Int32 = bson_42;
          exports.MinKey = bson_43;
          exports.MaxKey = bson_44;
          exports.BSONRegExp = bson_45;
          exports.Decimal128 = bson_46;
          exports.serialize = bson_47;
          exports.serializeWithBufferAndIndex = bson_48;
          exports.deserialize = bson_49;
          exports.calculateObjectSize = bson_50;
          exports.deserializeStream = bson_51;
          exports.setInternalBufferSize = bson_52;
          exports.ObjectID = bson_53;
          exports.EJSON = bson_54;
          Object.defineProperty(exports, '__esModule', {
            value: true
          });
        });
        /* WEBPACK VAR INJECTION */

      }).call(exports, __webpack_require__(0), __webpack_require__(1).Buffer);
      /***/
    },
    /* 3 */

    /***/
    function (module, exports, __webpack_require__) {

      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
      var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

      for (var i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      } // Support decoding URL-safe base64 strings, as Node.js does.
      // See: https://en.wikipedia.org/wiki/Base64#URL_applications


      revLookup['-'.charCodeAt(0)] = 62;
      revLookup['_'.charCodeAt(0)] = 63;

      function getLens(b64) {
        var len = b64.length;

        if (len % 4 > 0) {
          throw new Error('Invalid string. Length must be a multiple of 4');
        } // Trim off extra bytes after placeholder bytes are found
        // See: https://github.com/beatgammit/base64-js/issues/42


        var validLen = b64.indexOf('=');
        if (validLen === -1) validLen = len;
        var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      } // base64 is 4/3 + up to two characters of the original data


      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }

      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }

      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars

        var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i;

        for (i = 0; i < len; i += 4) {
          tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
          arr[curByte++] = tmp >> 16 & 0xFF;
          arr[curByte++] = tmp >> 8 & 0xFF;
          arr[curByte++] = tmp & 0xFF;
        }

        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
          arr[curByte++] = tmp & 0xFF;
        }

        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 0xFF;
          arr[curByte++] = tmp & 0xFF;
        }

        return arr;
      }

      function tripletToBase64(num) {
        return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
      }

      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];

        for (var i = start; i < end; i += 3) {
          tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
          output.push(tripletToBase64(tmp));
        }

        return output.join('');
      }

      function fromByteArray(uint8) {
        var tmp;
        var len = uint8.length;
        var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

        var parts = [];
        var maxChunkLength = 16383; // must be multiple of 3
        // go through the array every three bytes, we'll deal with trailing stuff later

        for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
          parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
        } // pad the end with zeros, but make sure to not forget the extra bytes


        if (extraBytes === 1) {
          tmp = uint8[len - 1];
          parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
        } else if (extraBytes === 2) {
          tmp = (uint8[len - 2] << 8) + uint8[len - 1];
          parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
        }

        return parts.join('');
      }
      /***/

    },
    /* 4 */

    /***/
    function (module, exports) {
      exports.read = function (buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset + i];
        i += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;

        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;

        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }

        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      };

      exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);

        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);

          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }

          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }

          if (value * c >= 2) {
            e++;
            c /= 2;
          }

          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }

        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

        e = e << mLen | m;
        eLen += mLen;

        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

        buffer[offset + i - d] |= s * 128;
      };
      /***/

    },
    /* 5 */

    /***/
    function (module, exports) {
      var toString = {}.toString;

      module.exports = Array.isArray || function (arr) {
        return toString.call(arr) == '[object Array]';
      };
      /***/

    },
    /* 6 */

    /***/
    function (module, exports) {
      module.exports = Long;
      /**
       * wasm optimizations, to do native i64 multiplication and divide
       */

      var wasm = null;

      try {
        wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
      } catch (e) {} // no wasm support :(

      /**
       * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
       *  See the from* functions below for more convenient ways of constructing Longs.
       * @exports Long
       * @class A Long class for representing a 64 bit two's-complement integer value.
       * @param {number} low The low (signed) 32 bits of the long
       * @param {number} high The high (signed) 32 bits of the long
       * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
       * @constructor
       */


      function Long(low, high, unsigned) {
        /**
         * The low 32 bits as a signed value.
         * @type {number}
         */
        this.low = low | 0;
        /**
         * The high 32 bits as a signed value.
         * @type {number}
         */

        this.high = high | 0;
        /**
         * Whether unsigned or not.
         * @type {boolean}
         */

        this.unsigned = !!unsigned;
      } // The internal representation of a long is the two given signed, 32-bit values.
      // We use 32-bit pieces because these are the size of integers on which
      // Javascript performs bit-operations.  For operations like addition and
      // multiplication, we split each number into 16 bit pieces, which can easily be
      // multiplied within Javascript's floating-point representation without overflow
      // or change in sign.
      //
      // In the algorithms below, we frequently reduce the negative case to the
      // positive case by negating the input(s) and then post-processing the result.
      // Note that we must ALWAYS check specially whether those values are MIN_VALUE
      // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
      // a positive number, it overflows back into a negative).  Not handling this
      // case would often result in infinite recursion.
      //
      // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
      // methods on which they depend.

      /**
       * An indicator used to reliably determine if an object is a Long or not.
       * @type {boolean}
       * @const
       * @private
       */


      Long.prototype.__isLong__;
      Object.defineProperty(Long.prototype, "__isLong__", {
        value: true
      });
      /**
       * @function
       * @param {*} obj Object
       * @returns {boolean}
       * @inner
       */

      function isLong(obj) {
        return (obj && obj["__isLong__"]) === true;
      }
      /**
       * Tests if the specified object is a Long.
       * @function
       * @param {*} obj Object
       * @returns {boolean}
       */


      Long.isLong = isLong;
      /**
       * A cache of the Long representations of small integer values.
       * @type {!Object}
       * @inner
       */

      var INT_CACHE = {};
      /**
       * A cache of the Long representations of small unsigned integer values.
       * @type {!Object}
       * @inner
       */

      var UINT_CACHE = {};
      /**
       * @param {number} value
       * @param {boolean=} unsigned
       * @returns {!Long}
       * @inner
       */

      function fromInt(value, unsigned) {
        var obj, cachedObj, cache;

        if (unsigned) {
          value >>>= 0;

          if (cache = 0 <= value && value < 256) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj) return cachedObj;
          }

          obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
          if (cache) UINT_CACHE[value] = obj;
          return obj;
        } else {
          value |= 0;

          if (cache = -128 <= value && value < 128) {
            cachedObj = INT_CACHE[value];
            if (cachedObj) return cachedObj;
          }

          obj = fromBits(value, value < 0 ? -1 : 0, false);
          if (cache) INT_CACHE[value] = obj;
          return obj;
        }
      }
      /**
       * Returns a Long representing the given 32 bit integer value.
       * @function
       * @param {number} value The 32 bit integer in question
       * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
       * @returns {!Long} The corresponding Long value
       */


      Long.fromInt = fromInt;
      /**
       * @param {number} value
       * @param {boolean=} unsigned
       * @returns {!Long}
       * @inner
       */

      function fromNumber(value, unsigned) {
        if (isNaN(value)) return unsigned ? UZERO : ZERO;

        if (unsigned) {
          if (value < 0) return UZERO;
          if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
        } else {
          if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;
          if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;
        }

        if (value < 0) return fromNumber(-value, unsigned).neg();
        return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
      }
      /**
       * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
       * @function
       * @param {number} value The number in question
       * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
       * @returns {!Long} The corresponding Long value
       */


      Long.fromNumber = fromNumber;
      /**
       * @param {number} lowBits
       * @param {number} highBits
       * @param {boolean=} unsigned
       * @returns {!Long}
       * @inner
       */

      function fromBits(lowBits, highBits, unsigned) {
        return new Long(lowBits, highBits, unsigned);
      }
      /**
       * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
       *  assumed to use 32 bits.
       * @function
       * @param {number} lowBits The low 32 bits
       * @param {number} highBits The high 32 bits
       * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
       * @returns {!Long} The corresponding Long value
       */


      Long.fromBits = fromBits;
      /**
       * @function
       * @param {number} base
       * @param {number} exponent
       * @returns {number}
       * @inner
       */

      var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

      /**
       * @param {string} str
       * @param {(boolean|number)=} unsigned
       * @param {number=} radix
       * @returns {!Long}
       * @inner
       */

      function fromString(str, unsigned, radix) {
        if (str.length === 0) throw Error('empty string');
        if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity") return ZERO;

        if (typeof unsigned === 'number') {
          // For goog.math.long compatibility
          radix = unsigned, unsigned = false;
        } else {
          unsigned = !!unsigned;
        }

        radix = radix || 10;
        if (radix < 2 || 36 < radix) throw RangeError('radix');
        var p;
        if ((p = str.indexOf('-')) > 0) throw Error('interior hyphen');else if (p === 0) {
          return fromString(str.substring(1), unsigned, radix).neg();
        } // Do several (8) digits each time through the loop, so as to
        // minimize the calls to the very expensive emulated div.

        var radixToPower = fromNumber(pow_dbl(radix, 8));
        var result = ZERO;

        for (var i = 0; i < str.length; i += 8) {
          var size = Math.min(8, str.length - i),
              value = parseInt(str.substring(i, i + size), radix);

          if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
          } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
          }
        }

        result.unsigned = unsigned;
        return result;
      }
      /**
       * Returns a Long representation of the given string, written using the specified radix.
       * @function
       * @param {string} str The textual representation of the Long
       * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
       * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
       * @returns {!Long} The corresponding Long value
       */


      Long.fromString = fromString;
      /**
       * @function
       * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
       * @param {boolean=} unsigned
       * @returns {!Long}
       * @inner
       */

      function fromValue(val, unsigned) {
        if (typeof val === 'number') return fromNumber(val, unsigned);
        if (typeof val === 'string') return fromString(val, unsigned); // Throws for non-objects, converts non-instanceof Long:

        return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
      }
      /**
       * Converts the specified value to a Long using the appropriate from* function for its type.
       * @function
       * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
       * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
       * @returns {!Long}
       */


      Long.fromValue = fromValue; // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
      // no runtime penalty for these.

      /**
       * @type {number}
       * @const
       * @inner
       */

      var TWO_PWR_16_DBL = 1 << 16;
      /**
       * @type {number}
       * @const
       * @inner
       */

      var TWO_PWR_24_DBL = 1 << 24;
      /**
       * @type {number}
       * @const
       * @inner
       */

      var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
      /**
       * @type {number}
       * @const
       * @inner
       */

      var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
      /**
       * @type {number}
       * @const
       * @inner
       */

      var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
      /**
       * @type {!Long}
       * @const
       * @inner
       */

      var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
      /**
       * @type {!Long}
       * @inner
       */

      var ZERO = fromInt(0);
      /**
       * Signed zero.
       * @type {!Long}
       */

      Long.ZERO = ZERO;
      /**
       * @type {!Long}
       * @inner
       */

      var UZERO = fromInt(0, true);
      /**
       * Unsigned zero.
       * @type {!Long}
       */

      Long.UZERO = UZERO;
      /**
       * @type {!Long}
       * @inner
       */

      var ONE = fromInt(1);
      /**
       * Signed one.
       * @type {!Long}
       */

      Long.ONE = ONE;
      /**
       * @type {!Long}
       * @inner
       */

      var UONE = fromInt(1, true);
      /**
       * Unsigned one.
       * @type {!Long}
       */

      Long.UONE = UONE;
      /**
       * @type {!Long}
       * @inner
       */

      var NEG_ONE = fromInt(-1);
      /**
       * Signed negative one.
       * @type {!Long}
       */

      Long.NEG_ONE = NEG_ONE;
      /**
       * @type {!Long}
       * @inner
       */

      var MAX_VALUE = fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);
      /**
       * Maximum signed value.
       * @type {!Long}
       */

      Long.MAX_VALUE = MAX_VALUE;
      /**
       * @type {!Long}
       * @inner
       */

      var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);
      /**
       * Maximum unsigned value.
       * @type {!Long}
       */

      Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
      /**
       * @type {!Long}
       * @inner
       */

      var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);
      /**
       * Minimum signed value.
       * @type {!Long}
       */

      Long.MIN_VALUE = MIN_VALUE;
      /**
       * @alias Long.prototype
       * @inner
       */

      var LongPrototype = Long.prototype;
      /**
       * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
       * @returns {number}
       */

      LongPrototype.toInt = function toInt() {
        return this.unsigned ? this.low >>> 0 : this.low;
      };
      /**
       * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
       * @returns {number}
       */


      LongPrototype.toNumber = function toNumber() {
        if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
      };
      /**
       * Converts the Long to a string written in the specified radix.
       * @param {number=} radix Radix (2-36), defaults to 10
       * @returns {string}
       * @override
       * @throws {RangeError} If `radix` is out of range
       */


      LongPrototype.toString = function toString(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix) throw RangeError('radix');
        if (this.isZero()) return '0';

        if (this.isNegative()) {
          // Unsigned Longs are never negative
          if (this.eq(MIN_VALUE)) {
            // We need to change the Long value before it can be negated, so we remove
            // the bottom-most digit in this base and then recurse to do the rest.
            var radixLong = fromNumber(radix),
                div = this.div(radixLong),
                rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
          } else return '-' + this.neg().toString(radix);
        } // Do several (6) digits each time through the loop, so as to
        // minimize the calls to the very expensive emulated div.


        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
            rem = this;
        var result = '';

        while (true) {
          var remDiv = rem.div(radixToPower),
              intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
              digits = intval.toString(radix);
          rem = remDiv;
          if (rem.isZero()) return digits + result;else {
            while (digits.length < 6) {
              digits = '0' + digits;
            }

            result = '' + digits + result;
          }
        }
      };
      /**
       * Gets the high 32 bits as a signed integer.
       * @returns {number} Signed high bits
       */


      LongPrototype.getHighBits = function getHighBits() {
        return this.high;
      };
      /**
       * Gets the high 32 bits as an unsigned integer.
       * @returns {number} Unsigned high bits
       */


      LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
        return this.high >>> 0;
      };
      /**
       * Gets the low 32 bits as a signed integer.
       * @returns {number} Signed low bits
       */


      LongPrototype.getLowBits = function getLowBits() {
        return this.low;
      };
      /**
       * Gets the low 32 bits as an unsigned integer.
       * @returns {number} Unsigned low bits
       */


      LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
        return this.low >>> 0;
      };
      /**
       * Gets the number of bits needed to represent the absolute value of this Long.
       * @returns {number}
       */


      LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
        if (this.isNegative()) // Unsigned Longs are never negative
          return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
        var val = this.high != 0 ? this.high : this.low;

        for (var bit = 31; bit > 0; bit--) {
          if ((val & 1 << bit) != 0) break;
        }

        return this.high != 0 ? bit + 33 : bit + 1;
      };
      /**
       * Tests if this Long's value equals zero.
       * @returns {boolean}
       */


      LongPrototype.isZero = function isZero() {
        return this.high === 0 && this.low === 0;
      };
      /**
       * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
       * @returns {boolean}
       */


      LongPrototype.eqz = LongPrototype.isZero;
      /**
       * Tests if this Long's value is negative.
       * @returns {boolean}
       */

      LongPrototype.isNegative = function isNegative() {
        return !this.unsigned && this.high < 0;
      };
      /**
       * Tests if this Long's value is positive.
       * @returns {boolean}
       */


      LongPrototype.isPositive = function isPositive() {
        return this.unsigned || this.high >= 0;
      };
      /**
       * Tests if this Long's value is odd.
       * @returns {boolean}
       */


      LongPrototype.isOdd = function isOdd() {
        return (this.low & 1) === 1;
      };
      /**
       * Tests if this Long's value is even.
       * @returns {boolean}
       */


      LongPrototype.isEven = function isEven() {
        return (this.low & 1) === 0;
      };
      /**
       * Tests if this Long's value equals the specified's.
       * @param {!Long|number|string} other Other value
       * @returns {boolean}
       */


      LongPrototype.equals = function equals(other) {
        if (!isLong(other)) other = fromValue(other);
        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;
        return this.high === other.high && this.low === other.low;
      };
      /**
       * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
       * @function
       * @param {!Long|number|string} other Other value
       * @returns {boolean}
       */


      LongPrototype.eq = LongPrototype.equals;
      /**
       * Tests if this Long's value differs from the specified's.
       * @param {!Long|number|string} other Other value
       * @returns {boolean}
       */

      LongPrototype.notEquals = function notEquals(other) {
        return !this.eq(
        /* validates */
        other);
      };
      /**
       * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
       * @function
       * @param {!Long|number|string} other Other value
       * @returns {boolean}
       */


      LongPrototype.neq = LongPrototype.notEquals;
      /**
       * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
       * @function
       * @param {!Long|number|string} other Other value
       * @returns {boolean}
       */

      LongPrototype.ne = LongPrototype.notEquals;
      /**
       * Tests if this Long's value is less than the specified's.
       * @param {!Long|number|string} other Other value
       * @returns {boolean}
       */

      LongPrototype.lessThan = function lessThan(other) {
        return this.comp(
        /* validates */
        other) < 0;
      };
      /**
       * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
       * @function
       * @param {!Long|number|string} other Other value
       * @returns {boolean}
       */


      LongPrototype.lt = LongPrototype.lessThan;
      /**
       * Tests if this Long's value is less than or equal the specified's.
       * @param {!Long|number|string} other Other value
       * @returns {boolean}
       */

      LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
        return this.comp(
        /* validates */
        other) <= 0;
      };
      /**
       * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
       * @function
       * @param {!Long|number|string} other Other value
       * @returns {boolean}
       */


      LongPrototype.lte = LongPrototype.lessThanOrEqual;
      /**
       * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
       * @function
       * @param {!Long|number|string} other Other value
       * @returns {boolean}
       */

      LongPrototype.le = LongPrototype.lessThanOrEqual;
      /**
       * Tests if this Long's value is greater than the specified's.
       * @param {!Long|number|string} other Other value
       * @returns {boolean}
       */

      LongPrototype.greaterThan = function greaterThan(other) {
        return this.comp(
        /* validates */
        other) > 0;
      };
      /**
       * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
       * @function
       * @param {!Long|number|string} other Other value
       * @returns {boolean}
       */


      LongPrototype.gt = LongPrototype.greaterThan;
      /**
       * Tests if this Long's value is greater than or equal the specified's.
       * @param {!Long|number|string} other Other value
       * @returns {boolean}
       */

      LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
        return this.comp(
        /* validates */
        other) >= 0;
      };
      /**
       * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
       * @function
       * @param {!Long|number|string} other Other value
       * @returns {boolean}
       */


      LongPrototype.gte = LongPrototype.greaterThanOrEqual;
      /**
       * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
       * @function
       * @param {!Long|number|string} other Other value
       * @returns {boolean}
       */

      LongPrototype.ge = LongPrototype.greaterThanOrEqual;
      /**
       * Compares this Long's value with the specified's.
       * @param {!Long|number|string} other Other value
       * @returns {number} 0 if they are the same, 1 if the this is greater and -1
       *  if the given one is greater
       */

      LongPrototype.compare = function compare(other) {
        if (!isLong(other)) other = fromValue(other);
        if (this.eq(other)) return 0;
        var thisNeg = this.isNegative(),
            otherNeg = other.isNegative();
        if (thisNeg && !otherNeg) return -1;
        if (!thisNeg && otherNeg) return 1; // At this point the sign bits are the same

        if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1; // Both are positive if at least one is unsigned

        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
      };
      /**
       * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
       * @function
       * @param {!Long|number|string} other Other value
       * @returns {number} 0 if they are the same, 1 if the this is greater and -1
       *  if the given one is greater
       */


      LongPrototype.comp = LongPrototype.compare;
      /**
       * Negates this Long's value.
       * @returns {!Long} Negated Long
       */

      LongPrototype.negate = function negate() {
        if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;
        return this.not().add(ONE);
      };
      /**
       * Negates this Long's value. This is an alias of {@link Long#negate}.
       * @function
       * @returns {!Long} Negated Long
       */


      LongPrototype.neg = LongPrototype.negate;
      /**
       * Returns the sum of this and the specified Long.
       * @param {!Long|number|string} addend Addend
       * @returns {!Long} Sum
       */

      LongPrototype.add = function add(addend) {
        if (!isLong(addend)) addend = fromValue(addend); // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;
        var b48 = addend.high >>> 16;
        var b32 = addend.high & 0xFFFF;
        var b16 = addend.low >>> 16;
        var b00 = addend.low & 0xFFFF;
        var c48 = 0,
            c32 = 0,
            c16 = 0,
            c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 + b48;
        c48 &= 0xFFFF;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      /**
       * Returns the difference of this and the specified Long.
       * @param {!Long|number|string} subtrahend Subtrahend
       * @returns {!Long} Difference
       */


      LongPrototype.subtract = function subtract(subtrahend) {
        if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);
        return this.add(subtrahend.neg());
      };
      /**
       * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
       * @function
       * @param {!Long|number|string} subtrahend Subtrahend
       * @returns {!Long} Difference
       */


      LongPrototype.sub = LongPrototype.subtract;
      /**
       * Returns the product of this and the specified Long.
       * @param {!Long|number|string} multiplier Multiplier
       * @returns {!Long} Product
       */

      LongPrototype.multiply = function multiply(multiplier) {
        if (this.isZero()) return ZERO;
        if (!isLong(multiplier)) multiplier = fromValue(multiplier); // use wasm support if present

        if (wasm) {
          var low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);
          return fromBits(low, wasm.get_high(), this.unsigned);
        }

        if (multiplier.isZero()) return ZERO;
        if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;
        if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;

        if (this.isNegative()) {
          if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());else return this.neg().mul(multiplier).neg();
        } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg(); // If both longs are small, use float multiplication


        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24)) return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned); // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
        // We can skip products that would overflow.

        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;
        var b48 = multiplier.high >>> 16;
        var b32 = multiplier.high & 0xFFFF;
        var b16 = multiplier.low >>> 16;
        var b00 = multiplier.low & 0xFFFF;
        var c48 = 0,
            c32 = 0,
            c16 = 0,
            c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 0xFFFF;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      /**
       * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
       * @function
       * @param {!Long|number|string} multiplier Multiplier
       * @returns {!Long} Product
       */


      LongPrototype.mul = LongPrototype.multiply;
      /**
       * Returns this Long divided by the specified. The result is signed if this Long is signed or
       *  unsigned if this Long is unsigned.
       * @param {!Long|number|string} divisor Divisor
       * @returns {!Long} Quotient
       */

      LongPrototype.divide = function divide(divisor) {
        if (!isLong(divisor)) divisor = fromValue(divisor);
        if (divisor.isZero()) throw Error('division by zero'); // use wasm support if present

        if (wasm) {
          // guard against signed division overflow: the largest
          // negative number / -1 would be 1 larger than the largest
          // positive number, due to two's complement.
          if (!this.unsigned && this.high === -0x80000000 && divisor.low === -1 && divisor.high === -1) {
            // be consistent with non-wasm code path
            return this;
          }

          var low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);
          return fromBits(low, wasm.get_high(), this.unsigned);
        }

        if (this.isZero()) return this.unsigned ? UZERO : ZERO;
        var approx, rem, res;

        if (!this.unsigned) {
          // This section is only relevant for signed longs and is derived from the
          // closure library as a whole.
          if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE)) return MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.eq(MIN_VALUE)) return ONE;else {
                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);

                if (approx.eq(ZERO)) {
                  return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                  rem = this.sub(divisor.mul(approx));
                  res = approx.add(rem.div(divisor));
                  return res;
                }
              }
          } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;

          if (this.isNegative()) {
            if (divisor.isNegative()) return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
          } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();

          res = ZERO;
        } else {
          // The algorithm below has not been made for unsigned longs. It's therefore
          // required to take special care of the MSB prior to running it.
          if (!divisor.unsigned) divisor = divisor.toUnsigned();
          if (divisor.gt(this)) return UZERO;
          if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
            return UONE;
          res = UZERO;
        } // Repeat the following until the remainder is less than other:  find a
        // floating-point that approximates remainder / other *from below*, add this
        // into the result, and subtract it from the remainder.  It is critical that
        // the approximate value is less than or equal to the real value so that the
        // remainder never becomes negative.


        rem = this;

        while (rem.gte(divisor)) {
          // Approximate the result of division. This may be a little greater or
          // smaller than the actual value.
          approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber())); // We will tweak the approximate result by changing it in the 48-th digit or
          // the smallest non-fractional digit, whichever is larger.

          var log2 = Math.ceil(Math.log(approx) / Math.LN2),
              delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48),
              // Decrease the approximation until it is smaller than the remainder.  Note
          // that if it is too large, the product overflows and is negative.
          approxRes = fromNumber(approx),
              approxRem = approxRes.mul(divisor);

          while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
          } // We know the answer can't be zero... and actually, zero would cause
          // infinite recursion since we would make no progress.


          if (approxRes.isZero()) approxRes = ONE;
          res = res.add(approxRes);
          rem = rem.sub(approxRem);
        }

        return res;
      };
      /**
       * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
       * @function
       * @param {!Long|number|string} divisor Divisor
       * @returns {!Long} Quotient
       */


      LongPrototype.div = LongPrototype.divide;
      /**
       * Returns this Long modulo the specified.
       * @param {!Long|number|string} divisor Divisor
       * @returns {!Long} Remainder
       */

      LongPrototype.modulo = function modulo(divisor) {
        if (!isLong(divisor)) divisor = fromValue(divisor); // use wasm support if present

        if (wasm) {
          var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);
          return fromBits(low, wasm.get_high(), this.unsigned);
        }

        return this.sub(this.div(divisor).mul(divisor));
      };
      /**
       * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
       * @function
       * @param {!Long|number|string} divisor Divisor
       * @returns {!Long} Remainder
       */


      LongPrototype.mod = LongPrototype.modulo;
      /**
       * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
       * @function
       * @param {!Long|number|string} divisor Divisor
       * @returns {!Long} Remainder
       */

      LongPrototype.rem = LongPrototype.modulo;
      /**
       * Returns the bitwise NOT of this Long.
       * @returns {!Long}
       */

      LongPrototype.not = function not() {
        return fromBits(~this.low, ~this.high, this.unsigned);
      };
      /**
       * Returns the bitwise AND of this Long and the specified.
       * @param {!Long|number|string} other Other Long
       * @returns {!Long}
       */


      LongPrototype.and = function and(other) {
        if (!isLong(other)) other = fromValue(other);
        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
      };
      /**
       * Returns the bitwise OR of this Long and the specified.
       * @param {!Long|number|string} other Other Long
       * @returns {!Long}
       */


      LongPrototype.or = function or(other) {
        if (!isLong(other)) other = fromValue(other);
        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
      };
      /**
       * Returns the bitwise XOR of this Long and the given one.
       * @param {!Long|number|string} other Other Long
       * @returns {!Long}
       */


      LongPrototype.xor = function xor(other) {
        if (!isLong(other)) other = fromValue(other);
        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
      };
      /**
       * Returns this Long with bits shifted to the left by the given amount.
       * @param {number|!Long} numBits Number of bits
       * @returns {!Long} Shifted Long
       */


      LongPrototype.shiftLeft = function shiftLeft(numBits) {
        if (isLong(numBits)) numBits = numBits.toInt();
        if ((numBits &= 63) === 0) return this;else if (numBits < 32) return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);else return fromBits(0, this.low << numBits - 32, this.unsigned);
      };
      /**
       * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
       * @function
       * @param {number|!Long} numBits Number of bits
       * @returns {!Long} Shifted Long
       */


      LongPrototype.shl = LongPrototype.shiftLeft;
      /**
       * Returns this Long with bits arithmetically shifted to the right by the given amount.
       * @param {number|!Long} numBits Number of bits
       * @returns {!Long} Shifted Long
       */

      LongPrototype.shiftRight = function shiftRight(numBits) {
        if (isLong(numBits)) numBits = numBits.toInt();
        if ((numBits &= 63) === 0) return this;else if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);else return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
      };
      /**
       * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
       * @function
       * @param {number|!Long} numBits Number of bits
       * @returns {!Long} Shifted Long
       */


      LongPrototype.shr = LongPrototype.shiftRight;
      /**
       * Returns this Long with bits logically shifted to the right by the given amount.
       * @param {number|!Long} numBits Number of bits
       * @returns {!Long} Shifted Long
       */

      LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
        if (isLong(numBits)) numBits = numBits.toInt();
        numBits &= 63;
        if (numBits === 0) return this;else {
          var high = this.high;

          if (numBits < 32) {
            var low = this.low;
            return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
          } else if (numBits === 32) return fromBits(high, 0, this.unsigned);else return fromBits(high >>> numBits - 32, 0, this.unsigned);
        }
      };
      /**
       * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
       * @function
       * @param {number|!Long} numBits Number of bits
       * @returns {!Long} Shifted Long
       */


      LongPrototype.shru = LongPrototype.shiftRightUnsigned;
      /**
       * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
       * @function
       * @param {number|!Long} numBits Number of bits
       * @returns {!Long} Shifted Long
       */

      LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
      /**
       * Converts this Long to signed.
       * @returns {!Long} Signed long
       */

      LongPrototype.toSigned = function toSigned() {
        if (!this.unsigned) return this;
        return fromBits(this.low, this.high, false);
      };
      /**
       * Converts this Long to unsigned.
       * @returns {!Long} Unsigned long
       */


      LongPrototype.toUnsigned = function toUnsigned() {
        if (this.unsigned) return this;
        return fromBits(this.low, this.high, true);
      };
      /**
       * Converts this Long to its byte representation.
       * @param {boolean=} le Whether little or big endian, defaults to big endian
       * @returns {!Array.<number>} Byte representation
       */


      LongPrototype.toBytes = function toBytes(le) {
        return le ? this.toBytesLE() : this.toBytesBE();
      };
      /**
       * Converts this Long to its little endian byte representation.
       * @returns {!Array.<number>} Little endian byte representation
       */


      LongPrototype.toBytesLE = function toBytesLE() {
        var hi = this.high,
            lo = this.low;
        return [lo & 0xff, lo >>> 8 & 0xff, lo >>> 16 & 0xff, lo >>> 24, hi & 0xff, hi >>> 8 & 0xff, hi >>> 16 & 0xff, hi >>> 24];
      };
      /**
       * Converts this Long to its big endian byte representation.
       * @returns {!Array.<number>} Big endian byte representation
       */


      LongPrototype.toBytesBE = function toBytesBE() {
        var hi = this.high,
            lo = this.low;
        return [hi >>> 24, hi >>> 16 & 0xff, hi >>> 8 & 0xff, hi & 0xff, lo >>> 24, lo >>> 16 & 0xff, lo >>> 8 & 0xff, lo & 0xff];
      };
      /**
       * Creates a Long from its byte representation.
       * @param {!Array.<number>} bytes Byte representation
       * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
       * @param {boolean=} le Whether little or big endian, defaults to big endian
       * @returns {Long} The corresponding Long value
       */


      Long.fromBytes = function fromBytes(bytes, unsigned, le) {
        return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
      };
      /**
       * Creates a Long from its little endian byte representation.
       * @param {!Array.<number>} bytes Little endian byte representation
       * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
       * @returns {Long} The corresponding Long value
       */


      Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
        return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
      };
      /**
       * Creates a Long from its big endian byte representation.
       * @param {!Array.<number>} bytes Big endian byte representation
       * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
       * @returns {Long} The corresponding Long value
       */


      Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
        return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
      };
      /***/

    }
    /******/
    ]);
  });
  var BSON = unwrapExports(bson_common);

  var bson = BSON.bson;
  console.log({
    BSON: BSON
  }, bson);

  var Bson =
  /*#__PURE__*/
  function () {
    function Bson() {
      _classCallCheck(this, Bson);
    }

    _createClass(Bson, null, [{
      key: "serialize",

      /**
       * Serialize a Javascript object.
       * 
       * @param object The Javascript object to serialize.
       * @param options Serialize options.
       * @return The Buffer object containing the serialized object.
       */
      value: function serialize(object, options) {
        return bson.serialize(object, options);
      }
      /**
       * Deserialize data as BSON.
       * 
       * @param buffer The buffer containing the serialized set of BSON documents.
       * @param options Deserialize options.
       * @returns The deserialized Javascript Object.
       */

    }, {
      key: "deserialize",
      value: function deserialize(object, options) {
        return bson.deserialize(object, options);
      }
    }]);

    return Bson;
  }();

  /**
   * @typedef {Object} SdlPacket
   * @property {number} EXTRA_PARCEL_DATA_LENGTH
   * @property {number} HEADER_SIZE
   * @property {number} HEADER_SIZE_V1
   * @property {number} ENCRYPTION_MASK
   * @property {number} SERVICE_TYPE_CONTROL
   * @property {number} SERVICE_TYPE_RPC
   * @property {number} SERVICE_TYPE_PCM
   * @property {number} SERVICE_TYPE_VIDEO
   * @property {number} SERVICE_TYPE_BULK_DATA
   * @property {number} FRAME_INFO_HEART_BEAT
   * @property {number} FRAME_INFO_START_SERVICE
   * @property {number} FRAME_INFO_START_SERVICE_ACK
   * @property {number} FRAME_INFO_START_SERVICE_NAK
   * @property {number} FRAME_INFO_END_SERVICE
   * @property {number} FRAME_INFO_END_SERVICE_ACK
   * @property {number} FRAME_INFO_END_SERVICE_NAK
   * @property {number} FRAME_INFO_REGISTER_SECONDARY_TRANSPORT
   * @property {number} FRAME_INFO_REGISTER_SECONDARY_TRANSPORT_ACK
   * @property {number} FRAME_INFO_REGISTER_SECONDARY_TRANSPORT_NAK
   * @property {number} FRAME_INFO_TRANSPORT_EVENT_UPDATE
   * @property {number} FRAME_INFO_SERVICE_DATA_ACK
   * @property {number} FRAME_INFO_HEART_BEAT_ACK
   * @property {number} FRAME_INFO_FINAL_CONNESCUTIVE_FRAME
   * @property {number} FRAME_INFO_RESERVED

   * @property {function} getVersion
   * @property {function} getEncryption
   * @property {function} getServiceType
   * @property {function} getFrameInfo
   * @property {function} getSessionID
   * @property {function} getMessageID
   * @property {function} getDataSize
   * @property {function} setPayload
   * @property {function} getPayload
   * @property {function} getEncryptionBit
   * @property {function} getFrameType
   * @property {function} toUint8Array
   * @property {function} toString
   * @property {function} constructPacket
   * @property {function} putTag
   * @property {function} getTag
   */

  var SdlPacket =
  /*#__PURE__*/
  function () {
    /**
    * @constructor
    * @param {Number} version - Protocol version to use
    * @param {Boolean} encryption - Whether or not the payload in this packet is encrypted
    * @param {FrameType} frameType - A number representing the packet frame type
    * @param {ServiceType} serviceType - The service that this packet is associated with
    * @param {Number} frameInfo - Specific frame info related to this packet
    * @param {Number} sessionID - ID this packet is associated with
    * @param {Number} dataSize - Size of the payload that will be added
    * @param {Number} messageID - ID of this specific packet
    * @param {Uint8Array} payload - Raw data that will be attached to the packet (RPC message, raw bytes, etc)
    * @param {Number} offset
    * @param {Number} bytesToWrite
    */
    function SdlPacket() {
      var version = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var encryption = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var frameType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
      var serviceType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;
      var frameInfo = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : -1;
      var sessionId = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
      var dataSize = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
      var messageId = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
      var payload = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;
      var offset = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;
      var bytesToWrite = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 0;

      _classCallCheck(this, SdlPacket);

      this._version = version;
      this._encryption = encryption;
      this._frameType = frameType;
      this._serviceType = serviceType;
      this._frameInfo = frameInfo;
      this._sessionId = sessionId;
      this._dataSize = dataSize;
      this._messageId = messageId;
      this._payload = payload;
      this._offset = offset;
      this._bytesToWrite = bytesToWrite;
      this._bsonPayload = undefined;

      if (payload !== null) {
        this._payload = new Uint8Array(payload.slice(offset, bytesToWrite + offset));
      }

      return this;
    }
    /**
    * @return {Number} - Protocol version used by this packet
    */


    _createClass(SdlPacket, [{
      key: "getVersion",
      value: function getVersion() {
        return this._version;
      }
      /**
      * @return {Boolean} - Whether or not the payload in this packet is encrypted
      */

    }, {
      key: "getEncryption",
      value: function getEncryption() {
        return this._encryption;
      }
      /**
      * @return {ServiceType} - The service that this packet is associated with
      */

    }, {
      key: "getServiceType",
      value: function getServiceType() {
        return this._serviceType;
      }
      /**
      * @return {Number} - Specific frame info related to this packet
      */

    }, {
      key: "getFrameInfo",
      value: function getFrameInfo() {
        return this._frameInfo;
      }
      /**
      * @return {Number} - ID this packet is associated with
      */

    }, {
      key: "getSessionId",
      value: function getSessionId() {
        return this._sessionId;
      }
      /**
      * @return {Number} - ID of this specific packet
      */

    }, {
      key: "getMessageId",
      value: function getMessageId() {
        return this._messageId;
      }
      /**
      * @return {Number} - Size of the payload that will be added
      */

    }, {
      key: "getDataSize",
      value: function getDataSize() {
        return this._dataSize;
      }
      /**
      * @return {Uint8Array} payload - Raw data that will be attached to the packet (RPC message, raw bytes, etc)
      */

    }, {
      key: "setPayload",
      value: function setPayload(payload) {
        this._payload = payload;
      }
      /**
      * @return {Uint8Array} - Raw data that will be attached to the packet (RPC message, raw bytes, etc)
      */

    }, {
      key: "getPayload",
      value: function getPayload() {
        return this._payload;
      }
      /**
      * @return {Number} - Returns a number representing a byte mask depending on the boolean value
      */

    }, {
      key: "getEncryptionBit",
      value: function getEncryptionBit() {
        return SdlPacket.getEncryptionBit(this._encryption);
      }
      /**
       * 
       * @param {Boolean} encryption 
       * @return {Number} - Returns a number representing a byte mask depending on the boolean value
       */

    }, {
      key: "getFrameType",

      /**
      * @return {FrameType} - A number representing the packet frame type
      */
      value: function getFrameType() {
        return this._frameType;
      }
      /**
      * @return {String} - String representation of the packet
      */

    }, {
      key: "toString",
      value: function toString() {
        var output = '***** Sdl Packet *****';
        output += "\nVersion: ".concat(this._version);
        output += "\nEncryption: ".concat(this._encryption);
        output += "\nFrameType: ".concat(this._frameType);
        output += "\nServiceType: ".concat(this._serviceType);
        output += "\nFrameInfo: ".concat(this._frameInfo);
        output += "\nSessionID: ".concat(this._sessionID);
        output += "\nDataSize: ".concat(this._dataSize);

        if (this._version > 1) {
          output += "\nMessageID: ".concat(this._messageID);
        }

        output += '\n***** Sdl Packet End *****';
        return output;
      }
      /**
      * This method takes in the various components to the SDL packet structure and creates a new byte array that can be sent via the transport
       * @param {Number} version - Protocol version to use
       * @param {Boolean} encryption - Whether or not the payload in this packet is encrypted
       * @param {FrameType} frameType - A number representing the packet frame type
       * @param {ServiceType} serviceType - The service that this packet is associated with
       * @param {Number} controlFrameInfo - Specific frame info related to this packet
       * @param {Number} sessionID - ID this packet is associated with
       * @param {Number} dataSize - Size of the payload that will be added
       * @param {Number} messageID - ID of this specific packet
       * @param {Uint8Array} payload - Raw data that will be attached to the packet (RPC message, raw bytes, etc)
      * @return {Uint8Array} - A byte[] representation of an SdlPacket built using the supplied params
      */

    }, {
      key: "constructPacket",

      /**
      * This method takes in the various components to the SDL packet structure and creates a new byte array that can be sent via the transport
       * @param {Number} version - Protocol version to use
       * @param {Boolean} encryption - Whether or not the payload in this packet is encrypted
       * @param {FrameType} frameType - A number representing the packet frame type
       * @param {ServiceType} serviceType - The service that this packet is associated with
       * @param {Number} controlFrameInfo - Specific frame info related to this packet
       * @param {Number} sessionID - ID this packet is associated with
       * @param {Number} dataSize - Size of the payload that will be added
       * @param {Number} messageID - ID of this specific packet
       * @param {Uint8Array} payload - Raw data that will be attached to the packet (RPC message, raw bytes, etc)
      * @return {Uint8Array} - A byte[] representation of an SdlPacket built using the supplied params
      */
      value: function constructPacket() {
        if (this._bsonPayload) {
          this._payload = Bson.serialize(this._bsonPayload);
          this._dataSize = this._payload.length;
        }

        return this.constructor.constructPacket(this._version, this._encryption, this._frameType, this._serviceType, this._frameInfo, this._sessionId, this._dataSize, this._messageId, this._payload);
      }
      /**
       * @param {String} tag - String key to add as a property to the BSON map
       * @param {Object} data - Object to add as a value to the BSON map
       */

    }, {
      key: "putTag",
      value: function putTag(tag, data) {
        if (!this._bsonPayload) {
          this._bsonPayload = {};
        }

        this._bsonPayload[tag] = data;
      }
      /**
       * @param {String} tag - String key to add as a property to the BSON map
       * @return {Object} data - Object as a value found from the the BSON map
       */

    }, {
      key: "getTag",
      value: function getTag(tag) {
        if (!this._bsonPayload) {
          if (!this._payload) {
            return null;
          }

          this._bsonPayload = Bson.deserialize(this._payload);
          return this._bsonPayload[tag];
        }

        return null;
      }
    }], [{
      key: "getEncryptionBit",
      value: function getEncryptionBit(encryption) {
        return encryption ? SdlPacket.ENCRYPTION_MASK : 0;
      }
    }, {
      key: "constructPacket",
      value: function constructPacket(version, encryption, frameType, serviceType, controlFrameInfo, sessionId, dataSize, messageId, payload) {
        var dataView = null;
        var dataViewIndex = 0;

        if (version > 1) {
          dataView = new Uint8Array(SdlPacket.HEADER_SIZE + dataSize);
        } else {
          dataView = new Uint8Array(SdlPacket.HEADER_SIZE_V1 + dataSize);
        }

        dataView[dataViewIndex++] = (version << 4) + this.getEncryptionBit(encryption) + frameType;
        dataView[dataViewIndex++] = serviceType;
        dataView[dataViewIndex++] = controlFrameInfo;
        dataView[dataViewIndex++] = sessionId;
        dataView[dataViewIndex++] = (dataSize & 0xFF000000) >> 24;
        dataView[dataViewIndex++] = (dataSize & 0x00FF0000) >> 16;
        dataView[dataViewIndex++] = (dataSize & 0x0000FF00) >> 8;
        dataView[dataViewIndex++] = dataSize & 0x000000FF;

        if (version > 1) {
          dataView[dataViewIndex++] = (messageId & 0xFF000000) >> 24;
          dataView[dataViewIndex++] = (messageId & 0x00FF0000) >> 16;
          dataView[dataViewIndex++] = (messageId & 0x0000FF00) >> 8;
          dataView[dataViewIndex++] = messageId & 0x000000FF;
        }

        if (payload !== null && payload.length > 0) {
          dataView.set(payload, dataViewIndex);
        }

        return dataView;
      }
    }]);

    return SdlPacket;
  }();

  SdlPacket.EXTRA_PARCEL_DATA_LENGTH = 24;
  SdlPacket.HEADER_SIZE = 12;
  SdlPacket.HEADER_SIZE_V1 = 8;
  SdlPacket.ENCRYPTION_MASK = 0x08;
  /**
   * Service Type
   */

  SdlPacket.SERVICE_TYPE_CONTROL = 0x00; // RESERVED 0x01 - 0x06

  SdlPacket.SERVICE_TYPE_RPC = 0x07; // RESERVED 0x08 - 0x09

  SdlPacket.SERVICE_TYPE_PCM = 0x0A;
  SdlPacket.SERVICE_TYPE_VIDEO = 0x0B; // RESERVED 0x0C - 0x0E

  SdlPacket.SERVICE_TYPE_BULK_DATA = 0x0F; // RESERVED 0x10 - 0xFF

  /**
   * Frame Info
   */

  SdlPacket.FRAME_INFO_HEART_BEAT = 0x00;
  SdlPacket.FRAME_INFO_START_SERVICE = 0x01;
  SdlPacket.FRAME_INFO_START_SERVICE_ACK = 0x02;
  SdlPacket.FRAME_INFO_START_SERVICE_NAK = 0x03;
  SdlPacket.FRAME_INFO_END_SERVICE = 0x04;
  SdlPacket.FRAME_INFO_END_SERVICE_ACK = 0x05;
  SdlPacket.FRAME_INFO_END_SERVICE_NAK = 0x06;
  SdlPacket.FRAME_INFO_REGISTER_SECONDARY_TRANSPORT = 0x07;
  SdlPacket.FRAME_INFO_REGISTER_SECONDARY_TRANSPORT_ACK = 0x08;
  SdlPacket.FRAME_INFO_REGISTER_SECONDARY_TRANSPORT_NAK = 0x09; // 0x0A-0xFC are reserved

  SdlPacket.FRAME_INFO_TRANSPORT_EVENT_UPDATE = 0xFD;
  SdlPacket.FRAME_INFO_SERVICE_DATA_ACK = 0xFE;
  SdlPacket.FRAME_INFO_HEART_BEAT_ACK = 0xFF;
  SdlPacket.FRAME_INFO_FINAL_CONNESCUTIVE_FRAME = 0x00;
  SdlPacket.FRAME_INFO_RESERVED = 0x00;

  var RpcStruct =
  /*#__PURE__*/
  function () {
    /**
    * @constructor
    */
    function RpcStruct() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, RpcStruct);

      this._isFormatRequested = false;
      this._rpcSpecVersion = null;
      this._parameters = JSON.parse(JSON.stringify(parameters || {}));
    }
    /**
    * @return {Object}
    */


    _createClass(RpcStruct, [{
      key: "getParameters",
      value: function getParameters() {
        return JSON.parse(JSON.stringify(this._parameters));
      }
      /**
      * @param {String} key
      * @return {*}
      */

    }, {
      key: "getParameter",
      value: function getParameter(key) {
        return this._parameters[key];
      }
      /**
      * @param {String} key
      * @param {*} value
      * @return {RpcStruct}
      */

    }, {
      key: "setParameter",
      value: function setParameter(key, value) {
        if (value === null) {
          delete this._parameters[key];
        } else {
          this._parameters[key] = value;
        }

        return this;
      }
      /**
      * @param {Function} tClass
      * @param {String} key
      * @return {Object}
      */

    }, {
      key: "getObject",
      value: function getObject(tClass, key) {
        return this.formatObject(tClass, this.getParameter(key));
      }
      /**
      * @param {Function} tClass
      * @param {Object} obj
      * @return {null|Object}
      */

    }, {
      key: "formatObject",
      value: function formatObject(tClass, obj) {
        if (obj === null) {
          return null;
        } else if (obj.constructor === tClass) {
          // if tClass is String and obj is a String, this should execute
          return obj;
        } else if (obj.constructor === String) {
          if (tClass instanceof Enum) {
            return tClass.valueForString(obj);
          } else if (tClass instanceof String) {
            // this may be redundant
            return obj;
          }

          return null;
        } else if (obj.constructor === Object) {
          if (tClass instanceof RpcStruct) {
            return new tClass(obj);
          }

          return null;
        } else if (obj.constructor === Array) {
          // TODO: ensure completeness
          if (obj.length > 0) {
            var outArray = [];

            for (item in obj) {
              outArray.push(this.formatObject(tclass, item));
            }

            return outArray;
          }
        }

        return null;
      }
      /**
      * @param {Function} tClass
      * @param {Object} obj
      */

    }, {
      key: "validateType",
      value: function validateType(tClass, obj) {
        if (tClass instanceof Enum && tClass.valueForString(obj) === null || obj !== null && obj.constructor !== tClass) {
          throw "".concat(obj.name, " must be of type ").concat(tClass.name);
        }
      }
    }]);

    return RpcStruct;
  }();

  /**
   * @typedef {Object} RpcMessage
   * @property {RpcType} rpcType
   */

  var RpcMessage =
  /*#__PURE__*/
  function (_RpcStruct) {
    _inherits(RpcMessage, _RpcStruct);

    /*
    {
        "rpcType": "Request",
        "functionName": "RegisterAppInterface",
        "coorelationID": "320948",
        "isEncrypted": false,
        "parameters": {
            "appName": "Hello"
        },
        "bulkData": "...",
    }
    */

    /**
    * @constructor
    */
    function RpcMessage() {
      var _this;

      var store = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, RpcMessage);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(RpcMessage).call(this, store.parameters));
      _this._isEncrypted = false;
      _this._rpcType = store.rpcType;
      _this._functionName = store.functionName;
      _this._correlationID = store.correlationID;
      _this._bulkData = _this.setBulkData(store.bulkData);
      return _this;
    }
    /**
    * @return {RpcType}
    */


    _createClass(RpcMessage, [{
      key: "getRPCType",
      value: function getRPCType() {
        return this._rpcType;
      }
      /**
      * @param {RpcType} type
      * @return {RpcMessage}
      */

    }, {
      key: "setRPCType",
      value: function setRPCType(type) {
        this._rpcType = type;
        return this;
      }
      /**
      * @return {String} type
      */

    }, {
      key: "getFunctionName",
      value: function getFunctionName() {
        return this._functionName;
      }
      /**
      * @param {String} name
      * @return {RpcMessage}
      */

    }, {
      key: "setFunctionName",
      value: function setFunctionName(name) {
        this._functionName = name;
        return this;
      }
      /**
      * @return {Uint8Array} data
      */

    }, {
      key: "getBulkData",
      value: function getBulkData() {
        return this._bulkData;
      }
      /**
      * @param {UInt8Array} data
      * @return {RpcMessage}
      */

    }, {
      key: "setBulkData",
      value: function setBulkData() {
        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        if (data !== null) {
          this._bulkData = data.slice(0);
        } else {
          this._bulkData = null;
        }

        return this;
      }
      /**
      * @return {Boolean}
      */

    }, {
      key: "getIsEncrypted",
      value: function getIsEncrypted() {
        return this._isEncrypted;
      }
      /**
      * @param {Boolean} bool
      * @return {RpcMessage}
      */

    }, {
      key: "setIsEncrypted",
      value: function setIsEncrypted(bool) {
        this._isEncrypted = bool;
        return this;
      }
    }]);

    return RpcMessage;
  }(RpcStruct);

  /**
   * @typedef {Enum} ServiceType
   * @property {Object} MAP
   */

  var ServiceType =
  /*#__PURE__*/
  function (_Enum) {
    _inherits(ServiceType, _Enum);

    /**
    * @constructor
    */
    function ServiceType() {
      _classCallCheck(this, ServiceType);

      return _possibleConstructorReturn(this, _getPrototypeOf(ServiceType).call(this));
    }
    /**
    * @return {Number}
    */


    _createClass(ServiceType, null, [{
      key: "valueForString",

      /**
      * Confirms whether the value passed in exists in the Enums of this class
      * @return {null|Number} - Returns null if the enum value doesn't exist
      */
      value: function valueForString(value) {
        for (var key in ServiceType.MAP) {
          if (ServiceType.MAP[key] === value) {
            return ServiceType.MAP[key];
          }
        }

        return null;
      }
    }, {
      key: "CONTROL",
      get: function get() {
        return ServiceType.MAP.CONTROL;
      }
      /**
      * @return {Number}
      */

    }, {
      key: "RPC",
      get: function get() {
        return ServiceType.MAP.RPC;
      }
      /**
      * @return {Number}
      */

    }, {
      key: "AUDIO",
      get: function get() {
        return ServiceType.MAP.AUDIO;
      }
      /**
      * @return {Number}
      */

    }, {
      key: "VIDEO",
      get: function get() {
        return ServiceType.MAP.VIDEO;
      }
      /**
      * @return {Number}
      */

    }, {
      key: "HYBRID",
      get: function get() {
        return ServiceType.MAP.HYBRID;
      }
    }]);

    return ServiceType;
  }(Enum);

  ServiceType.MAP = Object.freeze({
    'CONTROL': 0x00,
    'RPC': 0x07,
    'AUDIO': 0x0A,
    'VIDEO': 0x0B,
    'HYBRID': 0x0F
  });

  /**
   * @typedef {Object} SdlProtocolListener
   * @property {function} setOnRpcMessageReceivedListener
   * @property {function} setOnControlServiceMessageReceivedListener
   * @property {function} setOnDecryptRequestListener
   * @property {function} onControlServiceMessageReceived
   * @property {function} onRpcMessageReceived
   * @property {function} onStartServiceACKReceived
   * @property {function} onStartServiceNAKReceived
   * @property {function} onEndServiceACKReceived
   * @property {function} onEndServiceNAKReceived
   * @property {function} onServiceEncryptionStarted
   */

  var SdlProtocolListener =
  /*#__PURE__*/
  function () {
    /**
     * @constructor 
     */
    function SdlProtocolListener() {
      _classCallCheck(this, SdlProtocolListener);

      this._onRpcMessageReceived = null;
      this._onControlServiceMessageReceived = null;
    }
    /**
     * @param {function} listener 
     */


    _createClass(SdlProtocolListener, [{
      key: "setOnRpcMessageReceivedListener",
      value: function setOnRpcMessageReceivedListener(listener) {
        this._onRpcMessageReceived = listener;
      }
      /**
       * @param {function} listener 
       */

    }, {
      key: "setOnControlServiceMessageReceivedListener",
      value: function setOnControlServiceMessageReceivedListener(listener) {
        this._onControlServiceMessageReceived = listener;
      }
      /**
       * @param {function} listener 
       */

    }, {
      key: "setOnDecryptRequestListener",
      value: function setOnDecryptRequestListener(listener) {
        this._onDecryptRequestListener = listener;
      } //TODO add the setters for the added functions

      /*
      * Listener methods to be called
      *
      */

      /**
       * @param {SdlPacket} sdlPacket 
       */

    }, {
      key: "onControlServiceMessageReceived",
      value: function onControlServiceMessageReceived(sdlPacket) {
        if (typeof this._onControlServiceMessageReceived === 'function') {
          this._onControlServiceMessageReceived(sdlPacket);
        }
      }
      /**
       * @param {RpcMessage} rpcMessage 
       */

    }, {
      key: "onRpcMessageReceived",
      value: function onRpcMessageReceived(rpcMessage) {
        if (typeof this._onRpcMessageReceived === 'function') {
          this._onRpcMessageReceived(rpcMessage);
        }
      }
      /**
       * @param {SdlPacket} sdlPacket 
       */

    }, {
      key: "onStartServiceACKReceived",
      value: function onStartServiceACKReceived(sdlPacket) {
        if (typeof this._onStartServiceACKReceived === 'function') {
          this._onStartServiceACKReceived(sdlPacket);
        }
      }
      /**
       * @param {SdlPacket} sdlPacket 
       */

    }, {
      key: "onStartServiceNAKReceived",
      value: function onStartServiceNAKReceived(sdlPacket) {
        if (typeof this._onStartServiceNAKReceived === 'function') {
          this._onStartServiceNAKReceived(sdlPacket);
        }
      }
      /**
       * @param {SdlPacket} sdlPacket 
       */

    }, {
      key: "onEndServiceACKReceived",
      value: function onEndServiceACKReceived(sdlPacket) {
        if (typeof this._onEndServiceACKReceived === 'function') {
          this._onEndServiceACKReceived(sdlPacket);
        }
      }
      /**
       * @param {SdlPacket} sdlPacket 
       */

    }, {
      key: "onEndServiceNAKReceived",
      value: function onEndServiceNAKReceived(sdlPacket) {
        if (typeof this._onEndServiceNAKReceived === 'function') {
          this._onEndServiceNAKReceived(sdlPacket);
        }
      }
      /**
       * @param {ServiceType} serviceType 
       */

    }, {
      key: "onServiceEncryptionStarted",
      value: function onServiceEncryptionStarted(serviceType) {
        if (typeof this.onServiceEncryptionStarted === 'function') {
          this.onServiceEncryptionStarted(serviceType);
        }
      }
    }]);

    return SdlProtocolListener;
  }();

  var TransportListener =
  /*#__PURE__*/
  function () {
    /**
     * @constructor
     */
    function TransportListener() {
      _classCallCheck(this, TransportListener);

      this._onTransportConnected = null;
      this._onTransportDisconnected = null;
      this._onError = null;
      this._onPacketReceived = null;
    }
    /**
     * @param {Function} func
     * @return {TransportListener}
     */


    _createClass(TransportListener, [{
      key: "setOnTransportConnected",
      value: function setOnTransportConnected(func) {
        this._onTransportConnected = func;
        return this;
      }
      /**
       * @param {Function} func
       * @return {TransportListener}
       */

    }, {
      key: "setOnTransportDisconnected",
      value: function setOnTransportDisconnected(func) {
        this._onTransportDisconnected = func;
        return this;
      }
      /**
       * @param {Function} func
       * @return {TransportListener}
       */

    }, {
      key: "setOnError",
      value: function setOnError(func) {
        this._onError = func;
        return this;
      }
      /**
       * @param {Function} func
       * @return {TransportListener}
       */

    }, {
      key: "setOnPacketReceived",
      value: function setOnPacketReceived(func) {
        this._onPacketReceived = func;
        return this;
      }
    }, {
      key: "onTransportConnected",
      value: function onTransportConnected() {
        if (typeof this._onTransportConnected === 'function') {
          this._onTransportConnected();
        }
      }
    }, {
      key: "onTransportDisconnected",
      value: function onTransportDisconnected() {
        if (typeof this._onTransportDisconnected === 'function') {
          this._onTransportDisconnected();
        }
      }
    }, {
      key: "onError",
      value: function onError() {
        if (typeof this._onError === 'function') {
          this._onError();
        }
      }
    }, {
      key: "onPacketReceived",
      value: function onPacketReceived(sdlPacket) {
        if (typeof this._onPacketReceived === 'function') {
          this._onPacketReceived(sdlPacket);
        }
      }
    }]);

    return TransportListener;
  }();

  /*
  * Copyright (c) 2019, Livio, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
  * Redistributions of source code must retain the above copyright notice, this
  * list of conditions and the following disclaimer.
  *
  * Redistributions in binary form must reproduce the above copyright notice,
  * this list of conditions and the following
  * disclaimer in the documentation and/or other materials provided with the
  * distribution.
  *
  * Neither the name of the Livio Inc. nor the names of its contributors
  * may be used to endorse or promote products derived from this software
  * without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */

  /**
   * @typedef {Object} TransportConfigBase
   * @property {TransportType} _transportType
   * @property {Function} getTransportType
   */
  var TransportConfigBase =
  /*#__PURE__*/
  function () {
    /**
        * @constructor
        * @param {TransportType} transportType - enum
        */
    function TransportConfigBase(transportType) {
      _classCallCheck(this, TransportConfigBase);

      this._transportType = transportType;
    }
    /**
     * @return {TransportType}
     */


    _createClass(TransportConfigBase, [{
      key: "getTransportType",
      value: function getTransportType() {
        return this._transportType;
      }
    }]);

    return TransportConfigBase;
  }();

  /*
  * Copyright (c) 2019, Livio, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
  * Redistributions of source code must retain the above copyright notice, this
  * list of conditions and the following disclaimer.
  *
  * Redistributions in binary form must reproduce the above copyright notice,
  * this list of conditions and the following
  * disclaimer in the documentation and/or other materials provided with the
  * distribution.
  *
  * Neither the name of the Livio Inc. nor the names of its contributors
  * may be used to endorse or promote products derived from this software
  * without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
  var Version =
  /*#__PURE__*/
  function () {
    /**
    * @constructor
    */
    function Version(major, minor, patch) {
      _classCallCheck(this, Version);

      this.setMajor(major);
      this.setMinor(minor);
      this.setPatch(patch);
    }
    /**
    * @param {Number} major
    * @return {Version}
    */


    _createClass(Version, [{
      key: "setMajor",
      value: function setMajor(major) {
        this._major = parseInt(major) || 0;
        return this;
      }
      /**
      * @return {Number}
      */

    }, {
      key: "getMajor",
      value: function getMajor() {
        return this._major;
      }
      /**
      * @param {Number} minor
      * @return {Version}
      */

    }, {
      key: "setMinor",
      value: function setMinor(minor) {
        this._minor = parseInt(minor) || 0;
        return this;
      }
      /**
      * @return {Number}
      */

    }, {
      key: "getMinor",
      value: function getMinor() {
        return this._minor;
      }
      /**
      * @param {Number} patch
      * @return {Version}
      */

    }, {
      key: "setPatch",
      value: function setPatch(patch) {
        this._patch = parseInt(patch) || 0;
        return this;
      }
      /**
      * @return {Number}
      */

    }, {
      key: "getPatch",
      value: function getPatch() {
        return this._patch;
      }
      /**
      * @param {String} version - Parse this string to a Version object
      * @return {Version}
      */

    }, {
      key: "fromString",
      value: function fromString(version) {
        var versions = version.split(".");
        if (versions.length != 3) throw "Incorrect version string format";
        this.setMajor(versions[0]);
        this.setMinor(versions[1]);
        this.setPatch(versions[2]);
        return this;
      }
      /**
      * @return {String}
      */

    }, {
      key: "toString",
      value: function toString() {
        return "".concat(this.getMajor(), ".").concat(this.getMinor(), ".").concat(this.getPatch());
      }
      /**
      * Method to test if this instance of Version is newer than the supplied one.
      * @param version - the version to check against
      * @return {Number} - 1 if this instance is newer, -1 if supplied version is newer, and 0 if they are equal
      */

    }, {
      key: "isNewerThan",
      value: function isNewerThan(version) {
        if (this.getMajor() > version.getMajor()) {
          return 1;
        } else if (this.getMajor() == version.getMajor()) {
          if (this.getMinor() > version.getMinor()) {
            return 1;
          } else if (this.getMinor() == version.getMinor()) {
            if (this.getPatch() > version.getPatch()) {
              return 1;
            } else if (this.getPatch() == version.getPatch()) {
              return 0;
            }
          }
        }

        return -1;
      }
    }]);

    return Version;
  }();

  var SdlProtocolBase =
  /*#__PURE__*/
  function () {
    /**
     * 
     * @param { TransportConfigBase } baseTransportConfig
     * @param { SdlProtocolListener } sdlProtocolListener
     */
    function SdlProtocolBase(baseTransportConfig, sdlProtocolListener) {
      _classCallCheck(this, SdlProtocolBase);

      this._transportConfig = baseTransportConfig;
      this._sdlProtocollistener = sdlProtocolListener;
      reset();

      _createTransportListener();

      this._transportManager = null; //The transport manager should be created
    }
    /**
     * Listens for transport-related events and handles them here
     * @private
     */


    _createClass(SdlProtocolBase, [{
      key: "_createTransportListener",
      value: function _createTransportListener() {
        this._transportListener = new TransportListener();

        this._transportListener.setOnTransportConnected(function () {//Transport connected
          //Start RPC session
        });

        this._transportListener.setOnTransportDisconnected(function () {//Transport disconnected
          //Shut everything down
        });

        this._transportListener.setOnPacketReceived(function (sdlPacket) {
          //SdlPacket received
          this._handlePacketReceived(sdlPacket); //Could just pass in this funciton instead of creating an anonymouse funciton to call it

        });

        this._transportListener.setOnError(function () {//Handle error?
        });
      }
      /**
       * Starts up the SDL protocol class. It will kick off the transport manager and underlying transport.
       */

    }, {
      key: "start",
      value: function start() {
        if (this._transportManager == null) {
          throw "transport manager was null, unable to start SDL Protocol";
        }

        this._transportManager.start();

        return this;
      }
      /**
       * @param {ServiceType} serviceType 
       * @return {Number} max transport unit for the give service type
       */

    }, {
      key: "getMtu",
      value: function getMtu(serviceType) {
        var retVal = this._mtus.get(serviceType);

        if (retVal != null) {
          return retVal;
        }

        return SdlProtocolBase.V1_V2_MTU_SIZE;
      }
      /**
       * @return {Boolean} isConnected
       */

    }, {
      key: "isConnected",
      value: function isConnected() {
        return this._transportManager != null && this._transportManager.isConnected(null, null);
      }
      /**
       * Sets internal class members to default values
       */

    }, {
      key: "reset",
      value: function reset() {
        this._protocol_version = new Version(1, 0, 0);
        this._transportConfig = baseTransportConfig;
        this._headerSize = SdlProtocolBase.V1_HEADER_SIZE;
        this.serviceStatus = new Map();
        this.serviceStatus[ServiceType.CONTROL] = true;
        this._mtus = new Map();
        this._mtus[ServiceType.RPC] = SdlProtocolBase.V1_V2_MTU_SIZE - this._headerSize;
        this._hashID = 0;
        this._messageID = 0;
        this._messageFrameAssemblers = new Map();
      }
      /**
       * @return {Version} protocol_version
       */

    }, {
      key: "getProtocolVersion",
      value: function getProtocolVersion() {
        return this._protocol_version;
      }
      /**
       * This method will set the major protocol version that we should use. It will also set the default MTU based on version.
       * @param {Number} version - major version to use
       * @private
       */

    }, {
      key: "_setVersion",
      value: function _setVersion(version) {
        if (version > 5) {
          this.protocolVersion = new Version("5.1.0"); //protect for future, proxy only supports v5 or lower

          headerSize = SdlProtocolBase.V2_HEADER_SIZE;
          mtus[ServiceType.RPC] = SdlProtocolBase.V3_V4_MTU_SIZE;
        } else if (version == 5) {
          this.protocolVersion = new Version("5.0.0");
          headerSize = SdlProtocolBase.V2_HEADER_SIZE;
          mtus[ServiceType.RPC] = SdlProtocolBase.V3_V4_MTU_SIZE;
        } else if (version == 4) {
          this.protocolVersion = new Version("4.0.0");
          headerSize = SdlProtocolBase.V2_HEADER_SIZE;
          mtus[ServiceType.RPC] = SdlProtocolBase.V3_V4_MTU_SIZE; //versions 4 supports 128k MTU
        } else if (version == 3) {
          this.protocolVersion = new Version("3.0.0");
          headerSize = SdlProtocolBase.V2_HEADER_SIZE;
          mtus[ServiceType.RPC] = SdlProtocolBase.V3_V4_MTU_SIZE; //versions 3 supports 128k MTU
        } else if (version == 2) {
          this.protocolVersion = new Version("2.0.0");
          headerSize = SdlProtocolBase.V2_HEADER_SIZE;
          mtus[ServiceType.RPC] = SdlProtocolBase.V1_V2_MTU_SIZE - headerSize;
        } else if (version == 1) {
          this.protocolVersion = new Version("1.0.0");
          headerSize = SdlProtocolBase.V1_HEADER_SIZE;
          mtus[ServiceType.RPC] = SdlProtocolBase.V1_V2_MTU_SIZE - headerSize;
        }
      }
      /**
       * @param {SdlPacket} sdlPacket
       */

    }, {
      key: "sendPacket",
      value: function sendPacket(sdlPacket) {
        if (this._transportManager != null) {
          this._transportManager.sendPacket(sdlPacket);
        }
      }
      /**
       * @param {RpcMessage} rpcMessage 
       */

    }, {
      key: "sendRpc",
      value: function sendRpc(rpcMessage) {
        if (rpcMessage != null) {
          //(version = 1, encryption = false, frameType = -1, serviceType = -1, frameInfo = -1, sessionID = 0, dataSize = 0, messageID = 0, payload = null, offset = 0, bytesToWrite = 0) {
          var paramBytes = new Uint8Array(rpcMessage.getParameters());
          var sdlPacket = new SdlPacket(this._protocol_version.getMajor(), false); //TODO: sdlPacket.set
        }
      }
    }, {
      key: "sendMessage",
      value: function sendMessage(protocolMessage) {} //TODO 
      // This is the method that handles all the building of sdl packets that get sent 
      // in the java suite lib. We want to avoid using protocol message here as an extra 
      // class that doesn't make much sense. I believe we should probably alter SdlPacket
      // to handle the situation protocol message used to

      /**
       * Handle an SdlPacket depending on its FrameType
       * @param {SdlPacket} sdlPacket 
       * @private
       */

    }, {
      key: "_handlePacketReceived",
      value: function _handlePacketReceived(sdlPacket) {
        if (this._protocol_version == null || this._protocol_version.getMajor() == 1) {
          this._setVersion(packet.version);
        }

        if (sdlPacket.getFrameType() == FrameType.FIRST || sdlPacket.getFrameType() == FrameType.CONSECUTIVE) {
          messageFrameAssembler = _getMessageFrameAssembler(sdlPacket);
          messageFrameAssembler.handleFrame(sdlPacket);
        } else {
          //Packet can be handled as is
          switch (sdlPacket.getFrameType()) {
            case FrameType.CONTROL:
              this._handleControlPacket(sdlPacket);

              break;

            case FrameType.SINGLE:
              switch (sdlPacket.getServiceType()) {
                case ServiceType.RPC:
                  this._handleRPCPacket(sdlPacket);

                  break;
              }

          }
        }
      }
      /**
       * @param {SdlPacket} sdlPacket 
       * @private
       */

    }, {
      key: "_getMessageFrameAssembler",
      value: function _getMessageFrameAssembler(sdlPacket) {
        var messageFrameAssembler = this._messageFrameAssemblers[sdlPacket.getMessageID()];

        if (messageFrameAssembler == null) {
          messageFrameAssembler = MessageFrameAssembler(this._headerSize, new function (sdlPacket) {
            //TODO
            // Make sure we want to pass back an SDL Packet. 
            this._messageFrameAssemblers[sdlPacket.getMessageID()] = null; //Remove the mapping
          }());
          this._messageFrameAssemblers[sdlPacket.getMessageID()] = messageFrameAssembler;
        }

        return messageFrameAssembler;
      }
      /**
       * This method will handle control packets for all service types
       * @param {SdlPacket} sdlPacket 
       * @private
       */

    }, {
      key: "_handleControlPacket",
      value: function _handleControlPacket(sdlPacket) {
        var serviceType = sdlPacket.getServiceType();
        var frameInfo = sdlPacket.getFrameInfo();
        var payload = sdlPacket.getPayload();

        switch (frameInfo) {
          case sdlPacket.FRAME_INFO_START_SERVICE_ACK:
            this._handleStartServiceACK(sdlPacket);

            break;

          case sdlPacket.FRAME_INFO_START_SERVICE_NAK:
            this._handleStartServiceNAK(sdlPacket);

            break;

          case sdlPacket.FRAME_INFO_END_SERVICE_ACK:
            this._handleEndServiceACK(sdlPacket);

            break;

          case sdlPacket.FRAME_INFO_END_SERVICE_NAK:
            this._handleEndServiceACK(sdlPacket);

            break;
        }
      }
      /**
       * @param {SdlPacket} sdlPacket 
       * @private
       */

    }, {
      key: "_handleStartServiceACK",
      value: function _handleStartServiceACK(sdlPacket) {
        //TODO
        //Handle things internally first
        switch (serviceType) {
                } //Then call the listener (should be SdlSession)


        if (this._sdlProtocollistener != null) {
          this._sdlProtocollistener.onStartServiceACKReceived(sdlPacket);
        }
      }
      /**
       * @param {SdlPacket} sdlPacket 
       * @private
       */

    }, {
      key: "_handleStartServiceNAK",
      value: function _handleStartServiceNAK(sdlPacket) {} //TODO

      /**
       * @param {SdlPacket} sdlPacket 
       * @private
       */

    }, {
      key: "_handleEndServiceACK",
      value: function _handleEndServiceACK(sdlPacket) {} //TODO

      /**
       * @param {SdlPacket} sdlPacket 
       * @private
       */

    }, {
      key: "_handleEndServiceNAK",
      value: function _handleEndServiceNAK(sdlPacket) {} //TODO

      /**
       * @param {SdlPacket} sdlPacket 
       * @private
       */

    }, {
      key: "_handleControlServicePacket",
      value: function _handleControlServicePacket(sdlPacket) {
        if (this._sdlProtocollistener != null) {
          this._sdlProtocollistener.onControlServiceMessageReceived(sdlPacket);
        }
      }
      /**
       * @param {SdlPacket} sdlPacket 
       * @private
       */

    }, {
      key: "_handleRPCPacket",
      value: function _handleRPCPacket(sdlPacket) {
        var payload = sdlPacket.getPayload(); // TODO possibly add error checking that ensures this is an RPC packet

        var rpcMessage = null;

        if (this._protocol_version.getMajor() == 1) ; //There is no binary frame header
        //TODO actually create the RPC message


        if (this._sdlProtocollistener != null) {
          this._sdlProtocollistener.onRpcMessageReceived(rpcMessage);
        }
      } //Not sure if we need

      /**
       * @param {*} sessionID 
       * @param {*} _hashID 
       */

    }, {
      key: "endSession",
      value: function endSession(sessionID, _hashID) {}
    }]);

    return SdlProtocolBase;
  }();
  /**
   * Original header size based on version 1.0.0 only
   */


  SdlProtocolBase.V1_HEADER_SIZE = 8;
  /**
   * Larger header size that is used by versions 2.0.0 and up
   */

  SdlProtocolBase.V2_HEADER_SIZE = 12;
  SdlProtocolBase.V1_V2_MTU_SIZE = 1500;
  SdlProtocolBase.V3_V4_MTU_SIZE = 131072;
  /**
   * Max supported protocol version in this release of the library
  */

  SdlProtocolBase.MAX_PROTOCOL_VERSION = new Version(5, 2, 0);

  /*
  * Copyright (c) 2019, Livio, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
  * Redistributions of source code must retain the above copyright notice, this
  * list of conditions and the following disclaimer.
  *
  * Redistributions in binary form must reproduce the above copyright notice,
  * this list of conditions and the following
  * disclaimer in the documentation and/or other materials provided with the
  * distribution.
  *
  * Neither the name of the Livio Inc. nor the names of its contributors
  * may be used to endorse or promote products derived from this software
  * without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
  var ControlFrameTags = function ControlFrameTags() {
    _classCallCheck(this, ControlFrameTags);
  }; // hidden inner objects


  var StartServiceACKBase = {
    MTU: "mtu"
  };
  var NAKBase = {
    REJECTED_PARAMS: "rejectedParams"
  };
  var StartServiceProtocolVersion = {
    /** The negotiated version of the protocol. Must be in the format "Major.Minor.Patch"*/
    PROTOCOL_VERSION: "protocolVersion"
  };
  var StartServiceHashId = {
    /** Hash ID to identify this service and used when sending an EndService control frame*/
    HASH_ID: "hashId"
  };
  var StartServiceDimensions = {
    HEIGHT: "height",
    WIDTH: "width"
  }; //static members 

  ControlFrameTags.RPC = Object.freeze({
    StartService: StartServiceProtocolVersion,
    StartServiceACK: Object.assign({
      /** HU allowed transport for secondary connection */
      SECONDARY_TRANSPORTS: "secondaryTransports",

      /** HU allowed transports for audio and video services (1 == Primary, 2 == Secondary) */
      AUDIO_SERVICE_TRANSPORTS: "audioServiceTransports",
      VIDEO_SERVICE_TRANSPORTS: "videoServiceTransports",

      /** Auth token to be used for log in into services **/
      AUTH_TOKEN: "authToken"
    }, StartServiceACKBase, StartServiceProtocolVersion, StartServiceHashId),
    StartServiceNAK: NAKBase,
    EndService: StartServiceHashId,
    EndServiceACK: {},
    EndServiceNAK: NAKBase,
    TransportEventUpdate: {
      TCP_IP_ADDRESS: "tcpIpAddress",
      TCP_PORT: "tcpPort"
    },
    RegisterSecondaryTransport: {},
    RegisterSecondaryTransportACK: {},
    RegisterSecondaryTransportNAK: Object.assign({
      REASON: "reason"
    }, NAKBase)
  });
  ControlFrameTags.Audio = Object.freeze({
    StartService: {},
    StartServiceACK: StartServiceACKBase,
    StartServiceNAK: NAKBase,
    EndService: {},
    EndServiceACK: {},
    EndServiceNAK: NAKBase
  });
  ControlFrameTags.Video = Object.freeze({
    StartService: Object.assign({
      VIDEO_PROTOCOL: "videoProtocol",
      VIDEO_CODEC: "videoCodec"
    }, StartServiceDimensions),
    StartServiceACK: Object.assign({}, StartServiceACKBase, StartServiceDimensions)
  });

  /**
   * @typedef {Enum} RpcType
   * @property {Object} MAP
   */

  var RpcType =
  /*#__PURE__*/
  function (_Enum) {
    _inherits(RpcType, _Enum);

    /**
    * @constructor
    */
    function RpcType() {
      _classCallCheck(this, RpcType);

      return _possibleConstructorReturn(this, _getPrototypeOf(RpcType).call(this));
    }
    /**
     * @return {Number} 
     */


    _createClass(RpcType, null, [{
      key: "valueForString",

      /**
      * Confirms whether the value passed in exists in the Enums of this class
      * @param {Number} value
      * @return {null|Number} - Returns null if the enum value doesn't exist
      */
      value: function valueForString(value) {
        return RpcType.valueForStringInternal(value, RpcType.MAP);
      }
      /**
      * Returns the key of the map with the corresponding value
      * @param {Number} value
      * @return {null|String} - Returns null if not found
      */

    }, {
      key: "keyForValue",
      value: function keyForValue(value) {
        return RpcType.keyForValueInternal(value, RpcType.MAP);
      }
    }, {
      key: "NOTIFICATION",
      get: function get() {
        return RpcType.MAP.NOTIFICATION;
      }
      /**
       * @return {Number} 
       */

    }, {
      key: "RESPONSE",
      get: function get() {
        return RpcType.MAP.RESPONSE;
      }
      /**
       * @return {Number} 
       */

    }, {
      key: "REQUEST",
      get: function get() {
        return RpcType.MAP.REQUEST;
      }
    }]);

    return RpcType;
  }(Enum);

  RpcType.MAP = Object.freeze({
    'NOTIFICATION': 0x2,
    'RESPONSE': 0x1,
    'REQUEST': 0x0
  });

  var RpcNotification =
  /*#__PURE__*/
  function (_RpcMessage) {
    _inherits(RpcNotification, _RpcMessage);

    /**
       * @constructor
       */
    function RpcNotification(store) {
      var _this;

      _classCallCheck(this, RpcNotification);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(RpcNotification).call(this, store));

      _this.setRPCType(RpcType.NOTIFICATION);

      return _this;
    }

    return RpcNotification;
  }(RpcMessage);

  var RpcRequest =
  /*#__PURE__*/
  function (_RpcMessage) {
    _inherits(RpcRequest, _RpcMessage);

    /**
    * @constructor
    */
    function RpcRequest(store) {
      var _this;

      _classCallCheck(this, RpcRequest);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(RpcRequest).call(this, store));

      _this.setRPCType(RpcType.REQUEST);

      _this._promise = null;
      return _this;
    }
    /**
    * @return {Number}
    */


    _createClass(RpcRequest, [{
      key: "getCorrelationID",
      value: function getCorrelationID() {
        return this._correlationID;
      }
      /**
      * @param {Number} id
      * @return {RpcMessage}
      */

    }, {
      key: "setCorrelationID",
      value: function setCorrelationID(id) {
        this._correlationID = id;
        return this;
      }
      /**
      * @return {Promise}
      */

    }, {
      key: "getOnRPCResponsePromise",
      value: function getOnRPCResponsePromise() {
        return this._promise;
      }
      /**
      * @param {Promise} promise
      * @return {RpcMessage}
      */

    }, {
      key: "setOnRPCResponsePromise",
      value: function setOnRPCResponsePromise(promise) {
        this.validateType(Promise, promise);
        this._promise = promise;
        return this;
      }
    }]);

    return RpcRequest;
  }(RpcMessage);

  /**
   * @typedef {Enum} Result
   * @property {Object} MAP
   */

  var Result =
  /*#__PURE__*/
  function (_Enum) {
    _inherits(Result, _Enum);

    /**
     * @constructor
     */
    function Result() {
      _classCallCheck(this, Result);

      return _possibleConstructorReturn(this, _getPrototypeOf(Result).call(this));
    }
    /**
     * @return {String} 
     */


    _createClass(Result, null, [{
      key: "valueForString",

      /**
      * Confirms whether the value passed in exists in the Enums of this class
      * @param {String} value
      * @return {null|String} - Returns null if the enum value doesn't exist
      */
      value: function valueForString(value) {
        return Result.valueForStringInternal(value, Result.MAP);
      }
      /**
      * Returns the key of the map with the corresponding value
      * @param {String} value
      * @return {null|String} - Returns null if not found
      */

    }, {
      key: "keyForValue",
      value: function keyForValue(value) {
        return Result.keyForValueInternal(value, Result.MAP);
      }
    }, {
      key: "SUCCESS",
      get: function get() {
        return Result.MAP.SUCCESS;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "UNSUPPORTED_REQUEST",
      get: function get() {
        return Result.MAP.UNSUPPORTED_REQUEST;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "UNSUPPORTED_RESOURCE",
      get: function get() {
        return Result.MAP.UNSUPPORTED_REQUEST;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "DISALLOWED",
      get: function get() {
        return Result.MAP.DISALLOWED;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "REJECTED",
      get: function get() {
        return Result.MAP.REJECTED;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "ABORTED",
      get: function get() {
        return Result.MAP.ABORTED;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "IGNORED",
      get: function get() {
        return Result.MAP.IGNORED;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "RETRY",
      get: function get() {
        return Result.MAP.RETRY;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "IN_USE",
      get: function get() {
        return Result.MAP.IN_USE;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "VEHICLE_DATA_NOT_AVAILABLE",
      get: function get() {
        return Result.MAP.VEHICLE_DATA_NOT_AVAILABLE;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "TIMED_OUT",
      get: function get() {
        return Result.MAP.TIMED_OUT;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "INVALID_DATA",
      get: function get() {
        return Result.MAP.INVALID_DATA;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "CHAR_LIMIT_EXCEEDED",
      get: function get() {
        return Result.MAP.CHAR_LIMIT_EXCEEDED;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "INVALID_ID",
      get: function get() {
        return Result.MAP.INVALID_ID;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "DUPLICATE_NAME",
      get: function get() {
        return Result.MAP.DUPLICATE_NAME;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "APPLICATION_NOT_REGISTERED",
      get: function get() {
        return Result.MAP.APPLICATION_NOT_REGISTERED;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "WRONG_LANGUAGE",
      get: function get() {
        return Result.MAP.WRONG_LANGUAGE;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "OUT_OF_MEMORY",
      get: function get() {
        return Result.MAP.OUT_OF_MEMORY;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "TOO_MANY_PENDING_REQUESTS",
      get: function get() {
        return Result.MAP.TOO_MANY_PENDING_REQUESTS;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "TOO_MANY_APPLICATIONS",
      get: function get() {
        return Result.MAP.TOO_MANY_APPLICATIONS;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "APPLICATION_REGISTERED_ALREADY",
      get: function get() {
        return Result.MAP.APPLICATION_REGISTERED_ALREADY;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "WARNINGS",
      get: function get() {
        return Result.MAP.WARNINGS;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "GENERIC_ERROR",
      get: function get() {
        return Result.MAP.GENERIC_ERROR;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "USER_DISALLOWED",
      get: function get() {
        return Result.MAP.USER_DISALLOWED;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "TRUNCATED_DATA",
      get: function get() {
        return Result.MAP.TRUNCATED_DATA;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "UNSUPPORTED_VERSION",
      get: function get() {
        return Result.MAP.UNSUPPORTED_VERSION;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "VEHICLE_DATA_NOT_ALLOWED",
      get: function get() {
        return Result.MAP.VEHICLE_DATA_NOT_ALLOWED;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "FILE_NOT_FOUND",
      get: function get() {
        return Result.MAP.FILE_NOT_FOUND;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "CANCEL_ROUTE",
      get: function get() {
        return Result.MAP.CANCEL_ROUTE;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "SAVED",
      get: function get() {
        return Result.MAP.SAVED;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "INVALID_CERT",
      get: function get() {
        return Result.MAP.INVALID_CERT;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "EXPIRED_CERT",
      get: function get() {
        return Result.MAP.EXPIRED_CERT;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "RESUME_FAILED",
      get: function get() {
        return Result.MAP.RESUME_FAILED;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "DATA_NOT_AVAILABLE",
      get: function get() {
        return Result.MAP.DATA_NOT_AVAILABLE;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "READ_ONLY",
      get: function get() {
        return Result.MAP.READ_ONLY;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "CORRUPTED_DATA",
      get: function get() {
        return Result.MAP.CORRUPTED_DATA;
      }
    }]);

    return Result;
  }(Enum);

  Result.MAP = Object.freeze({
    'SUCCESS': 'SUCCESS',
    'UNSUPPORTED_REQUEST': 'UNSUPPORTED_REQUEST',
    'UNSUPPORTED_RESOURCE': 'UNSUPPORTED_RESOURCE',
    'DISALLOWED': 'DISALLOWED',
    'REJECTED': 'REJECTED',
    'ABORTED': 'ABORTED',
    'IGNORED': 'IGNORED',
    'RETRY': 'RETRY',
    'IN_USE': 'IN_USE',
    'VEHICLE_DATA_NOT_AVAILABLE': 'VEHICLE_DATA_NOT_AVAILABLE',
    'TIMED_OUT': 'TIMED_OUT',
    'INVALID_DATA': 'INVALID_DATA',
    'CHAR_LIMIT_EXCEEDED': 'CHAR_LIMIT_EXCEEDED',
    'INVALID_ID': 'INVALID_ID',
    'DUPLICATE_NAME': 'DUPLICATE_NAME',
    'APPLICATION_NOT_REGISTERED': 'APPLICATION_NOT_REGISTERED',
    'WRONG_LANGUAGE': 'WRONG_LANGUAGE',
    'OUT_OF_MEMORY': 'OUT_OF_MEMORY',
    'TOO_MANY_PENDING_REQUESTS': 'TOO_MANY_PENDING_REQUESTS',
    'TOO_MANY_APPLICATIONS': 'TOO_MANY_APPLICATIONS',
    'APPLICATION_REGISTERED_ALREADY': 'APPLICATION_REGISTERED_ALREADY',
    'WARNINGS': 'WARNINGS',
    'GENERIC_ERROR': 'GENERIC_ERROR',
    'USER_DISALLOWED': 'USER_DISALLOWED',
    'TRUNCATED_DATA': 'TRUNCATED_DATA',
    'UNSUPPORTED_VERSION': 'UNSUPPORTED_VERSION',
    'VEHICLE_DATA_NOT_ALLOWED': 'VEHICLE_DATA_NOT_ALLOWED',
    'FILE_NOT_FOUND': 'FILE_NOT_FOUND',
    'CANCEL_ROUTE': 'CANCEL_ROUTE',
    'SAVED': 'SAVED',
    'INVALID_CERT': 'INVALID_CERT',
    'EXPIRED_CERT': 'EXPIRED_CERT',
    'RESUME_FAILED': 'RESUME_FAILED',
    'DATA_NOT_AVAILABLE': 'DATA_NOT_AVAILABLE',
    'READ_ONLY': 'READ_ONLY',
    'CORRUPTED_DATA': 'CORRUPTED_DATA'
  });

  var RpcResponse =
  /*#__PURE__*/
  function (_RpcMessage) {
    _inherits(RpcResponse, _RpcMessage);

    /**
    * @constructor
    */
    function RpcResponse(store) {
      var _this;

      _classCallCheck(this, RpcResponse);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(RpcResponse).call(this, store));

      _this.setRPCType(RpcType.RESPONSE);

      return _this;
    }
    /**
    * @return {Number}
    */


    _createClass(RpcResponse, [{
      key: "getCorrelationID",
      value: function getCorrelationID() {
        return this._correlationID;
      }
      /**
      * @param {Number} id
      * @return {RpcResponse}
      */

    }, {
      key: "setCorrelationID",
      value: function setCorrelationID(id) {
        this._correlationID = id;
        return this;
      }
      /**
      * @return {Boolean}
      */

    }, {
      key: "getSuccess",
      value: function getSuccess() {
        return this.getParameter(KEY_SUCCESS);
      }
      /**
      * @return {RpcResponse}
      */

    }, {
      key: "setSuccess",
      value: function setSuccess(success) {
        this.setParameter(KEY_SUCCESS, success);
        return this;
      }
      /**
      * @return {String}
      */

    }, {
      key: "getInfo",
      value: function getInfo() {
        return this.getParameter(KEY_INFO);
      }
      /**
      * @return {RpcResponse}
      */

    }, {
      key: "setInfo",
      value: function setInfo(info) {
        this.setParameter(KEY_INFO, info);
        return this;
      }
      /**
      * @return {Result}
      */

    }, {
      key: "getResultCode",
      value: function getResultCode() {
        return this.getObject(Result, KEY_RESULT_CODE);
      }
      /**
      * @return {RpcResponse}
      */

    }, {
      key: "setResultCode",
      value: function setResultCode(resultCode) {
        this.validateType(Result, resultCode);
        this.setParameter(KEY_RESULT_CODE, resultCode);
        return this;
      }
    }]);

    return RpcResponse;
  }(RpcMessage);

  RpcResponse.KEY_SUCCESS = 'success';
  RpcResponse.KEY_INFO = 'info';
  RpcResponse.KEY_RESULT_CODE = 'resultCode';

  /**
   * @typedef {Enum} FunctionID
   * @property {Object} MAP
   */

  var FunctionID =
  /*#__PURE__*/
  function (_Enum) {
    _inherits(FunctionID, _Enum);

    /**
     * @constructor 
     */
    function FunctionID() {
      _classCallCheck(this, FunctionID);

      return _possibleConstructorReturn(this, _getPrototypeOf(FunctionID).call(this));
    }
    /**
    * @return {Number}
    */


    _createClass(FunctionID, null, [{
      key: "valueForString",

      /**
      * Confirms whether the value passed in exists in the Enums of this class
      * @param {Number} value
      * @return {null|Number} - Returns null if the enum value doesn't exist
      */
      value: function valueForString(value) {
        return FunctionID.valueForStringInternal(value, FunctionID.MAP);
      }
      /**
      * Returns the key of the map with the corresponding value
      * @param {Number} value
      * @return {null|String} - Returns null if not found
      */

    }, {
      key: "keyForValue",
      value: function keyForValue(value) {
        return FunctionID.keyForValueInternal(value, FunctionID.MAP);
      }
    }, {
      key: "ADD_COMMAND",
      get: function get() {
        return FunctionID.MAP.AddCommand;
      }
      /**
      * @return {Number}
      */

    }, {
      key: "ON_LANGUAGE_CHANGE",
      get: function get() {
        return FunctionID.MAP.OnLanguageChange;
      }
    }]);

    return FunctionID;
  }(Enum);

  FunctionID.MAP = Object.freeze({
    'AddCommand': 0x05,
    'OnLanguageChange': 0x800A //TODO this needs to be completely filled out still

  });

  /**
   * @typedef {Enum} ImageType
   * @property {Object} MAP
   */

  var ImageType =
  /*#__PURE__*/
  function (_Enum) {
    _inherits(ImageType, _Enum);

    /**
    * @constructor
    */
    function ImageType() {
      _classCallCheck(this, ImageType);

      return _possibleConstructorReturn(this, _getPrototypeOf(ImageType).call(this));
    }
    /**
     * @return {String} 
     */


    _createClass(ImageType, null, [{
      key: "valueForString",

      /**
      * Confirms whether the value passed in exists in the Enums of this class
      * @param {String} value
      * @return {null|String} - Returns null if the enum value doesn't exist
      */
      value: function valueForString(value) {
        return ImageType.valueForStringInternal(value, ImageType.MAP);
      }
    }, {
      key: "STATIC",
      get: function get() {
        return ImageType.MAP.STATIC;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "DYNAMIC",
      get: function get() {
        return ImageType.MAP.DYNAMIC;
      }
    }]);

    return ImageType;
  }(Enum);

  ImageType.MAP = Object.freeze({
    'STATIC': 'STATIC',
    'DYNAMIC': 'DYNAMIC'
  });

  /**
   * @typedef {Enum} Language
   * @property {Object} MAP
   */

  var Language =
  /*#__PURE__*/
  function (_Enum) {
    _inherits(Language, _Enum);

    /**
     * @constructor 
     */
    function Language() {
      _classCallCheck(this, Language);

      return _possibleConstructorReturn(this, _getPrototypeOf(Language).call(this));
    }
    /**
     * @return {String} 
     */


    _createClass(Language, null, [{
      key: "valueForString",

      /**
      * Confirms whether the value passed in exists in the Enums of this class
      * @param {String} value
      * @return {null|String} - Returns null if the enum value doesn't exist
      */
      value: function valueForString(value) {
        for (var key in Language.MAP) {
          if (Language.MAP[key] === value) {
            return Language.MAP[key];
          }
        }

        return null;
      }
    }, {
      key: "EN_SA",
      get: function get() {
        return Language.MAP.EN_SA;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "HE_IL",
      get: function get() {
        return Language.MAP.HE_IL;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "RO_RO",
      get: function get() {
        return Language.MAP.RO_RO;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "UK_UA",
      get: function get() {
        return Language.MAP.UK_UA;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "ID_ID",
      get: function get() {
        return Language.MAP.ID_ID;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "VI_VN",
      get: function get() {
        return Language.MAP.VI_VN;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "MS_MY",
      get: function get() {
        return Language.MAP.MS_MY;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "HI_IN",
      get: function get() {
        return Language.MAP.HI_IN;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "NL_BE",
      get: function get() {
        return Language.MAP.NL_BE;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "EL_GR",
      get: function get() {
        return Language.MAP.EL_GR;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "HU_HU",
      get: function get() {
        return Language.MAP.HU_HU;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "FI_FI",
      get: function get() {
        return Language.MAP.FI_FI;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "SK_SK",
      get: function get() {
        return Language.MAP.SK_SK;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "EN_US",
      get: function get() {
        return Language.MAP.EN_US;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "ES_MX",
      get: function get() {
        return Language.MAP.ES_MX;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "FR_CA",
      get: function get() {
        return Language.MAP.FR_CA;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "DE_DE",
      get: function get() {
        return Language.MAP.DE_DE;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "ES_ES",
      get: function get() {
        return Language.MAP.ES_ES;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "EN_GB",
      get: function get() {
        return Language.MAP.EN_GB;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "RU_RU",
      get: function get() {
        return Language.MAP.RU_RU;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "TR_TR",
      get: function get() {
        return Language.MAP.TR_TR;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "PL_PL",
      get: function get() {
        return Language.MAP.PL_PL;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "FR_FR",
      get: function get() {
        return Language.MAP.FR_FR;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "IT_IT",
      get: function get() {
        return Language.MAP.IT_IT;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "SV_SE",
      get: function get() {
        return Language.MAP.SV_SE;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "PT_PT",
      get: function get() {
        return Language.MAP.PT_PT;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "NL_NL",
      get: function get() {
        return Language.MAP.NL_NL;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "EN_AU",
      get: function get() {
        return Language.MAP.EN_AU;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "ZH_CN",
      get: function get() {
        return Language.MAP.ZH_CN;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "ZH_TW",
      get: function get() {
        return Language.MAP.ZH_TW;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "JA_JP",
      get: function get() {
        return Language.MAP.JA_JP;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "AR_SA",
      get: function get() {
        return Language.MAP.AR_SA;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "KO_KR",
      get: function get() {
        return Language.MAP.KO_KR;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "PT_BR",
      get: function get() {
        return Language.MAP.PT_BR;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "CS_CZ",
      get: function get() {
        return Language.MAP.CS_CZ;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "DA_DK",
      get: function get() {
        return Language.MAP.DA_DK;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "NO_NO",
      get: function get() {
        return Language.MAP.NO_NO;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "EN_IN",
      get: function get() {
        return Language.MAP.EN_IN;
      }
      /**
       * @return {String} 
       */

    }, {
      key: "TH_TH",
      get: function get() {
        return Language.MAP.TH_TH;
      }
    }]);

    return Language;
  }(Enum);

  Language.MAP = Object.freeze({
    'EN_SA': 'EN-SA',
    'HE_IL': 'HE-IL',
    'RO_RO': 'RO-RO',
    'UK_UA': 'UK-UA',
    'ID_ID': 'ID-ID',
    'VI_VN': 'VI-VN',
    'MS_MY': 'MS-MY',
    'HI_IN': 'HI-IN',
    'NL_BE': 'NL-BE',
    'EL_GR': 'EL-GR',
    'HU_HU': 'HU-HU',
    'FI_FI': 'FI-FI',
    'SK_SK': 'SK-SK',
    'EN_US': 'EN-US',
    'ES_MX': 'ES-MX',
    'FR_CA': 'FR-CA',
    'DE_DE': 'DE-DE',
    'ES_ES': 'ES-ES',
    'EN_GB': 'EN-GB',
    'RU_RU': 'RU-RU',
    'TR_TR': 'TR-TR',
    'PL_PL': 'PL-PL',
    'FR_FR': 'FR-FR',
    'IT_IT': 'IT-IT',
    'SV_SE': 'SV-SE',
    'PT_PT': 'PT-PT',
    'NL_NL': 'NL-NL',
    'EN_AU': 'EN-AU',
    'ZH_CN': 'ZH-CN',
    'ZH_TW': 'ZH-TW',
    'JA_JP': 'JA-JP',
    'AR_SA': 'AR-SA',
    'KO_KR': 'KO-KR',
    'PT_BR': 'PT-BR',
    'CS_CZ': 'CS-CZ',
    'DA_DK': 'DA-DK',
    'NO_NO': 'NO-NO',
    'EN_IN': 'EN-IN',
    'TH_TH': 'TH-TH'
  });

  var Image =
  /*#__PURE__*/
  function (_RpcStruct) {
    _inherits(Image, _RpcStruct);

    /**
    * @constructor
    */
    function Image(parameters) {
      _classCallCheck(this, Image);

      return _possibleConstructorReturn(this, _getPrototypeOf(Image).call(this, parameters));
    }
    /**
    * @param {String} value
    * @return {Image}
    */


    _createClass(Image, [{
      key: "setValue",
      value: function setValue(value) {
        this.setParameter(Image.KEY_VALUE, value);
        return this;
      }
      /**
      * @return {Number}
      */

    }, {
      key: "getValue",
      value: function getValue() {
        return this.getParameter(Image.KEY_VALUE);
      }
      /**
      * @param {ImageType} type
      * @return {Image}
      */

    }, {
      key: "setImageType",
      value: function setImageType(type) {
        this.validateType(ImageType, type);
        this.setParameter(Image.KEY_IMAGE_TYPE, type);
        return this;
      }
      /**
      * @return {ImageType}
      */

    }, {
      key: "getImageType",
      value: function getImageType() {
        return this.getObject(Image, Image.KEY_IMAGE_TYPE);
      }
      /**
      * @param {Boolean} isTemplate
      * @return {Image}
      */

    }, {
      key: "setIsTemplate",
      value: function setIsTemplate(isTemplate) {
        this.setParameter(Image.KEY_IS_TEMPLATE, isTemplate);
        return this;
      }
      /**
      * @return {Boolean}
      */

    }, {
      key: "getIsTemplate",
      value: function getIsTemplate() {
        return this.getParameter(Image.KEY_IS_TEMPLATE);
      }
    }]);

    return Image;
  }(RpcStruct);

  Image.KEY_VALUE = 'value';
  Image.KEY_IMAGE_TYPE = 'imageType';
  Image.KEY_IS_TEMPLATE = 'isTemplate';

  var MenuParams =
  /*#__PURE__*/
  function (_RpcStruct) {
    _inherits(MenuParams, _RpcStruct);

    /**
    * @constructor
    */
    function MenuParams(parameters) {
      _classCallCheck(this, MenuParams);

      return _possibleConstructorReturn(this, _getPrototypeOf(MenuParams).call(this, parameters));
    }
    /**
    * @param {Number} id
    * @return {MenuParams}
    */


    _createClass(MenuParams, [{
      key: "setParentID",
      value: function setParentID(id) {
        this.setParameter(MenuParams.KEY_PARENT_ID, id);
        return this;
      }
      /**
      * @return {Number}
      */

    }, {
      key: "getParentID",
      value: function getParentID() {
        return this.getParameter(MenuParams.KEY_PARENT_ID);
      }
      /**
      * @param {Number} position
      * @return {MenuParams}
      */

    }, {
      key: "setPosition",
      value: function setPosition(position) {
        this.setParameter(MenuParams.KEY_POSITION, position);
        return this;
      }
      /**
      * @return {Number}
      */

    }, {
      key: "getPosition",
      value: function getPosition() {
        return this.getParameter(MenuParams.KEY_POSITION);
      }
      /**
      * @param {String} menuName
      * @return {MenuParams}
      */

    }, {
      key: "setMenuName",
      value: function setMenuName(menuName) {
        this.setParameter(MenuParams.KEY_MENU_NAME, menuName);
        return this;
      }
      /**
      * @param {String}
      */

    }, {
      key: "getMenuName",
      value: function getMenuName() {
        return this.getParameter(MenuParams.KEY_MENU_NAME);
      }
    }]);

    return MenuParams;
  }(RpcStruct);

  MenuParams.KEY_PARENT_ID = 'parentID';
  MenuParams.KEY_POSITION = 'position';
  MenuParams.KEY_MENU_NAME = 'menuName';

  var AddCommand =
  /*#__PURE__*/
  function (_RpcRequest) {
    _inherits(AddCommand, _RpcRequest);

    /**
    * @constructor
    */
    function AddCommand(store) {
      var _this;

      _classCallCheck(this, AddCommand);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(AddCommand).call(this, store));

      _this.setFunctionName(FunctionID.ADD_COMMAND);

      return _this;
    }
    /**
    * @param {Number} id
    * @return {AddCommand}
    */


    _createClass(AddCommand, [{
      key: "setCmdID",
      value: function setCmdID(id) {
        this.setParameter(AddCommand.KEY_CMD_ID, id);
        return this;
      }
      /**
      * @return {Number}
      */

    }, {
      key: "getCmdID",
      value: function getCmdID() {
        return this.getParameter(AddCommand.KEY_CMD_ID);
      }
      /**
      * @param {MenuParams} menuParams
      * @return {AddCommand}
      */

    }, {
      key: "setMenuParams",
      value: function setMenuParams(menuParams) {
        this.validateType(MenuParams, menuParams);
        this.setParameter(AddCommand.KEY_MENU_PARAMS, menuParams);
        return this;
      }
      /**
      * @return {Number}
      */

    }, {
      key: "getMenuParams",
      value: function getMenuParams() {
        return this.getObject(MenuParams, AddCommand.KEY_MENU_PARAMS);
      }
      /**
      * @param {Array<String>} vrCommands
      * @return {AddCommand}
      */

    }, {
      key: "setVrCommands",
      value: function setVrCommands(vrCommands) {
        this.setParameter(AddCommand.KEY_VR_COMMANDS, vrCommands);
        return this;
      }
      /**
      * @return {Array<String>}
      */

    }, {
      key: "getVrCommands",
      value: function getVrCommands() {
        return this.getParameter(AddCommand.KEY_VR_COMMANDS);
      }
      /**
      * @param {Image} icon
      * @return {AddCommand}
      */

    }, {
      key: "setCmdIcon",
      value: function setCmdIcon(icon) {
        this.validateType(Image, icon);
        this.setParameter(AddCommand.KEY_CMD_ICON, icon);
        return this;
      }
      /**
      * @return {Image}
      */

    }, {
      key: "getCmdIcon",
      value: function getCmdIcon() {
        return this.getObject(Image, AddCommand.KEY_CMD_ICON);
      }
    }]);

    return AddCommand;
  }(RpcRequest);

  AddCommand.KEY_CMD_ICON = 'cmdIcon';
  AddCommand.KEY_MENU_PARAMS = 'menuParams';
  AddCommand.KEY_CMD_ID = 'cmdID';
  AddCommand.KEY_VR_COMMANDS = 'vrCommands';

  var AddCommandResponse =
  /*#__PURE__*/
  function (_RpcResponse) {
    _inherits(AddCommandResponse, _RpcResponse);

    /**
       * @constructor
       */
    function AddCommandResponse(store) {
      var _this;

      _classCallCheck(this, AddCommandResponse);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(AddCommandResponse).call(this, store));

      _this.setFunctionName(FunctionID.ADD_COMMAND);

      return _this;
    }

    return AddCommandResponse;
  }(RpcResponse);

  var OnLanguageChange =
  /*#__PURE__*/
  function (_RpcNotification) {
    _inherits(OnLanguageChange, _RpcNotification);

    /**
    * @constructor
    */
    function OnLanguageChange(store) {
      var _this;

      _classCallCheck(this, OnLanguageChange);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(OnLanguageChange).call(this, store));

      _this.setFunctionName(FunctionID.ON_LANGUAGE_CHANGE);

      return _this;
    }
    /**
    * @param {Language} langauge
    * @return {OnLanguageChange}
    */


    _createClass(OnLanguageChange, [{
      key: "setLanguage",
      value: function setLanguage(langauge) {
        this.validateType(Language, language);
        this.setParameter(OnLanguageChange.KEY_LANGUAGE, language);
        return this;
      }
      /**
      * @return {Language}
      */

    }, {
      key: "getLanguage",
      value: function getLanguage() {
        return this.getObject(Language, OnLanguageChange.KEY_LANGUAGE);
      }
      /**
      * @param {Language} langauge
      * @return {OnLanguageChange}
      */

    }, {
      key: "setHMIDisplayLanguage",
      value: function setHMIDisplayLanguage(language) {
        this.validateType(Language, language);
        this.setParameter(OnLanguageChange.KEY_HMI_DISPLAY_LANGUAGE, language);
        return this;
      }
      /**
      * @return {Language}
      */

    }, {
      key: "getHMIDisplayLanguage",
      value: function getHMIDisplayLanguage() {
        return this.getObject(Language, OnLanguageChange.KEY_HMI_DISPLAY_LANGUAGE);
      }
    }]);

    return OnLanguageChange;
  }(RpcNotification);

  OnLanguageChange.KEY_LANGUAGE = 'language';
  OnLanguageChange.KEY_HMI_DISPLAY_LANGUAGE = 'hmiDisplayLanguage';

  /*
  * Copyright (c) 2019, Livio, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
  * Redistributions of source code must retain the above copyright notice, this
  * list of conditions and the following disclaimer.
  *
  * Redistributions in binary form must reproduce the above copyright notice,
  * this list of conditions and the following
  * disclaimer in the documentation and/or other materials provided with the
  * distribution.
  *
  * Neither the name of the Livio Inc. nor the names of its contributors
  * may be used to endorse or promote products derived from this software
  * without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */

  /**
   * @typedef {Object} SdlSessionListener
   */
  var SdlSessionListener =
  /**
   * @constructor
   */
  function SdlSessionListener() {//TODO add all callbacks

    _classCallCheck(this, SdlSessionListener);
  };

  /**
   * @typedef {Object} SdlSession
   * @property {Function} _setupSdlProtocolListener
   * @property {Function} start
   * @property {Function} endSession
   * @property {Function} addServiceListener
   * @property {Function} removeServiceListener
   * @property {Function} sendRpc
   */

  var SdlSession =
  /*#__PURE__*/
  function () {
    /**
     * @param {TransportConfigBase} baseTransportConfig 
     * @param {SdlSessionListener} sdlSessionListener 
     */
    function SdlSession(baseTransportConfig, sdlSessionListener) {
      _classCallCheck(this, SdlSession);

      this._serviceListeners = new Array();
      this._sdlSessionListener = sdlSessionListener;

      var sdlProtocolListener = _setupSdlProtocolListener();

      this._sdlProtocol = new SdlProtocolBase(sdlProtocolListener);
    }
    /**
     * @return {SdlProtocolListener} 
     * @private
     */


    _createClass(SdlSession, [{
      key: "_setupSdlProtocolListener",
      value: function _setupSdlProtocolListener() {
        var sdlProtocolListener = new SdlProtocolListener(); //TODO create all the functions that will be set for this listener

        return sdlProtocolListener;
      }
    }, {
      key: "start",
      value: function start() {
        if (this._sdlProtocol != null) {
          this._sdlProtocol.start();
        }
      }
    }, {
      key: "endSession",
      value: function endSession() {
        //TODO handle internal items
        if (this._sdlProtocol != null) {
          this._sdlProtocol.endSession();
        }
      }
      /**
       * @param {SdlSessionListener} serviceListener 
       */

    }, {
      key: "addServiceListener",
      value: function addServiceListener(serviceListener) {
        this._serviceListeners.push(serviceListener);
      }
      /**
       * @param {SdlSessionListener} serviceListener 
       */

    }, {
      key: "removeServiceListener",
      value: function removeServiceListener(serviceListener) {
        var index = this._serviceListeners.indexOf(serviceListener);

        if (index >= 0) {
          this._serviceListeners.splice(index, 1);
        }
      }
      /**
       * @param {RpcMessage} rpcMessage 
       */

    }, {
      key: "sendRpc",
      value: function sendRpc(rpcMessage) {}
    }]);

    return SdlSession;
  }();

  var SdlPsm =
  /*#__PURE__*/
  function () {
    //TODO check to see if it's better to use '==' or '==='

    /**
        * @constructor
        */
    function SdlPsm() {
      _classCallCheck(this, SdlPsm);

      this.reset();
    }
    /**
     * Changes all internal members to default
     */


    _createClass(SdlPsm, [{
      key: "reset",
      value: function reset() {
        this._state = SdlPsm.START_STATE;
        this._version = 0;
        this._encryption = false;
        this._frameType = FrameType.SINGLE;
        this._serviceType = 0;
        this._controlFrameInfo = null;
        this._sessionID = null;
        this._dumpSize = null;
        this._dataLength = 0;
        this._messageID = 0;
        this._payload = null;
      }
      /**
          * @return {Number} - State represented by a Number
          */

    }, {
      key: "getState",
      value: function getState() {
        return this._state;
      }
      /**
       * @return {SdlPacket} - Returns null if not complete
       */

    }, {
      key: "getFormedPacket",
      value: function getFormedPacket() {
        if (this._state == SdlPsm.FINISHED_STATE) {
          return new SdlPacket(this._version, this._encryption, this._frameType, this._serviceType, this._controlFrameInfo, this._sessionID, this._dataLength, this._messageID, this._payload);
        } else {
          return null;
        }
      }
      /**
       * @param {Number} data - Represents a byte
       * @return {Boolean}
       */

    }, {
      key: "handleByte",
      value: function handleByte(data) {
        this._state = this._transitionOnInput(data, this._state);

        if (this._state == SdlPsm.ERROR_STATE) {
          return false;
        }

        return true;
      }
      /**
          * @param {Number} rawByte - Represents a byte
          * @param {Number} state
          * @return {Boolean}
          * @private
          */

    }, {
      key: "_transitionOnInput",
      value: function _transitionOnInput(rawByte, state) {
        switch (state) {
          case SdlPsm.START_STATE:
            this._version = (rawByte & SdlPsm.VERSION_MASK) >> 4;

            if (this._version == 0) {
              return SdlPsm.ERROR_STATE;
            }

            this._encryption = 1 == (rawByte & SdlPsm.ENCRYPTION_MASK) >> 3;
            this._frameType = rawByte & SdlPsm.FRAME_TYPE_MASK;

            if ((this._version < 1 || this._version > 5) && this._frameType != SdlPacket.FRAME_TYPE_CONTROL) {
              return SdlPsm.ERROR_STATE;
            }

            if (this._frameType < SdlPacket.FRAME_TYPE_CONTROL || this._frameType > SdlPacket.FRAME_TYPE_CONSECUTIVE) {
              return SdlPsm.ERROR_STATE;
            }

            return SdlPsm.SERVICE_TYPE_STATE;

          case SdlPsm.SERVICE_TYPE_STATE:
            this._serviceType = rawByte & 0xFF;
            return SdlPsm.CONTROL_FRAME_INFO_STATE;

          case SdlPsm.CONTROL_FRAME_INFO_STATE:
            this._controlFrameInfo = rawByte & 0xFF;

            switch (this._frameType) {
              case SdlPacket.FRAME_TYPE_CONTROL:
                break;

              case SdlPacket.FRAME_TYPE_SINGLE:
              case SdlPacket.FRAME_TYPE_FIRST:
                if (this._controlFrameInfo != 0x00) {
                  return SdlPsm.ERROR_STATE;
                }

                break;

              case SdlPacket.FRAME_TYPE_CONSECUTIVE:
                //It might be a good idea to check packet sequence numbers here
                break;

              default:
                return SdlPsm.ERROR_STATE;
            }

            return SdlPsm.SESSION_ID_STATE;

          case SdlPsm.SESSION_ID_STATE:
            this._sessionID = rawByte & 0xFF;
            return SdlPsm.DATA_SIZE_1_STATE;

          case SdlPsm.DATA_SIZE_1_STATE:
            this._dataLength += (rawByte & 0xFF) << 24; //Shift 3 bytes x 8 bits

            return SdlPsm.DATA_SIZE_2_STATE;

          case SdlPsm.DATA_SIZE_2_STATE:
            this._dataLength += (rawByte & 0xFF) << 16; //Sift 2 bytes x 8 bits

            return DATA_SIZE_3_STATE;

          case SdlPsm.DATA_SIZE_3_STATE:
            this._dataLength += (rawByte & 0xFF) << 8; //Sift 1 byte x 8 bits

            return DATA_SIZE_4_STATE;

          case SdlPsm.DATA_SIZE_4_STATE:
            this._dataLength += rawByte & 0xFF; //We should have data length now for the pump state

            switch (this._frameType) {
              //If all is correct we should break out of this switch statement
              case SdlPacket.FRAME_TYPE_SINGLE:
              case SdlPacket.FRAME_TYPE_CONSECUTIVE:
                break;

              case SdlPacket.FRAME_TYPE_CONTROL:
                //Ok, well here's some interesting bit of knowledge. Because the start session request is from the phone with no knowledge of version it sends out
                //a v1 packet. THEREFORE there is no message id field. **** Now you know and knowing is half the battle ****
                if (this._version == 1 && this._controlFrameInfo == SdlPacket.FRAME_INFO_START_SERVICE) {
                  if (this._dataLength == 0) {
                    return SdlPsm.FINISHED_STATE; //We are done if we don't have any payload
                  }

                  if (this._dataLength <= SdlProtocolBase.V1_V2_MTU_SIZE - SdlProtocolBase.V1_HEADER_SIZE) {
                    // sizes from protocol/SdlProtocol.js
                    this._payload = new byte[this._dataLength]();
                  } else {
                    return SdlPsm.ERROR_STATE;
                  }

                  this._dumpSize = this._dataLength;
                  return SdlPsm.DATA_PUMP_STATE;
                }

                break;

              case SdlPacket.FRAME_TYPE_FIRST:
                if (dataLength == SdlPsm.FIRST_FRAME_DATA_SIZE) {
                  break;
                }

              default:
                return SdlPsm.ERROR_STATE;
            }

            if (this._version == 1) {
              //Version 1 packets will not have message id's
              if (this._dataLength == 0) {
                return SdlPsm.FINISHED_STATE; //We are done if we don't have any payload
              }

              if (this._dataLength <= SdlProtocolBase.V1_V2_MTU_SIZE - SdlProtocolBase.V1_HEADER_SIZE) {
                // sizes from protocol/SdlProtocol.java
                this._payload = new Uint8Array(this._dataLength);
              } else {
                return SdlPsm.ERROR_STATE;
              }

              this._dumpSize = this._dataLength;
              return SdlPsm.DATA_PUMP_STATE;
            } else {
              return SdlPsm.MESSAGE_1_STATE;
            }

          case SdlPsm.MESSAGE_1_STATE:
            this._messageID += (rawByte & 0xFF) << 24; // Shift 3 bytes x 8 bits

            return SdlPsm.MESSAGE_2_STATE;

          case SdlPsm.MESSAGE_2_STATE:
            this._messageID += (rawByte & 0xFF) << 16; // Shift 2 bytes x 8 bits

            return SdlPsm.MESSAGE_3_STATE;

          case SdlPsm.MESSAGE_3_STATE:
            this._messageID += (rawByte & 0xFF) << 8; // Shift 1 byte x 8 bits

            return SdlPsm.MESSAGE_4_STATE;

          case SdlPsm.MESSAGE_4_STATE:
            this._messageID += rawByte & 0xFF;

            if (this._dataLength == 0) {
              return SdlPsm.FINISHED_STATE; //We are done if we don't have any payload
            }

            try {
              this._payload = new Uint8Array(this._dataLength);
            } catch (error) {
              //Possible Out of Memory error if data length is invalid
              return SdlPsm.ERROR_STATE;
            }

            dumpSize = dataLength;
            return SdlPsm.DATA_PUMP_STATE;

          case SdlPsm.DATA_PUMP_STATE:
            this._payload[this._dataLength - this._dumpSize] = rawByte;
            this._dumpSize--; //Do we have any more bytes to read in?

            if (this._dumpSize > 0) {
              return SdlPsm.DATA_PUMP_STATE;
            } else if (this._dumpSize == 0) {
              return SdlPsm.FINISHED_STATE;
            } else {
              return SdlPsm.ERROR_STATE;
            }

          case SdlPsm.FINISHED_STATE:
          default:
            //Should not be handling any other bytes while in the finished state
            return SdlPsm.ERROR_STATE;
        }
      }
    }]);

    return SdlPsm;
  }();

  SdlPsm.START_STATE = 0x0;
  SdlPsm.SERVICE_TYPE_STATE = 0x02;
  SdlPsm.CONTROL_FRAME_INFO_STATE = 0x03;
  SdlPsm.SESSION_ID_STATE = 0x04;
  SdlPsm.DATA_SIZE_1_STATE = 0x05;
  SdlPsm.DATA_SIZE_2_STATE = 0x06;
  SdlPsm.DATA_SIZE_3_STATE = 0x07;
  SdlPsm.DATA_SIZE_4_STATE = 0x08;
  SdlPsm.MESSAGE_1_STATE = 0x09;
  SdlPsm.MESSAGE_2_STATE = 0x0A;
  SdlPsm.MESSAGE_3_STATE = 0x0B;
  SdlPsm.MESSAGE_4_STATE = 0x0C;
  SdlPsm.DATA_PUMP_STATE = 0x0D;
  SdlPsm.FINISHED_STATE = 0xFF;
  SdlPsm.ERROR_STATE = -1;
  SdlPsm.FIRST_FRAME_DATA_SIZE = 0x08;
  SdlPsm.VERSION_MASK = 0xF0; //4 highest bits

  SdlPsm.ENCRYPTION_MASK = 0x08; //4th lowest bit

  SdlPsm.FRAME_TYPE_MASK = 0x07; //3 lowest bits

  var TransportBase =
  /*#__PURE__*/
  function () {
    /**
     * @constructor
     * @param {BaseTransportConfig} baseTransportConfig
     * @param {TransportListener} transportListener
     */
    function TransportBase(baseTransportConfig, transportListener) {
      _classCallCheck(this, TransportBase);

      this._sdlPsm = new SdlPsm();
      this._transportListener = transportListener;
    }

    _createClass(TransportBase, [{
      key: "start",
      value: function start() {
        throw "start method must be overridden";
      }
    }, {
      key: "stop",
      value: function stop() {
        throw "stop method must be overridden";
      }
      /**
       * @param {SdlPacket} sdlPacket
       */

    }, {
      key: "sendPacket",
      value: function sendPacket(sdlPacket) {
        throw "sendPacket method must be overridden";
      }
    }]);

    return TransportBase;
  }();

  /*
  * Copyright (c) 2019, Livio, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
  * Redistributions of source code must retain the above copyright notice, this
  * list of conditions and the following disclaimer.
  *
  * Redistributions in binary form must reproduce the above copyright notice,
  * this list of conditions and the following
  * disclaimer in the documentation and/or other materials provided with the
  * distribution.
  *
  * Neither the name of the Livio Inc. nor the names of its contributors
  * may be used to endorse or promote products derived from this software
  * without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
  var TransportManagerBase =
  /*#__PURE__*/
  function () {
    /**
     * @constructor
     * @param {BaseTransportConfig} baseTransportConfig
     * @param {TransportListener} transportListener
     */
    function TransportManagerBase(baseTransportConfig, transportListener) {
      _classCallCheck(this, TransportManagerBase);

      this._transportConfig = baseTransportConfig;
      this._transportListener = transportListener;
    }

    _createClass(TransportManagerBase, [{
      key: "onTransportConnected",
      value: function onTransportConnected() {
        this._transportListener.onTransportConnected();
      }
      /**
       * @param {Function} func
       */

    }, {
      key: "onTransportDisconnected",
      value: function onTransportDisconnected(func) {
        this._transportListener.onTransportDisconnected();
      }
      /**
       * @param {Function} func
       */

    }, {
      key: "onError",
      value: function onError(func) {
        this._transportListener.onError();
      }
      /**
       * @param {SdlPacket} sdlPacket
       */

    }, {
      key: "onPacketReceived",
      value: function onPacketReceived(sdlPacket) {
        this._transportListener.onPacketReceived(sdlPacket);
      }
      /**
       * @param {SdlPacket} sdlPacket
       */

    }, {
      key: "sendPacket",
      value: function sendPacket(sdlPacket) {
        throw "sendPacket method must be overridden";
      }
    }, {
      key: "start",
      value: function start() {
        throw "start method must be overridden";
      }
    }, {
      key: "stop",
      value: function stop() {
        throw "stop method must be overridden";
      }
      /**
       * @param {TransportType} transportType
       * @param {String} address
       */

    }, {
      key: "isConnected",
      value: function isConnected(transportType, address) {
        throw "isConnected method must be overridden";
      }
    }]);

    return TransportManagerBase;
  }();

  /**
   * @typedef {Enum} TransportType
   * @property {Object} MAP
   */

  var TransportType =
  /*#__PURE__*/
  function (_Enum) {
    _inherits(TransportType, _Enum);

    /**
    * @constructor
    */
    function TransportType() {
      _classCallCheck(this, TransportType);

      return _possibleConstructorReturn(this, _getPrototypeOf(TransportType).call(this));
    }
    /**
    * @param {String}
    */


    _createClass(TransportType, null, [{
      key: "valueForString",

      /**
      * Confirms whether the value passed in exists in the Enums of this class
      * @param {String} value
      * @return {null|String} - Returns null if the enum value doesn't exist
      */
      value: function valueForString(value) {
        return TransportType.valueForStringInternal(value, TransportType.MAP);
      }
    }, {
      key: "WEBSOCKET_SERVER",
      get: function get() {
        return TransportType.MAP.WEBSOCKET_SERVER;
      }
      /**
      * @param {String}
      */

    }, {
      key: "WEBSOCKET_CLIENT",
      get: function get() {
        return TransportType.MAP.WEBSOCKET_CLIENT;
      }
    }]);

    return TransportType;
  }(Enum);

  TransportType.MAP = Object.freeze({
    "WEBSOCKET_SERVER": "WEBSOCKET_SERVER",
    "WEBSOCKET_CLIENT": "WEBSOCKET_CLIENT",
    "CUSTOM": "CUSTOM"
  });

  /*
  * Copyright (c) 2019, Livio, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
  * Redistributions of source code must retain the above copyright notice, this
  * list of conditions and the following disclaimer.
  *
  * Redistributions in binary form must reproduce the above copyright notice,
  * this list of conditions and the following
  * disclaimer in the documentation and/or other materials provided with the
  * distribution.
  *
  * Neither the name of the Livio Inc. nor the names of its contributors
  * may be used to endorse or promote products derived from this software
  * without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
  var JsonRpcMarshaller =
  /*#__PURE__*/
  function () {
    function JsonRpcMarshaller() {
      _classCallCheck(this, JsonRpcMarshaller);
    }
    /*
    let testMap = {"rpcType":"Request", "functionName":"RAI"}
    undefined
    let stringed = JSON.stringify(testMap)
    undefined
    stringed
    "{"rpcType":"Request","functionName":"RAI"}"
    let array = new Uint8Array(stringed)
    undefined
    array
    Uint8Array []buffer: (...)byteLength: (...)byteOffset: (...)length: (...)Symbol(Symbol.toStringTag): (...)__proto__: TypedArray
    var enc = new TextEncoder(); // always utf-8
    undefined
    array = enc.encode(stringed)
    Uint8Array(42) [123, 34, 114, 112, 99, 84, 121, 112, 101, 34, 58, 34, 82, 101, 113, 117, 101, 115, 116, 34, 44, 34, 102, 117, 110, 99, 116, 105, 111, 110, 78, 97, 109, 101, 34, 58, 34, 82, 65, 73, 34, 125]0: 1231: 342: 1143: 1124: 995: 846: 1217: 1128: 1019: 3410: 5811: 3412: 8213: 10114: 11315: 11716: 10117: 11518: 11619: 3420: 4421: 3422: 10223: 11724: 11025: 9926: 11627: 10528: 11129: 11030: 7831: 9732: 10933: 10134: 3435: 5836: 3437: 8238: 6539: 7340: 3441: 125buffer: (...)byteLength: (...)byteOffset: (...)length: (...)Symbol(Symbol.toStringTag): (...)__proto__: TypedArray
    var enc = new TextDecoder("utf-8");
    undefined
    let step2 = enc.decode(array)
    undefined
    step2
    "{"rpcType":"Request","functionName":"RAI"}"
    let newJson = JSON.parse(step2)
    undefined
    newJson
    {rpcType: "Request", functionName: "RAI"}
       */

    /**
     * 
     * @param {RpcMessage} rpcMessage 
     */


    _createClass(JsonRpcMarshaller, null, [{
      key: "marshall",
      value: function marshall(rpcMessage) {

        try {
          var jsonObject = rpcMessage.getParameters(); //TODO do we need to go through each param and do this?

          var stringVersion = JSON.stringify(jsonObject);
          var encoder = new TextEncoder();
          return encoder.encode(stringVersion);
        } catch (exception) {//TODO print exception
        }

        return null;
      }
    }]);

    return JsonRpcMarshaller;
  }();

  /*
  * Copyright (c) 2019, Livio, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
  * Redistributions of source code must retain the above copyright notice, this
  * list of conditions and the following disclaimer.
  *
  * Redistributions in binary form must reproduce the above copyright notice,
  * this list of conditions and the following
  * disclaimer in the documentation and/or other materials provided with the
  * distribution.
  *
  * Neither the name of the Livio Inc. nor the names of its contributors
  * may be used to endorse or promote products derived from this software
  * without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
  var SDL = {
    manager: {
      lifecycle: {
        LifecycleManager: LifecycleManager
      }
    },
    protocol: {
      BinaryFrameHeader: BinaryFrameHeader,
      MessageFrameAssembler: MessageFrameAssembler,
      SdlPacket: SdlPacket,
      SdlProtocolBase: SdlProtocolBase,
      SdlProtocolListener: SdlProtocolListener,
      enums: {
        ControlFrameTags: ControlFrameTags,
        FrameType: FrameType,
        ServiceType: ServiceType
      }
    },
    rpc: {
      RpcMessage: RpcMessage,
      RpcNotification: RpcNotification,
      RpcRequest: RpcRequest,
      RpcResponse: RpcResponse,
      RpcStruct: RpcStruct,
      enums: {
        FunctionID: FunctionID,
        ImageType: ImageType,
        Language: Language,
        Result: Result,
        RpcType: RpcType
      },
      messages: {
        AddCommand: AddCommand,
        AddCommandResponse: AddCommandResponse,
        OnLanguageChange: OnLanguageChange
      },
      structs: {
        Image: Image,
        MenuParams: MenuParams
      }
    },
    session: {
      SdlSession: SdlSession,
      SdlSessionListener: SdlSessionListener
    },
    transport: {
      SdlPsm: SdlPsm,
      TransportBase: TransportBase,
      TransportConfigBase: TransportConfigBase,
      TransportListener: TransportListener,
      TransportManagerBase: TransportManagerBase,
      enums: {
        TransportType: TransportType
      }
    },
    util: {
      BitConverter: BitConverter,
      Bson: Bson,
      Enum: Enum,
      JsonRpcMarshaller: JsonRpcMarshaller,
      Version: Version
    }
  };

  return SDL;

})));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU0RMLmpzIiwic291cmNlcyI6WyIuLi9zcmMvbWFuYWdlci9saWZlY3ljbGUvTGlmZWN5Y2xlTWFuYWdlci5qcyIsIi4uL3NyYy91dGlsL0JpdENvbnZlcnRlci5qcyIsIi4uL3NyYy9wcm90b2NvbC9CaW5hcnlGcmFtZUhlYWRlci5qcyIsIi4uL3NyYy9wcm90b2NvbC9NZXNzYWdlRnJhbWVBc3NlbWJsZXIuanMiLCIuLi9zcmMvdXRpbC9FbnVtLmpzIiwiLi4vc3JjL3Byb3RvY29sL2VudW1zL0ZyYW1lVHlwZS5qcyIsIi4uLy4uLy4uL3RoaXJkX3BhcnR5L2Jzb24uY29tbW9uLmpzIiwiLi4vc3JjL3V0aWwvQnNvbi5qcyIsIi4uL3NyYy9wcm90b2NvbC9TZGxQYWNrZXQuanMiLCIuLi9zcmMvcnBjL1JwY1N0cnVjdC5qcyIsIi4uL3NyYy9ycGMvUnBjTWVzc2FnZS5qcyIsIi4uL3NyYy9wcm90b2NvbC9lbnVtcy9TZXJ2aWNlVHlwZS5qcyIsIi4uL3NyYy9wcm90b2NvbC9TZGxQcm90b2NvbExpc3RlbmVyLmpzIiwiLi4vc3JjL3RyYW5zcG9ydC9UcmFuc3BvcnRMaXN0ZW5lci5qcyIsIi4uL3NyYy90cmFuc3BvcnQvVHJhbnNwb3J0Q29uZmlnQmFzZS5qcyIsIi4uL3NyYy91dGlsL1ZlcnNpb24uanMiLCIuLi9zcmMvcHJvdG9jb2wvU2RsUHJvdG9jb2xCYXNlLmpzIiwiLi4vc3JjL3Byb3RvY29sL2VudW1zL0NvbnRyb2xGcmFtZVRhZ3MuanMiLCIuLi9zcmMvcnBjL2VudW1zL1JwY1R5cGUuanMiLCIuLi9zcmMvcnBjL1JwY05vdGlmaWNhdGlvbi5qcyIsIi4uL3NyYy9ycGMvUnBjUmVxdWVzdC5qcyIsIi4uL3NyYy9ycGMvZW51bXMvUmVzdWx0LmpzIiwiLi4vc3JjL3JwYy9ScGNSZXNwb25zZS5qcyIsIi4uL3NyYy9ycGMvZW51bXMvRnVuY3Rpb25JRC5qcyIsIi4uL3NyYy9ycGMvZW51bXMvSW1hZ2VUeXBlLmpzIiwiLi4vc3JjL3JwYy9lbnVtcy9MYW5ndWFnZS5qcyIsIi4uL3NyYy9ycGMvc3RydWN0cy9JbWFnZS5qcyIsIi4uL3NyYy9ycGMvc3RydWN0cy9NZW51UGFyYW1zLmpzIiwiLi4vc3JjL3JwYy9tZXNzYWdlcy9BZGRDb21tYW5kLmpzIiwiLi4vc3JjL3JwYy9tZXNzYWdlcy9BZGRDb21tYW5kUmVzcG9uc2UuanMiLCIuLi9zcmMvcnBjL21lc3NhZ2VzL09uTGFuZ3VhZ2VDaGFuZ2UuanMiLCIuLi9zcmMvc2Vzc2lvbi9TZGxTZXNzaW9uTGlzdGVuZXIuanMiLCIuLi9zcmMvc2Vzc2lvbi9TZGxTZXNzaW9uLmpzIiwiLi4vc3JjL3RyYW5zcG9ydC9TZGxQc20uanMiLCIuLi9zcmMvdHJhbnNwb3J0L1RyYW5zcG9ydEJhc2UuanMiLCIuLi9zcmMvdHJhbnNwb3J0L1RyYW5zcG9ydE1hbmFnZXJCYXNlLmpzIiwiLi4vc3JjL3RyYW5zcG9ydC9lbnVtcy9UcmFuc3BvcnRUeXBlLmpzIiwiLi4vc3JjL3V0aWwvSnNvblJwY01hcnNoYWxsZXIuanMiLCIuLi9hcHAuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiogQ29weXJpZ2h0IChjKSAyMDE5LCBMaXZpbywgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4qXG4qIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuKiBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbipcbiogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuKiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuKiBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGVcbiogZGlzdHJpYnV0aW9uLlxuKlxuKiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBMaXZpbyBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9yc1xuKiBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbiogd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4qXG4qIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4qIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiogQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRVxuKiBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4qIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GXG4qIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTU1xuKiBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTlxuKiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKVxuKiBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuKiBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cbmNsYXNzIExpZmVjeWNsZU1hbmFnZXIge1xuXG59XG5cbmV4cG9ydCB7IExpZmVjeWNsZU1hbmFnZXIgfTsiLCIvKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTksIExpdmlvLCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbipcbiogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4qIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuKlxuKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4qIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4qIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZVxuKiBkaXN0cmlidXRpb24uXG4qXG4qIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIExpdmlvIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzXG4qIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZVxuKiB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbipcbiogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiogQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuKiBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFXG4qIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1JcbiogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcbiogU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXG4qIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOXG4qIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4qIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4qIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cblxuY2xhc3MgQml0Q29udmVydGVyIHtcblxuICAgIC8qKlxuXHQgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBieXRlcyAtIGJ5dGUgYXJyYXkgdGhhdCB3aWxsIGJlIGNvbnZlcnRlZCB0byBoZXhcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCAtIGludCBvcHRpb25hbCwgcmVwcmVzZW50aW5nIHRoZSBvZmZzZXQgdG8gYmVnaW4gY29udmVyc2lvbiBhdFxuXHQgKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIC0gaW50IG9wdGlvbmFsLCByZXByZXNlbnRpbmcgbnVtYmVyIG9mIGJ5dGVzIGluIGFycmF5IHRvIGNvbnZlcnRcblx0ICogQHJldHVybiB7U3RyaW5nfSB0aGUgU3RyaW5nIGNvbnRhaW5pbmcgY29udmVydGVkIGhleCB2YWx1ZXMgb3IgbnVsbCBpZiBieXRlIGFycmF5IGlzIG51bGxcblx0ICovXG4gICAgYXJyYXlCdWZmZXJUb0hleChieXRlcywgb2Zmc2V0ID0gMCwgbGVuZ3RoKSB7XG4gICAgICAgIC8vIFRPRE9cbiAgICB9XG5cbiAgICAvKipcblx0ICogQHBhcmFtIHtTdHJpbmd9IGhleFN0cmluZyAtIHRoZSBTdHJpbmcgY29udGFpbmluZyBjb252ZXJ0ZWQgaGV4IHZhbHVlc1xuXHQgKiBAcmV0dXJuIHtBcnJheUJ1ZmZlcn0gYnl0ZSBhcnJheSBjb252ZXJ0ZWQgZnJvbSBpbnB1dCBTdHJpbmcgb3IgbnVsbCBpZiBTdHJpbmcgaXMgbnVsbFxuXHQgKi9cbiAgICBoZXhUb0FycmF5QnVmZmVyKGhleFN0cmluZykge1xuICAgICAgICAvLyBUT0RPXG4gICAgfVxuXG4gICAgLyoqXG5cdCAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGJ1ZmZlciAtIGJ1ZmZlciB0aGF0IHdpbGwgYmUgY29udmVydGVkIHRvIGludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgLSBpbnQgb3B0aW9uYWwsIHRoZSBvZmZzZXQgc2hpZnRcblx0ICogQHJldHVybiB7TnVtYmVyfSBpbnQgY29udmVydGVkIGZyb20gYnVmZmVyIG9yIC0xIGlmIGJ1ZmZlciBpcyBudWxsXG5cdCAqL1xuICAgIGFycmF5QnVmZmVyVG9JbnQzMihidWZmZXIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgLy8gVE9ET1xuICAgICAgICBpZighYnVmZmVyKSByZXR1cm4gLTE7XG4gICAgICAgIGxldCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB2aWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgIH1cblxuICAgIC8qKlxuXHQgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSB0aGUgaW50ZWdlciB0byBiZSBjb252ZXJ0ZWRcblx0ICogQHJldHVybiB7QXJyYXlCdWZmZXJ9IGJ1ZmZlciBjb252ZXJ0ZWQgZnJvbSBpbnB1dCB2YWx1ZVxuXHQgKi9cbiAgICBpbnQzMlRvQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgICAgICAgbGV0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcig0KTsgLy8gSW50MzIgaGFzIDQgYnl0ZXNcbiAgICAgICAgbGV0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICAgICAgdmlldy5zZXRVaW50MzIoMCwgdmFsdWUsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG5cbn1cblxuZXhwb3J0IHsgQml0Q29udmVydGVyIH07IiwiLypcbiogQ29weXJpZ2h0IChjKSAyMDE5LCBMaXZpbywgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4qXG4qIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuKiBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbipcbiogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuKiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuKiBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGVcbiogZGlzdHJpYnV0aW9uLlxuKlxuKiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBMaXZpbyBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9yc1xuKiBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbiogd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4qXG4qIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4qIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiogQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRVxuKiBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4qIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GXG4qIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTU1xuKiBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTlxuKiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKVxuKiBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuKiBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cbmltcG9ydCB7IEJpdENvbnZlcnRlciB9IGZyb20gJy4uL3V0aWwvQml0Q29udmVydGVyLmpzJztcblxuY2xhc3MgQmluYXJ5RnJhbWVIZWFkZXIge1xuXG4gICAgLyoqXG4gICAgKiBAY29uc3RydWN0b3JcbiAgICAqIEBwYXJhbSB7UnBjVHlwZX0gcnBjVHlwZSAtIEFuIFJQQyBFbnVtICByZXByZXNlbnRpbmcgdGhlIHR5cGUgb2YgUlBDIGJlaW5nIGRlc2NyaWJlZCAoUmVxdWVzdCwgUmVzcG9uc2UsIE5vdGlmaWNhdGlvbilcbiAgICAqIEBwYXJhbSB7RnVuY3Rpb25JRH0gZnVuY3Rpb25JZCAtIEEgRnVuY3Rpb25JRCBFbnVtIHJlcHJlc2VudGluZyB0aGUgUlBDIGZ1bmN0aW9uIHRoYXQgaXMgYmVpbmcgZGVzY3JpYmVkXG4gICAgKiBAcGFyYW0ge051bWJlcn0gY29ycmVsYXRpb25JZCAtIEEgbnVtYmVyIHJlcHJlc2VudGluZyBhbiBJRCB0byBjb3JyZWxhdGUgYSByZXF1ZXN0IGFuZCByZXNwb25zZSBwYWlyXG4gICAgKiBAcGFyYW0ge051bWJlcn0ganNvblNpemUgLSBBIG51bWJlciByZXByZXNlbnRpbmcgdGhlIHNpemUgb2YgYSBKU09OIG9iamVjdFxuICAgICovXG4gICAgY29uc3RydWN0b3IocnBjVHlwZSwgZnVuY3Rpb25JZCwgY29ycmVsYXRpb25JZCwganNvblNpemUpIHtcbiAgICAgICAgdGhpcy5fcnBjVHlwZSA9IHJwY1R5cGU7XG4gICAgICAgIHRoaXMuX2Z1bmN0aW9uSWQgPSBmdW5jdGlvbklkO1xuICAgICAgICB0aGlzLl9jb3JyZWxhdGlvbklkID0gY29ycmVsYXRpb25JZDtcbiAgICAgICAgdGhpcy5fanNvblNpemUgPSBqc29uU2l6ZTtcblxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIHRoaXMuX2pzb25EYXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYnVsa0RhdGEgPSBudWxsO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBUYWtlcyBpbiBhIGJ5dGUgYXJyYXkgYW5kIHRyYW5zZm9ybXMgaXQgdG8gYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzc1xuICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBiaW5IZWFkZXJcbiAgICAqIEByZXR1cm4ge0JpbmFyeUZyYW1lSGVhZGVyfSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIGZyb20gcGFyc2luZyB0aGUgc3VwcGxpZWQgVWludDhBcnJheSBcbiAgICAqL1xuICAgIGZyb21CaW5hcnlIZWFkZXIoYmluSGVhZGVyKSB7XG4gICAgICAgIC8vIFRPRE9cbiAgICB9XG5cbiAgICAvKipcbiAgICAqIFVzZXMgdGhlIHByaXZhdGUgbWVtYmVycyBvZiB0aGlzIGNsYXNzIHRvIGNvbnN0cnVjdCBhIGJ5dGUgYXJyYXkgaGVhZGVyXG4gICAgKiBAcmV0dXJuIHtVaW50OEFycmF5fSAtIEEgYnl0ZSBhcnJheVxuICAgICovXG4gICAgYXNzZW1ibGVIZWFkZXJCeXRlcygpIHtcbiAgICAgICAgLy8gVE9ET1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQHBhcmFtIHtScGNUeXBlfSBycGNUeXBlIC0gQW4gUlBDIEVudW0gIHJlcHJlc2VudGluZyB0aGUgdHlwZSBvZiBSUEMgYmVpbmcgZGVzY3JpYmVkIChSZXF1ZXN0LCBSZXNwb25zZSwgTm90aWZpY2F0aW9uKVxuICAgICovXG4gICAgc2V0UlBDVHlwZSh0eXBlKSB7XG4gICAgICAgIHRoaXMuX3JwY1R5cGUgPSB0eXBlO1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAqIEByZXR1cm4ge1JwY1R5cGV9IHJwY1R5cGUgLSBBbiBSUEMgRW51bSAgcmVwcmVzZW50aW5nIHRoZSB0eXBlIG9mIFJQQyBiZWluZyBkZXNjcmliZWQgKFJlcXVlc3QsIFJlc3BvbnNlLCBOb3RpZmljYXRpb24pXG4gICAgKi9cbiAgICBnZXRSUENUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcnBjVHlwZTtcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge0Z1bmN0aW9uSUR9IGZ1bmN0aW9uSWQgLSBBIEZ1bmN0aW9uSUQgRW51bSByZXByZXNlbnRpbmcgdGhlIFJQQyBmdW5jdGlvbiB0aGF0IGlzIGJlaW5nIGRlc2NyaWJlZFxuXG4gICAgKi9cbiAgICBzZXRGdW5jdGlvbklkKGlkKSB7XG4gICAgICAgIHRoaXMuX2Z1bmN0aW9uSWQgPSBpZDtcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgKiBAcmV0dXJuIHtGdW5jdGlvbklEfSBmdW5jdGlvbklkIC0gQSBGdW5jdGlvbklEIEVudW0gcmVwcmVzZW50aW5nIHRoZSBSUEMgZnVuY3Rpb24gdGhhdCBpcyBiZWluZyBkZXNjcmliZWRcbiAgICAqL1xuICAgIGdldEZ1bmN0aW9uSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mdW5jdGlvbklkO1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3JyZWxhdGlvbklkIC0gQSBudW1iZXIgcmVwcmVzZW50aW5nIGFuIElEIHRvIGNvcnJlbGF0ZSBhIHJlcXVlc3QgYW5kIHJlc3BvbnNlIHBhaXJcbiAgICAqL1xuICAgIHNldENvcnJlbGF0aW9uSWQoaWQpIHtcbiAgICAgICAgdGhpcy5fY29ycmVsYXRpb25JZCA9IGlkO1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAqIEByZXR1cm4ge051bWJlcn0gY29ycmVsYXRpb25JZCAtIEEgbnVtYmVyIHJlcHJlc2VudGluZyBhbiBJRCB0byBjb3JyZWxhdGUgYSByZXF1ZXN0IGFuZCByZXNwb25zZSBwYWlyXG5cbiAgICAqL1xuICAgIGdldENvcnJlbGF0aW9uSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb3JyZWxhdGlvbklkO1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBzaXplIC0gQSBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBzaXplIG9mIGEgSlNPTiBvYmplY3RcbiAgICAqL1xuICAgIHNldEpTT05TaXplKHNpemUpIHtcbiAgICAgICAgdGhpcy5fanNvblNpemUgPSBzaXplO1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAqIEByZXR1cm4ge051bWJlcn0gLSBBIG51bWJlciByZXByZXNlbnRpbmcgdGhlIHNpemUgb2YgYSBKU09OIG9iamVjdFxuICAgICovXG4gICAgZ2V0SlNPTlNpemUoKSB7XG4gICAgICAgIHJldHVybiBfanNvblNpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge051bWJlcn0gZGF0YSAtIEEgYnl0ZSBhcnJheSByZXByZXNlbnRpbmcgSlNPTiBkYXRhXG4gICAgKi9cbiAgICBzZXRKU09ORGF0YShkYXRhKSB7XG4gICAgICAgIC8vIFRPRE9cbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgKiBAcmV0dXJuIHtVaW50OEFycmF5fSAtIEEgYnl0ZSBhcnJheSByZXByZXNlbnRpbmcgSlNPTiBkYXRhXG4gICAgKi9cbiAgICBnZXRKU09ORGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2pzb25EYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhIC0gQSBieXRlIGFycmF5IHJlcHJlc2VudGluZyBidWxrIGRhdGFcbiAgICAqL1xuICAgIHNldEJ1bGtEYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy5fYnVsa0RhdGEgPSBkYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQHJldHVybiB7VWludDhBcnJheX0gLSBBIGJ5dGUgYXJyYXkgcmVwcmVzZW50aW5nIGJ1bGsgZGF0YVxuICAgICovXG4gICAgZ2V0QnVsa0RhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9idWxrRGF0YTtcbiAgICB9XG5cbn1cblxuZXhwb3J0IHsgQmluYXJ5RnJhbWVIZWFkZXIgfTtcbiIsIi8qXG4qIENvcHlyaWdodCAoYykgMjAxOSwgTGl2aW8sIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4qIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuKlxuKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiogbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4qXG4qIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiogdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiogZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlXG4qIGRpc3RyaWJ1dGlvbi5cbipcbiogTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgTGl2aW8gSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnNcbiogbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4qIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuKlxuKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuKiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4qIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4qIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkVcbiogTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRlxuKiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1NcbiogSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU5cbiogQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcbiogQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiogUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuXG4vKipcbiAqIFRoaXMgY2xhc3Mgd2lsbCBhc3NlbWJsZSB0aGUgZGlmZmVyZW50IHR5cGVzIG9mIG1lc3NhZ2VzXG4gKi9cbmNsYXNzIE1lc3NhZ2VGcmFtZUFzc2VtYmxlcntcblxuICAgIC8qKlxuICAgICogQGNvbnN0cnVjdG9yXG4gICAgKiBAcGFyYW0ge051bWJlcn0gaGVhZGVyU2l6ZVxuICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGhlYWRlclNpemU9OCwgY2FsbGJhY2spe1xuICAgICAgICBpZihjYWxsYmFjayA9PSBudWxsKXtcbiAgICAgICAgICAgIHRocm93IFwiQ2FsbGJhY2sgY2FuJ3QgYmUgbnVsbCBmb3IgTWVzc2FnZUZyYW1lQXNzZW1ibGVyXCI7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRoaXMuX2FjY3VtdWxhdG9yID0gbnVsbDsgLy9UT0RPIGJ5dGUgYXJyYXkgb3V0cHV0IHN0cmVhbVxuICAgICAgICB0aGlzLl9oZWFkZXJzaXplID0gaGVhZGVyU2l6ZTtcbiAgICAgICAgdGhpcy5fdG90YWxTaXplID0gMDtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge1NkbFBhY2tldH0gc2RsUGFja2V0XG4gICAgKi9cbiAgICBoYW5kbGVGcmFtZShzZGxQYWNrZXQpe1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge1NkbFBhY2tldH0gc2RsUGFja2V0XG4gICAgKi9cbiAgICBoYW5kbGVNdWx0aUZyYW1lTWVzc2FnZUZyYW1lKHNkbFBhY2tldCl7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7U2RsUGFja2V0fSBzZGxQYWNrZXRcbiAgICAqL1xuICAgIGhhbmRsZUZpcnN0RGF0YUZyYW1lKHNkbFBhY2tldCl7XG5cbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge1NkbFBhY2tldH0gc2RsUGFja2V0XG4gICAgKi9cbiAgICBoYW5kbGVSZW1haW5pbmdGcmFtZShzZGxQYWNrZXQpe1xuXG4gICAgfVxuXG59XG5cbmV4cG9ydCB7IE1lc3NhZ2VGcmFtZUFzc2VtYmxlciB9OyIsIi8qXG4qIENvcHlyaWdodCAoYykgMjAxOSwgTGl2aW8sIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4qIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuKlxuKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiogbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4qXG4qIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiogdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiogZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlXG4qIGRpc3RyaWJ1dGlvbi5cbipcbiogTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgTGl2aW8gSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnNcbiogbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4qIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuKlxuKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuKiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4qIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4qIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkVcbiogTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRlxuKiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1NcbiogSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU5cbiogQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcbiogQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiogUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuXG5jbGFzcyBFbnVtIHtcblxuICAgIC8qKlxuICAgICogQGNvbnN0cnVjdG9yXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgIH1cblxuICAgIC8qKlxuICAgICogUmV0dXJucyB0aGUga2V5IGZvciBhIGdpdmVuIHZhbHVlIGlmIHRoZSB2YWx1ZSBpcyBmb3VuZCB3aXRoaW4gdGhlIGtleTp2YWx1ZSBtYXBcbiAgICAqIEBwYXJhbSB2YWx1ZSAtIEEgcHJpbWl0aXZlIHZhbHVlIHRvIGZpbmQgaW4gdGhlIG1hcFxuICAgICogQHBhcmFtIG1hcCB7T2JqZWN0fSAtIEFuIG1hcCBvZiBzdHJpbmcgcHJvcGVydGllcyB0byBwcmltaXRpdmUgdmFsdWVzIFxuICAgICogQHJldHVybiB7bnVsbHxTdHJpbmd9IC0gUmV0dXJucyBudWxsIGlmIG5vdCBmb3VuZFxuICAgICovXG4gICAgc3RhdGljIGtleUZvclZhbHVlSW50ZXJuYWwodmFsdWUsIG1hcCkge1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gbWFwKSB7XG4gICAgICAgICAgICBpZiAobWFwW2tleV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogUmV0dXJucyB0aGUgZ2l2ZW4gdmFsdWUgaWYgdGhlIHZhbHVlIGlzIGZvdW5kIHdpdGhpbiB0aGUga2V5OnZhbHVlIG1hcFxuICAgICogQHBhcmFtIHZhbHVlIC0gQSBwcmltaXRpdmUgdmFsdWUgdG8gZmluZCBpbiB0aGUgbWFwXG4gICAgKiBAcGFyYW0gbWFwIHtPYmplY3R9IC0gQW4gbWFwIG9mIHN0cmluZyBwcm9wZXJ0aWVzIHRvIHByaW1pdGl2ZSB2YWx1ZXMgXG4gICAgKiBAcmV0dXJuIHsqfSAtIFJldHVybnMgYSB2YWx1ZSBpZiBmb3VuZCwgb3IgbnVsbCBpZiBub3QgZm91bmRcbiAgICAqL1xuICAgIHN0YXRpYyB2YWx1ZUZvclN0cmluZ0ludGVybmFsKHZhbHVlLCBtYXApIHtcbiAgICAgICAgZm9yIChsZXQga2V5IGluIG1hcCkge1xuICAgICAgICAgICAgaWYgKG1hcFtrZXldID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXBba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQSBtZXRob2QgZm9yIHN1YmNsYXNzZXMgdG8gaW1wbGVtZW50IHRoYXQgZG9lcyB3aGF0IGtleUZvclZhbHVlSW50ZXJuYWwgZG9lc1xuICAgICogQHBhcmFtIHZhbHVlIC0gQSBwcmltaXRpdmUgdmFsdWUgdG8gZmluZCBpbiB0aGUgbWFwIG9mIHRoZSBzdWJjbGFzc1xuICAgICogQHJldHVybiB7Kn0gLSBSZXR1cm5zIGEgdmFsdWUgaWYgZm91bmQsIG9yIG51bGwgaWYgbm90IGZvdW5kXG4gICAgKi9cbiAgICB2YWx1ZUZvclN0cmluZyh2YWx1ZSkge1xuICAgICAgICB0aHJvdyBcIm1ldGhvZCBtdXN0IGJlIG92ZXJyaWRkZW5cIjtcbiAgICB9XG59XG5cbmV4cG9ydCB7IEVudW0gfTsiLCIvKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTksIExpdmlvLCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbipcbiogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4qIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuKlxuKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4qIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4qIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZVxuKiBkaXN0cmlidXRpb24uXG4qXG4qIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIExpdmlvIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzXG4qIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZVxuKiB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbipcbiogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiogQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuKiBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFXG4qIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1JcbiogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcbiogU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXG4qIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOXG4qIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4qIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4qIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cblxuaW1wb3J0IHsgRW51bSB9IGZyb20gJy4uLy4uL3V0aWwvRW51bS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge0VudW19IEZyYW1lVHlwZVxuICogQHByb3BlcnR5IHtPYmplY3R9IE1BUFxuICovXG5jbGFzcyBGcmFtZVR5cGUgZXh0ZW5kcyBFbnVtIHtcblxuICAgIC8qKlxuICAgICogQGNvbnN0cnVjdG9yXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAqL1xuICAgIHN0YXRpYyBnZXQgQ09OVFJPTCgpIHtcbiAgICAgICAgcmV0dXJuIEZyYW1lVHlwZS5NQVAuQ09OVFJPTDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAqL1xuICAgIHN0YXRpYyBnZXQgRklSU1QoKSB7XG4gICAgICAgIHJldHVybiBGcmFtZVR5cGUuTUFQLkZJUlNUO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICovXG4gICAgc3RhdGljIGdldCBDT05TRUNVVElWRSgpIHtcbiAgICAgICAgcmV0dXJuIEZyYW1lVHlwZS5NQVAuQ09OU0VDVVRJVkU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgKi9cbiAgICBzdGF0aWMgZ2V0IFNJTkdMRSgpIHtcbiAgICAgICAgcmV0dXJuIEZyYW1lVHlwZS5NQVAuU0lOR0xFO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQ29uZmlybXMgd2hldGhlciB0aGUgdmFsdWUgcGFzc2VkIGluIGV4aXN0cyBpbiB0aGUgRW51bXMgb2YgdGhpcyBjbGFzc1xuICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgKiBAcmV0dXJuIHtudWxsfE51bWJlcn0gLSBSZXR1cm5zIG51bGwgaWYgdGhlIGVudW0gdmFsdWUgZG9lc24ndCBleGlzdFxuICAgICovXG4gICAgc3RhdGljIHZhbHVlRm9yU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBGcmFtZVR5cGUuTUFQKSB7XG4gICAgICAgICAgICBpZiAoRnJhbWVUeXBlLk1BUFtrZXldID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBGcmFtZVR5cGUuTUFQW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbkZyYW1lVHlwZS5NQVAgPSBPYmplY3QuZnJlZXplKHtcbiAgJ0NPTlRST0wnOiAweDAwLFxuICAnRklSU1QnOiAweDAyLFxuICAnQ09OU0VDVVRJVkUnOiAweDAzLFxuICAnU0lOR0xFJzogMHgwMSxcbn0pO1xuXG5leHBvcnQgeyBGcmFtZVR5cGUgfTtcbiIsImV4cG9ydHNbXCJic29uXCJdID1cbi8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbi8qKioqKiovIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbi8qKioqKiovIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbi8qKioqKiovIFx0XHRcdH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAyKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xufSBjYXRjaChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXG5cdFx0ZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuXG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuXG5cbnZhciBiYXNlNjQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpXG52YXIgaWVlZTc1NCA9IF9fd2VicGFja19yZXF1aXJlX18oNClcbnZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oMCkpKVxuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCwgQnVmZmVyKSB7KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0IHRydWUgPyBmYWN0b3J5KGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oNiksIF9fd2VicGFja19yZXF1aXJlX18oMSkpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdsb25nJywgJ2J1ZmZlciddLCBmYWN0b3J5KSA6XG5cdChmYWN0b3J5KChnbG9iYWwuQlNPTiA9IHt9KSxnbG9iYWwubG9uZyxnbG9iYWwuQnVmZmVyKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cyxsb25nLGJ1ZmZlcikgeyAndXNlIHN0cmljdCc7XG5cblx0bG9uZyA9IGxvbmcgJiYgbG9uZy5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdCcpID8gbG9uZ1snZGVmYXVsdCddIDogbG9uZztcblx0YnVmZmVyID0gYnVmZmVyICYmIGJ1ZmZlci5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdCcpID8gYnVmZmVyWydkZWZhdWx0J10gOiBidWZmZXI7XG5cblx0dmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxuXHRmdW5jdGlvbiBjcmVhdGVDb21tb25qc01vZHVsZShmbiwgbW9kdWxlKSB7XG5cdFx0cmV0dXJuIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Q2pzRXhwb3J0RnJvbU5hbWVzcGFjZSAobikge1xuXHRcdHJldHVybiBuICYmIG4uZGVmYXVsdCB8fCBuO1xuXHR9XG5cblx0dmFyIG1hcCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcblxuXHQgIGlmICh0eXBlb2YgY29tbW9uanNHbG9iYWwuTWFwICE9PSAndW5kZWZpbmVkJykge1xuXHQgICAgbW9kdWxlLmV4cG9ydHMgPSBjb21tb25qc0dsb2JhbC5NYXA7XG5cdCAgICBtb2R1bGUuZXhwb3J0cy5NYXAgPSBjb21tb25qc0dsb2JhbC5NYXA7XG5cdCAgfSBlbHNlIHtcblx0ICAgIC8vIFdlIHdpbGwgcmV0dXJuIGEgcG9seWZpbGxcblx0ICAgIHZhciBNYXAgPSBmdW5jdGlvbiBNYXAoYXJyYXkpIHtcblx0ICAgICAgdGhpcy5fa2V5cyA9IFtdO1xuXHQgICAgICB0aGlzLl92YWx1ZXMgPSB7fTtcblxuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgaWYgKGFycmF5W2ldID09IG51bGwpIGNvbnRpbnVlOyAvLyBza2lwIG51bGwgYW5kIHVuZGVmaW5lZFxuXG5cdCAgICAgICAgdmFyIGVudHJ5ID0gYXJyYXlbaV07XG5cdCAgICAgICAgdmFyIGtleSA9IGVudHJ5WzBdO1xuXHQgICAgICAgIHZhciB2YWx1ZSA9IGVudHJ5WzFdOyAvLyBBZGQgdGhlIGtleSB0byB0aGUgbGlzdCBvZiBrZXlzIGluIG9yZGVyXG5cblx0ICAgICAgICB0aGlzLl9rZXlzLnB1c2goa2V5KTsgLy8gQWRkIHRoZSBrZXkgYW5kIHZhbHVlIHRvIHRoZSB2YWx1ZXMgZGljdGlvbmFyeSB3aXRoIGEgcG9pbnRcblx0ICAgICAgICAvLyB0byB0aGUgbG9jYXRpb24gaW4gdGhlIG9yZGVyZWQga2V5cyBsaXN0XG5cblxuXHQgICAgICAgIHRoaXMuX3ZhbHVlc1trZXldID0ge1xuXHQgICAgICAgICAgdjogdmFsdWUsXG5cdCAgICAgICAgICBpOiB0aGlzLl9rZXlzLmxlbmd0aCAtIDFcblx0ICAgICAgICB9O1xuXHQgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICBNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICB0aGlzLl9rZXlzID0gW107XG5cdCAgICAgIHRoaXMuX3ZhbHVlcyA9IHt9O1xuXHQgICAgfTtcblxuXHQgICAgTWFwLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX3ZhbHVlc1trZXldO1xuXHQgICAgICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIGZhbHNlOyAvLyBEZWxldGUgZW50cnlcblxuXHQgICAgICBkZWxldGUgdGhpcy5fdmFsdWVzW2tleV07IC8vIFJlbW92ZSB0aGUga2V5IGZyb20gdGhlIG9yZGVyZWQga2V5cyBsaXN0XG5cblx0ICAgICAgdGhpcy5fa2V5cy5zcGxpY2UodmFsdWUuaSwgMSk7XG5cblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9O1xuXG5cdCAgICBNYXAucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHZhciBzZWxmID0gdGhpcztcblx0ICAgICAgdmFyIGluZGV4ID0gMDtcblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuXHQgICAgICAgICAgdmFyIGtleSA9IHNlbGYuX2tleXNbaW5kZXgrK107XG5cdCAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICB2YWx1ZToga2V5ICE9PSB1bmRlZmluZWQgPyBba2V5LCBzZWxmLl92YWx1ZXNba2V5XS52XSA6IHVuZGVmaW5lZCxcblx0ICAgICAgICAgICAgZG9uZToga2V5ICE9PSB1bmRlZmluZWQgPyBmYWxzZSA6IHRydWVcblx0ICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgICB9O1xuXHQgICAgfTtcblxuXHQgICAgTWFwLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBzZWxmKSB7XG5cdCAgICAgIHNlbGYgPSBzZWxmIHx8IHRoaXM7XG5cblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9rZXlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdmFyIGtleSA9IHRoaXMuX2tleXNbaV07IC8vIENhbGwgdGhlIGZvckVhY2ggY2FsbGJhY2tcblxuXHQgICAgICAgIGNhbGxiYWNrLmNhbGwoc2VsZiwgdGhpcy5fdmFsdWVzW2tleV0udiwga2V5LCBzZWxmKTtcblx0ICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl92YWx1ZXNba2V5XSA/IHRoaXMuX3ZhbHVlc1trZXldLnYgOiB1bmRlZmluZWQ7XG5cdCAgICB9O1xuXG5cdCAgICBNYXAucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlc1trZXldICE9IG51bGw7XG5cdCAgICB9O1xuXG5cdCAgICBNYXAucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHZhciBzZWxmID0gdGhpcztcblx0ICAgICAgdmFyIGluZGV4ID0gMDtcblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuXHQgICAgICAgICAgdmFyIGtleSA9IHNlbGYuX2tleXNbaW5kZXgrK107XG5cdCAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICB2YWx1ZToga2V5ICE9PSB1bmRlZmluZWQgPyBrZXkgOiB1bmRlZmluZWQsXG5cdCAgICAgICAgICAgIGRvbmU6IGtleSAhPT0gdW5kZWZpbmVkID8gZmFsc2UgOiB0cnVlXG5cdCAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblx0ICAgICAgfTtcblx0ICAgIH07XG5cblx0ICAgIE1hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblx0ICAgICAgaWYgKHRoaXMuX3ZhbHVlc1trZXldKSB7XG5cdCAgICAgICAgdGhpcy5fdmFsdWVzW2tleV0udiA9IHZhbHVlO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICB9IC8vIEFkZCB0aGUga2V5IHRvIHRoZSBsaXN0IG9mIGtleXMgaW4gb3JkZXJcblxuXG5cdCAgICAgIHRoaXMuX2tleXMucHVzaChrZXkpOyAvLyBBZGQgdGhlIGtleSBhbmQgdmFsdWUgdG8gdGhlIHZhbHVlcyBkaWN0aW9uYXJ5IHdpdGggYSBwb2ludFxuXHQgICAgICAvLyB0byB0aGUgbG9jYXRpb24gaW4gdGhlIG9yZGVyZWQga2V5cyBsaXN0XG5cblxuXHQgICAgICB0aGlzLl92YWx1ZXNba2V5XSA9IHtcblx0ICAgICAgICB2OiB2YWx1ZSxcblx0ICAgICAgICBpOiB0aGlzLl9rZXlzLmxlbmd0aCAtIDFcblx0ICAgICAgfTtcblx0ICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXG5cdCAgICBNYXAucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgICAgICB2YXIgaW5kZXggPSAwO1xuXHQgICAgICByZXR1cm4ge1xuXHQgICAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG5cdCAgICAgICAgICB2YXIga2V5ID0gc2VsZi5fa2V5c1tpbmRleCsrXTtcblx0ICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIHZhbHVlOiBrZXkgIT09IHVuZGVmaW5lZCA/IHNlbGYuX3ZhbHVlc1trZXldLnYgOiB1bmRlZmluZWQsXG5cdCAgICAgICAgICAgIGRvbmU6IGtleSAhPT0gdW5kZWZpbmVkID8gZmFsc2UgOiB0cnVlXG5cdCAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblx0ICAgICAgfTtcblx0ICAgIH07IC8vIExhc3QgaXNtYXN0ZXJcblxuXG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWFwLnByb3RvdHlwZSwgJ3NpemUnLCB7XG5cdCAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9rZXlzLmxlbmd0aDtcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICBtb2R1bGUuZXhwb3J0cyA9IE1hcDtcblx0ICB9XG5cdH0pO1xuXHR2YXIgbWFwXzEgPSBtYXAuTWFwO1xuXG5cdC8qKlxuXHQgKiBAaWdub3JlXG5cdCAqL1xuXG5cblx0bG9uZy5wcm90b3R5cGUudG9FeHRlbmRlZEpTT04gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHQgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVsYXhlZCkgcmV0dXJuIHRoaXMudG9OdW1iZXIoKTtcblx0ICByZXR1cm4ge1xuXHQgICAgJG51bWJlckxvbmc6IHRoaXMudG9TdHJpbmcoKVxuXHQgIH07XG5cdH07XG5cdC8qKlxuXHQgKiBAaWdub3JlXG5cdCAqL1xuXG5cblx0bG9uZy5mcm9tRXh0ZW5kZWRKU09OID0gZnVuY3Rpb24gKGRvYywgb3B0aW9ucykge1xuXHQgIHZhciByZXN1bHQgPSBsb25nLmZyb21TdHJpbmcoZG9jLiRudW1iZXJMb25nKTtcblx0ICByZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLnJlbGF4ZWQgPyByZXN1bHQudG9OdW1iZXIoKSA6IHJlc3VsdDtcblx0fTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkobG9uZy5wcm90b3R5cGUsICdfYnNvbnR5cGUnLCB7XG5cdCAgdmFsdWU6ICdMb25nJ1xuXHR9KTtcblx0dmFyIGxvbmdfMSA9IGxvbmc7XG5cblx0LyoqXG5cdCAqIEEgY2xhc3MgcmVwcmVzZW50YXRpb24gb2YgdGhlIEJTT04gRG91YmxlIHR5cGUuXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cblx0ZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5cdGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cblx0dmFyIERvdWJsZSA9XG5cdC8qI19fUFVSRV9fKi9cblx0ZnVuY3Rpb24gKCkge1xuXHQgIC8qKlxuXHQgICAqIENyZWF0ZSBhIERvdWJsZSB0eXBlXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgdGhlIG51bWJlciB3ZSB3YW50IHRvIHJlcHJlc2VudCBhcyBhIGRvdWJsZS5cblx0ICAgKiBAcmV0dXJuIHtEb3VibGV9XG5cdCAgICovXG5cdCAgZnVuY3Rpb24gRG91YmxlKHZhbHVlKSB7XG5cdCAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRG91YmxlKTtcblxuXHQgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuXHQgIH1cblx0ICAvKipcblx0ICAgKiBBY2Nlc3MgdGhlIG51bWJlciB2YWx1ZS5cblx0ICAgKlxuXHQgICAqIEBtZXRob2Rcblx0ICAgKiBAcmV0dXJuIHtudW1iZXJ9IHJldHVybnMgdGhlIHdyYXBwZWQgZG91YmxlIG51bWJlci5cblx0ICAgKi9cblxuXG5cdCAgX2NyZWF0ZUNsYXNzKERvdWJsZSwgW3tcblx0ICAgIGtleTogXCJ2YWx1ZU9mXCIsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWVPZigpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIEBpZ25vcmVcblx0ICAgICAqL1xuXG5cdCAgfSwge1xuXHQgICAga2V5OiBcInRvSlNPTlwiLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIEBpZ25vcmVcblx0ICAgICAqL1xuXG5cdCAgfSwge1xuXHQgICAga2V5OiBcInRvRXh0ZW5kZWRKU09OXCIsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gdG9FeHRlbmRlZEpTT04ob3B0aW9ucykge1xuXHQgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlbGF4ZWQgJiYgaXNGaW5pdGUodGhpcy52YWx1ZSkpIHJldHVybiB0aGlzLnZhbHVlO1xuXHQgICAgICByZXR1cm4ge1xuXHQgICAgICAgICRudW1iZXJEb3VibGU6IHRoaXMudmFsdWUudG9TdHJpbmcoKVxuXHQgICAgICB9O1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBAaWdub3JlXG5cdCAgICAgKi9cblxuXHQgIH1dLCBbe1xuXHQgICAga2V5OiBcImZyb21FeHRlbmRlZEpTT05cIixcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tRXh0ZW5kZWRKU09OKGRvYywgb3B0aW9ucykge1xuXHQgICAgICByZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLnJlbGF4ZWQgPyBwYXJzZUZsb2F0KGRvYy4kbnVtYmVyRG91YmxlKSA6IG5ldyBEb3VibGUocGFyc2VGbG9hdChkb2MuJG51bWJlckRvdWJsZSkpO1xuXHQgICAgfVxuXHQgIH1dKTtcblxuXHQgIHJldHVybiBEb3VibGU7XG5cdH0oKTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoRG91YmxlLnByb3RvdHlwZSwgJ19ic29udHlwZScsIHtcblx0ICB2YWx1ZTogJ0RvdWJsZSdcblx0fSk7XG5cdHZhciBkb3VibGVfMSA9IERvdWJsZTtcblxuXHRmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5cdGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayQxKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuXHRmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyQxKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuXHRmdW5jdGlvbiBfY3JlYXRlQ2xhc3MkMShDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzJDEoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyQxKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5cdGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuXHRmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuXHRmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cblx0ZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuXHRmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXHQvKipcblx0ICogQGNsYXNzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBsb3cgIHRoZSBsb3cgKHNpZ25lZCkgMzIgYml0cyBvZiB0aGUgVGltZXN0YW1wLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaGlnaCB0aGUgaGlnaCAoc2lnbmVkKSAzMiBiaXRzIG9mIHRoZSBUaW1lc3RhbXAuXG5cdCAqIEByZXR1cm4ge1RpbWVzdGFtcH1cblx0ICovXG5cblxuXHR2YXIgVGltZXN0YW1wID1cblx0LyojX19QVVJFX18qL1xuXHRmdW5jdGlvbiAoX0xvbmcpIHtcblx0ICBfaW5oZXJpdHMoVGltZXN0YW1wLCBfTG9uZyk7XG5cblx0ICBmdW5jdGlvbiBUaW1lc3RhbXAobG93LCBoaWdoKSB7XG5cdCAgICB2YXIgX3RoaXM7XG5cblx0ICAgIF9jbGFzc0NhbGxDaGVjayQxKHRoaXMsIFRpbWVzdGFtcCk7XG5cblx0ICAgIGlmIChsb25nXzEuaXNMb25nKGxvdykpIHtcblx0ICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoVGltZXN0YW1wKS5jYWxsKHRoaXMsIGxvdy5sb3csIGxvdy5oaWdoKSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihUaW1lc3RhbXApLmNhbGwodGhpcywgbG93LCBoaWdoKSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcyk7XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIFJldHVybiB0aGUgSlNPTiB2YWx1ZS5cblx0ICAgKlxuXHQgICAqIEBtZXRob2Rcblx0ICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBKU09OIHJlcHJlc2VudGF0aW9uLlxuXHQgICAqL1xuXG5cblx0ICBfY3JlYXRlQ2xhc3MkMShUaW1lc3RhbXAsIFt7XG5cdCAgICBrZXk6IFwidG9KU09OXCIsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuXHQgICAgICByZXR1cm4ge1xuXHQgICAgICAgICR0aW1lc3RhbXA6IHRoaXMudG9TdHJpbmcoKVxuXHQgICAgICB9O1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBSZXR1cm5zIGEgVGltZXN0YW1wIHJlcHJlc2VudGVkIGJ5IHRoZSBnaXZlbiAoMzItYml0KSBpbnRlZ2VyIHZhbHVlLlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2Rcblx0ICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSB0aGUgMzItYml0IGludGVnZXIgaW4gcXVlc3Rpb24uXG5cdCAgICAgKiBAcmV0dXJuIHtUaW1lc3RhbXB9IHRoZSB0aW1lc3RhbXAuXG5cdCAgICAgKi9cblxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJ0b0V4dGVuZGVkSlNPTlwiLFxuXG5cdCAgICAvKipcblx0ICAgICAqIEBpZ25vcmVcblx0ICAgICAqL1xuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHRvRXh0ZW5kZWRKU09OKCkge1xuXHQgICAgICByZXR1cm4ge1xuXHQgICAgICAgICR0aW1lc3RhbXA6IHtcblx0ICAgICAgICAgIHQ6IHRoaXMuaGlnaCxcblx0ICAgICAgICAgIGk6IHRoaXMubG93XG5cdCAgICAgICAgfVxuXHQgICAgICB9O1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBAaWdub3JlXG5cdCAgICAgKi9cblxuXHQgIH1dLCBbe1xuXHQgICAga2V5OiBcImZyb21JbnRcIixcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tSW50KHZhbHVlKSB7XG5cdCAgICAgIHJldHVybiBuZXcgVGltZXN0YW1wKGxvbmdfMS5mcm9tSW50KHZhbHVlKSk7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIFJldHVybnMgYSBUaW1lc3RhbXAgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiBudW1iZXIgdmFsdWUsIHByb3ZpZGVkIHRoYXQgaXQgaXMgYSBmaW5pdGUgbnVtYmVyLiBPdGhlcndpc2UsIHplcm8gaXMgcmV0dXJuZWQuXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZFxuXHQgICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIHRoZSBudW1iZXIgaW4gcXVlc3Rpb24uXG5cdCAgICAgKiBAcmV0dXJuIHtUaW1lc3RhbXB9IHRoZSB0aW1lc3RhbXAuXG5cdCAgICAgKi9cblxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJmcm9tTnVtYmVyXCIsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbU51bWJlcih2YWx1ZSkge1xuXHQgICAgICByZXR1cm4gbmV3IFRpbWVzdGFtcChsb25nXzEuZnJvbU51bWJlcih2YWx1ZSkpO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBSZXR1cm5zIGEgVGltZXN0YW1wIGZvciB0aGUgZ2l2ZW4gaGlnaCBhbmQgbG93IGJpdHMuIEVhY2ggaXMgYXNzdW1lZCB0byB1c2UgMzIgYml0cy5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kXG5cdCAgICAgKiBAcGFyYW0ge251bWJlcn0gbG93Qml0cyB0aGUgbG93IDMyLWJpdHMuXG5cdCAgICAgKiBAcGFyYW0ge251bWJlcn0gaGlnaEJpdHMgdGhlIGhpZ2ggMzItYml0cy5cblx0ICAgICAqIEByZXR1cm4ge1RpbWVzdGFtcH0gdGhlIHRpbWVzdGFtcC5cblx0ICAgICAqL1xuXG5cdCAgfSwge1xuXHQgICAga2V5OiBcImZyb21CaXRzXCIsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUJpdHMobG93Qml0cywgaGlnaEJpdHMpIHtcblx0ICAgICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAobG93Qml0cywgaGlnaEJpdHMpO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBSZXR1cm5zIGEgVGltZXN0YW1wIGZyb20gdGhlIGdpdmVuIHN0cmluZywgb3B0aW9uYWxseSB1c2luZyB0aGUgZ2l2ZW4gcmFkaXguXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZFxuXHQgICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciB0aGUgdGV4dHVhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgVGltZXN0YW1wLlxuXHQgICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRfcmFkaXhdIHRoZSByYWRpeCBpbiB3aGljaCB0aGUgdGV4dCBpcyB3cml0dGVuLlxuXHQgICAgICogQHJldHVybiB7VGltZXN0YW1wfSB0aGUgdGltZXN0YW1wLlxuXHQgICAgICovXG5cblx0ICB9LCB7XG5cdCAgICBrZXk6IFwiZnJvbVN0cmluZ1wiLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21TdHJpbmcoc3RyLCBvcHRfcmFkaXgpIHtcblx0ICAgICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAobG9uZ18xLmZyb21TdHJpbmcoc3RyLCBvcHRfcmFkaXgpKTtcblx0ICAgIH1cblx0ICB9LCB7XG5cdCAgICBrZXk6IFwiZnJvbUV4dGVuZGVkSlNPTlwiLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21FeHRlbmRlZEpTT04oZG9jKSB7XG5cdCAgICAgIHJldHVybiBuZXcgVGltZXN0YW1wKGRvYy4kdGltZXN0YW1wLmksIGRvYy4kdGltZXN0YW1wLnQpO1xuXHQgICAgfVxuXHQgIH1dKTtcblxuXHQgIHJldHVybiBUaW1lc3RhbXA7XG5cdH0obG9uZ18xKTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoVGltZXN0YW1wLnByb3RvdHlwZSwgJ19ic29udHlwZScsIHtcblx0ICB2YWx1ZTogJ1RpbWVzdGFtcCdcblx0fSk7XG5cdHZhciB0aW1lc3RhbXAgPSBUaW1lc3RhbXA7XG5cblx0dmFyIGVtcHR5ID0ge307XG5cblx0dmFyIGVtcHR5JDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdFx0ZGVmYXVsdDogZW1wdHlcblx0fSk7XG5cblx0dmFyIHJlcXVpcmUkJDAgPSBnZXRDanNFeHBvcnRGcm9tTmFtZXNwYWNlKGVtcHR5JDEpO1xuXG5cdC8qIGdsb2JhbCB3aW5kb3cgKi9cblxuXHQvKipcblx0ICogTm9ybWFsaXplcyBvdXIgZXhwZWN0ZWQgc3RyaW5naWZpZWQgZm9ybSBvZiBhIGZ1bmN0aW9uIGFjcm9zcyB2ZXJzaW9ucyBvZiBub2RlXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBzdHJpbmdpZnlcblx0ICovXG5cblxuXHRmdW5jdGlvbiBub3JtYWxpemVkRnVuY3Rpb25TdHJpbmcoZm4pIHtcblx0ICByZXR1cm4gZm4udG9TdHJpbmcoKS5yZXBsYWNlKCdmdW5jdGlvbignLCAnZnVuY3Rpb24gKCcpO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW5zZWN1cmVSYW5kb21CeXRlcyhzaXplKSB7XG5cdCAgdmFyIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcblx0ICAgIHJlc3VsdFtpXSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDI1Nik7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdHZhciByYW5kb21CeXRlcyA9IGluc2VjdXJlUmFuZG9tQnl0ZXM7XG5cblx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jcnlwdG8gJiYgd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcblx0ICByYW5kb21CeXRlcyA9IGZ1bmN0aW9uIHJhbmRvbUJ5dGVzKHNpemUpIHtcblx0ICAgIHJldHVybiB3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShzaXplKSk7XG5cdCAgfTtcblx0fSBlbHNlIHtcblx0ICB0cnkge1xuXHQgICAgcmFuZG9tQnl0ZXMgPSByZXF1aXJlJCQwLnJhbmRvbUJ5dGVzO1xuXHQgIH0gY2F0Y2ggKGUpIHt9IC8vIGtlZXAgdGhlIGZhbGxiYWNrXG5cdCAgLy8gTk9URTogaW4gdHJhbnNwaWxlZCBjYXNlcyB0aGUgYWJvdmUgcmVxdWlyZSBtaWdodCByZXR1cm4gbnVsbC91bmRlZmluZWRcblxuXG5cdCAgaWYgKHJhbmRvbUJ5dGVzID09IG51bGwpIHtcblx0ICAgIHJhbmRvbUJ5dGVzID0gaW5zZWN1cmVSYW5kb21CeXRlcztcblx0ICB9XG5cdH1cblxuXHR2YXIgdXRpbHMgPSB7XG5cdCAgbm9ybWFsaXplZEZ1bmN0aW9uU3RyaW5nOiBub3JtYWxpemVkRnVuY3Rpb25TdHJpbmcsXG5cdCAgcmFuZG9tQnl0ZXM6IHJhbmRvbUJ5dGVzXG5cdH07XG5cblx0Ly8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cdC8vIGJhc2VkIG9mZiBodHRwczovL2dpdGh1Yi5jb20vZGVmdW5jdHpvbWJpZS9ub2RlLXByb2Nlc3MvYmxvYi9tYXN0ZXIvYnJvd3Nlci5qc1xuXHRmdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuXHQgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCgpIHtcblx0ICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xuXHR9XG5cblx0dmFyIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuXHR2YXIgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcblxuXHRpZiAodHlwZW9mIGdsb2JhbC5zZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG5cdH1cblxuXHRpZiAodHlwZW9mIGdsb2JhbC5jbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcblx0ICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG5cdH1cblxuXHRmdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuXHQgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG5cdCAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcblx0ICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG5cdCAgfSAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuXG5cblx0ICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcblx0ICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuXHQgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcblx0ICB9XG5cblx0ICB0cnkge1xuXHQgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuXHQgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcblx0ICB9IGNhdGNoIChlKSB7XG5cdCAgICB0cnkge1xuXHQgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcblx0ICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuXHQgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuXHQgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuXHQgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuXHQgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG5cdCAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG5cdCAgfSAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG5cblxuXHQgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuXHQgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuXHQgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuXHQgIH1cblxuXHQgIHRyeSB7XG5cdCAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG5cdCAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG5cdCAgfSBjYXRjaCAoZSkge1xuXHQgICAgdHJ5IHtcblx0ICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuXHQgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcblx0ICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG5cdCAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcblx0ICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0dmFyIHF1ZXVlID0gW107XG5cdHZhciBkcmFpbmluZyA9IGZhbHNlO1xuXHR2YXIgY3VycmVudFF1ZXVlO1xuXHR2YXIgcXVldWVJbmRleCA9IC0xO1xuXG5cdGZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcblx0ICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cblx0ICBkcmFpbmluZyA9IGZhbHNlO1xuXG5cdCAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcblx0ICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHF1ZXVlSW5kZXggPSAtMTtcblx0ICB9XG5cblx0ICBpZiAocXVldWUubGVuZ3RoKSB7XG5cdCAgICBkcmFpblF1ZXVlKCk7XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcblx0ICBpZiAoZHJhaW5pbmcpIHtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cblx0ICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcblx0ICBkcmFpbmluZyA9IHRydWU7XG5cdCAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcblxuXHQgIHdoaWxlIChsZW4pIHtcblx0ICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuXHQgICAgcXVldWUgPSBbXTtcblxuXHQgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuXHQgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG5cdCAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHF1ZXVlSW5kZXggPSAtMTtcblx0ICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcblx0ICB9XG5cblx0ICBjdXJyZW50UXVldWUgPSBudWxsO1xuXHQgIGRyYWluaW5nID0gZmFsc2U7XG5cdCAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXHR9XG5cblx0ZnVuY3Rpb24gbmV4dFRpY2soZnVuKSB7XG5cdCAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuXG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG5cdCAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHQgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuXG5cdCAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcblx0ICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG5cdCAgfVxuXHR9IC8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcblxuXHRmdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcblx0ICB0aGlzLmZ1biA9IGZ1bjtcblx0ICB0aGlzLmFycmF5ID0gYXJyYXk7XG5cdH1cblxuXHRJdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG5cdH07XG5cblx0dmFyIHRpdGxlID0gJ2Jyb3dzZXInO1xuXHR2YXIgcGxhdGZvcm0gPSAnYnJvd3Nlcic7XG5cdHZhciBicm93c2VyID0gdHJ1ZTtcblx0dmFyIGVudiA9IHt9O1xuXHR2YXIgYXJndiA9IFtdO1xuXHR2YXIgdmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xuXG5cdHZhciB2ZXJzaW9ucyA9IHt9O1xuXHR2YXIgcmVsZWFzZSA9IHt9O1xuXHR2YXIgY29uZmlnID0ge307XG5cblx0ZnVuY3Rpb24gbm9vcCgpIHt9XG5cblx0dmFyIG9uID0gbm9vcDtcblx0dmFyIGFkZExpc3RlbmVyID0gbm9vcDtcblx0dmFyIG9uY2UgPSBub29wO1xuXHR2YXIgb2ZmID0gbm9vcDtcblx0dmFyIHJlbW92ZUxpc3RlbmVyID0gbm9vcDtcblx0dmFyIHJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5cdHZhciBlbWl0ID0gbm9vcDtcblx0ZnVuY3Rpb24gYmluZGluZyhuYW1lKSB7XG5cdCAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xuXHR9XG5cdGZ1bmN0aW9uIGN3ZCgpIHtcblx0ICByZXR1cm4gJy8nO1xuXHR9XG5cdGZ1bmN0aW9uIGNoZGlyKGRpcikge1xuXHQgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG5cdH1cblx0ZnVuY3Rpb24gdW1hc2soKSB7XG5cdCAgcmV0dXJuIDA7XG5cdH0gLy8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20va3VtYXZpcy9icm93c2VyLXByb2Nlc3MtaHJ0aW1lL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG5cblx0dmFyIHBlcmZvcm1hbmNlID0gZ2xvYmFsLnBlcmZvcm1hbmNlIHx8IHt9O1xuXG5cdHZhciBwZXJmb3JtYW5jZU5vdyA9IHBlcmZvcm1hbmNlLm5vdyB8fCBwZXJmb3JtYW5jZS5tb3pOb3cgfHwgcGVyZm9ybWFuY2UubXNOb3cgfHwgcGVyZm9ybWFuY2Uub05vdyB8fCBwZXJmb3JtYW5jZS53ZWJraXROb3cgfHwgZnVuY3Rpb24gKCkge1xuXHQgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblx0fTsgLy8gZ2VuZXJhdGUgdGltZXN0YW1wIG9yIGRlbHRhXG5cdC8vIHNlZSBodHRwOi8vbm9kZWpzLm9yZy9hcGkvcHJvY2Vzcy5odG1sI3Byb2Nlc3NfcHJvY2Vzc19ocnRpbWVcblxuXG5cdGZ1bmN0aW9uIGhydGltZShwcmV2aW91c1RpbWVzdGFtcCkge1xuXHQgIHZhciBjbG9ja3RpbWUgPSBwZXJmb3JtYW5jZU5vdy5jYWxsKHBlcmZvcm1hbmNlKSAqIDFlLTM7XG5cdCAgdmFyIHNlY29uZHMgPSBNYXRoLmZsb29yKGNsb2NrdGltZSk7XG5cdCAgdmFyIG5hbm9zZWNvbmRzID0gTWF0aC5mbG9vcihjbG9ja3RpbWUgJSAxICogMWU5KTtcblxuXHQgIGlmIChwcmV2aW91c1RpbWVzdGFtcCkge1xuXHQgICAgc2Vjb25kcyA9IHNlY29uZHMgLSBwcmV2aW91c1RpbWVzdGFtcFswXTtcblx0ICAgIG5hbm9zZWNvbmRzID0gbmFub3NlY29uZHMgLSBwcmV2aW91c1RpbWVzdGFtcFsxXTtcblxuXHQgICAgaWYgKG5hbm9zZWNvbmRzIDwgMCkge1xuXHQgICAgICBzZWNvbmRzLS07XG5cdCAgICAgIG5hbm9zZWNvbmRzICs9IDFlOTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gW3NlY29uZHMsIG5hbm9zZWNvbmRzXTtcblx0fVxuXHR2YXIgc3RhcnRUaW1lID0gbmV3IERhdGUoKTtcblx0ZnVuY3Rpb24gdXB0aW1lKCkge1xuXHQgIHZhciBjdXJyZW50VGltZSA9IG5ldyBEYXRlKCk7XG5cdCAgdmFyIGRpZiA9IGN1cnJlbnRUaW1lIC0gc3RhcnRUaW1lO1xuXHQgIHJldHVybiBkaWYgLyAxMDAwO1xuXHR9XG5cdHZhciBwcm9jZXNzID0ge1xuXHQgIG5leHRUaWNrOiBuZXh0VGljayxcblx0ICB0aXRsZTogdGl0bGUsXG5cdCAgYnJvd3NlcjogYnJvd3Nlcixcblx0ICBlbnY6IGVudixcblx0ICBhcmd2OiBhcmd2LFxuXHQgIHZlcnNpb246IHZlcnNpb24sXG5cdCAgdmVyc2lvbnM6IHZlcnNpb25zLFxuXHQgIG9uOiBvbixcblx0ICBhZGRMaXN0ZW5lcjogYWRkTGlzdGVuZXIsXG5cdCAgb25jZTogb25jZSxcblx0ICBvZmY6IG9mZixcblx0ICByZW1vdmVMaXN0ZW5lcjogcmVtb3ZlTGlzdGVuZXIsXG5cdCAgcmVtb3ZlQWxsTGlzdGVuZXJzOiByZW1vdmVBbGxMaXN0ZW5lcnMsXG5cdCAgZW1pdDogZW1pdCxcblx0ICBiaW5kaW5nOiBiaW5kaW5nLFxuXHQgIGN3ZDogY3dkLFxuXHQgIGNoZGlyOiBjaGRpcixcblx0ICB1bWFzazogdW1hc2ssXG5cdCAgaHJ0aW1lOiBocnRpbWUsXG5cdCAgcGxhdGZvcm06IHBsYXRmb3JtLFxuXHQgIHJlbGVhc2U6IHJlbGVhc2UsXG5cdCAgY29uZmlnOiBjb25maWcsXG5cdCAgdXB0aW1lOiB1cHRpbWVcblx0fTtcblxuXHR2YXIgaW5oZXJpdHM7XG5cblx0aWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgaW5oZXJpdHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcblx0ICAgIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG5cdCAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3Rvcjtcblx0ICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG5cdCAgICAgIGNvbnN0cnVjdG9yOiB7XG5cdCAgICAgICAgdmFsdWU6IGN0b3IsXG5cdCAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG5cdCAgICAgICAgd3JpdGFibGU6IHRydWUsXG5cdCAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgIH07XG5cdH0gZWxzZSB7XG5cdCAgaW5oZXJpdHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcblx0ICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuXG5cdCAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiBUZW1wQ3RvcigpIHt9O1xuXG5cdCAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlO1xuXHQgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKTtcblx0ICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3Rvcjtcblx0ICB9O1xuXHR9XG5cblx0dmFyIGluaGVyaXRzJDEgPSBpbmhlcml0cztcblxuXHRmdW5jdGlvbiBfdHlwZW9mJDEob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mJDEgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiQxID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2YkMShvYmopOyB9XG5cdHZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuXHRmdW5jdGlvbiBmb3JtYXQoZikge1xuXHQgIGlmICghaXNTdHJpbmcoZikpIHtcblx0ICAgIHZhciBvYmplY3RzID0gW107XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG5cdCAgfVxuXG5cdCAgdmFyIGkgPSAxO1xuXHQgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuXHQgIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcblx0ICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbiAoeCkge1xuXHQgICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG5cdCAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuXG5cdCAgICBzd2l0Y2ggKHgpIHtcblx0ICAgICAgY2FzZSAnJXMnOlxuXHQgICAgICAgIHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcblxuXHQgICAgICBjYXNlICclZCc6XG5cdCAgICAgICAgcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuXG5cdCAgICAgIGNhc2UgJyVqJzpcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG5cdCAgICAgICAgfSBjYXRjaCAoXykge1xuXHQgICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcblx0ICAgICAgICB9XG5cblx0ICAgICAgZGVmYXVsdDpcblx0ICAgICAgICByZXR1cm4geDtcblx0ICAgIH1cblx0ICB9KTtcblxuXHQgIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG5cdCAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuXHQgICAgICBzdHIgKz0gJyAnICsgeDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiBzdHI7XG5cdH1cblx0Ly8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cblx0Ly8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cblxuXHRmdW5jdGlvbiBkZXByZWNhdGUoZm4sIG1zZykge1xuXHQgIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG5cdCAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgcmV0dXJuIGRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgfTtcblx0ICB9XG5cblx0ICB2YXIgd2FybmVkID0gZmFsc2U7XG5cblx0ICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuXHQgICAgaWYgKCF3YXJuZWQpIHtcblx0ICAgICAge1xuXHQgICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHdhcm5lZCA9IHRydWU7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgIH1cblxuXHQgIHJldHVybiBkZXByZWNhdGVkO1xuXHR9XG5cdHZhciBkZWJ1Z3MgPSB7fTtcblx0dmFyIGRlYnVnRW52aXJvbjtcblx0ZnVuY3Rpb24gZGVidWdsb2coc2V0KSB7XG5cdCAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG5cdCAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG5cblx0ICBpZiAoIWRlYnVnc1tzZXRdKSB7XG5cdCAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcblx0ICAgICAgdmFyIHBpZCA9IDA7XG5cblx0ICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG1zZyA9IGZvcm1hdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuXHQgICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuXHQgICAgICB9O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbiAoKSB7fTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gZGVidWdzW3NldF07XG5cdH1cblx0LyoqXG5cdCAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcblx0ICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG5cdCAqL1xuXG5cdC8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cblxuXHRmdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuXHQgIC8vIGRlZmF1bHQgb3B0aW9uc1xuXHQgIHZhciBjdHggPSB7XG5cdCAgICBzZWVuOiBbXSxcblx0ICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG5cdCAgfTsgLy8gbGVnYWN5Li4uXG5cblx0ICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG5cdCAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcblxuXHQgIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcblx0ICAgIC8vIGxlZ2FjeS4uLlxuXHQgICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuXHQgIH0gZWxzZSBpZiAob3B0cykge1xuXHQgICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuXHQgICAgX2V4dGVuZChjdHgsIG9wdHMpO1xuXHQgIH0gLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuXG5cblx0ICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuXHQgIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuXHQgIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuXHQgIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcblx0ICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuXHQgIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcblx0fSAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3NcblxuXHRpbnNwZWN0LmNvbG9ycyA9IHtcblx0ICAnYm9sZCc6IFsxLCAyMl0sXG5cdCAgJ2l0YWxpYyc6IFszLCAyM10sXG5cdCAgJ3VuZGVybGluZSc6IFs0LCAyNF0sXG5cdCAgJ2ludmVyc2UnOiBbNywgMjddLFxuXHQgICd3aGl0ZSc6IFszNywgMzldLFxuXHQgICdncmV5JzogWzkwLCAzOV0sXG5cdCAgJ2JsYWNrJzogWzMwLCAzOV0sXG5cdCAgJ2JsdWUnOiBbMzQsIDM5XSxcblx0ICAnY3lhbic6IFszNiwgMzldLFxuXHQgICdncmVlbic6IFszMiwgMzldLFxuXHQgICdtYWdlbnRhJzogWzM1LCAzOV0sXG5cdCAgJ3JlZCc6IFszMSwgMzldLFxuXHQgICd5ZWxsb3cnOiBbMzMsIDM5XVxuXHR9OyAvLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcblxuXHRpbnNwZWN0LnN0eWxlcyA9IHtcblx0ICAnc3BlY2lhbCc6ICdjeWFuJyxcblx0ICAnbnVtYmVyJzogJ3llbGxvdycsXG5cdCAgJ2Jvb2xlYW4nOiAneWVsbG93Jyxcblx0ICAndW5kZWZpbmVkJzogJ2dyZXknLFxuXHQgICdudWxsJzogJ2JvbGQnLFxuXHQgICdzdHJpbmcnOiAnZ3JlZW4nLFxuXHQgICdkYXRlJzogJ21hZ2VudGEnLFxuXHQgIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG5cdCAgJ3JlZ2V4cCc6ICdyZWQnXG5cdH07XG5cblx0ZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuXHQgIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cblx0ICBpZiAoc3R5bGUpIHtcblx0ICAgIHJldHVybiBcIlxceDFCW1wiICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICsgXCJcXHgxQltcIiArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcblx0ICB9IGVsc2Uge1xuXHQgICAgcmV0dXJuIHN0cjtcblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuXHQgIHJldHVybiBzdHI7XG5cdH1cblxuXHRmdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuXHQgIHZhciBoYXNoID0ge307XG5cdCAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbiAodmFsLCBpZHgpIHtcblx0ICAgIGhhc2hbdmFsXSA9IHRydWU7XG5cdCAgfSk7XG5cdCAgcmV0dXJuIGhhc2g7XG5cdH1cblxuXHRmdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcblx0ICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG5cdCAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG5cdCAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmIHZhbHVlICYmIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiYgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG5cdCAgdmFsdWUuaW5zcGVjdCAhPT0gaW5zcGVjdCAmJiAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cblx0ICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG5cdCAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG5cblx0ICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuXHQgICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHJldDtcblx0ICB9IC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG5cblxuXHQgIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG5cblx0ICBpZiAocHJpbWl0aXZlKSB7XG5cdCAgICByZXR1cm4gcHJpbWl0aXZlO1xuXHQgIH0gLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuXG5cblx0ICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcblx0ICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuXHQgIGlmIChjdHguc2hvd0hpZGRlbikge1xuXHQgICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcblx0ICB9IC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcblx0ICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuXG5cblx0ICBpZiAoaXNFcnJvcih2YWx1ZSkgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG5cdCAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuXHQgIH0gLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuXG5cblx0ICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcblx0ICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuXHQgICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuXHQgICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG5cdCAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG5cdCAgICB9XG5cblx0ICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG5cdCAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG5cdCAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgdmFyIGJhc2UgPSAnJyxcblx0ICAgICAgYXJyYXkgPSBmYWxzZSxcblx0ICAgICAgYnJhY2VzID0gWyd7JywgJ30nXTsgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuXG5cdCAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG5cdCAgICBhcnJheSA9IHRydWU7XG5cdCAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuXHQgIH0gLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG5cblxuXHQgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuXHQgICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcblx0ICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuXHQgIH0gLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcblxuXG5cdCAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuXHQgICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5cdCAgfSAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcblxuXG5cdCAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcblx0ICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcblx0ICB9IC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcblxuXG5cdCAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG5cdCAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuXHQgIH1cblxuXHQgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuXHQgICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG5cdCAgfVxuXG5cdCAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcblx0ICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcblx0ICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXHQgIHZhciBvdXRwdXQ7XG5cblx0ICBpZiAoYXJyYXkpIHtcblx0ICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcblx0ICAgIH0pO1xuXHQgIH1cblxuXHQgIGN0eC5zZWVuLnBvcCgpO1xuXHQgIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG5cdH1cblxuXHRmdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuXHQgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuXG5cdCAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuXHQgICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKS5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcblx0ICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcblx0ICB9XG5cblx0ICBpZiAoaXNOdW1iZXIodmFsdWUpKSByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuXHQgIGlmIChpc0Jvb2xlYW4odmFsdWUpKSByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTsgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuXG5cdCAgaWYgKGlzTnVsbCh2YWx1ZSkpIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG5cdH1cblxuXHRmdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuXHQgIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG5cdH1cblxuXHRmdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG5cdCAgdmFyIG91dHB1dCA9IFtdO1xuXG5cdCAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcblx0ICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuXHQgICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBTdHJpbmcoaSksIHRydWUpKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIG91dHB1dC5wdXNoKCcnKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHQgICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG5cdCAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgdHJ1ZSkpO1xuXHQgICAgfVxuXHQgIH0pO1xuXHQgIHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHRmdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG5cdCAgdmFyIG5hbWUsIHN0ciwgZGVzYztcblx0ICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7XG5cdCAgICB2YWx1ZTogdmFsdWVba2V5XVxuXHQgIH07XG5cblx0ICBpZiAoZGVzYy5nZXQpIHtcblx0ICAgIGlmIChkZXNjLnNldCkge1xuXHQgICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG5cdCAgICB9XG5cdCAgfSBlbHNlIHtcblx0ICAgIGlmIChkZXNjLnNldCkge1xuXHQgICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcblx0ICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG5cdCAgfVxuXG5cdCAgaWYgKCFzdHIpIHtcblx0ICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuXHQgICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcblx0ICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcblx0ICAgICAgICBpZiAoYXJyYXkpIHtcblx0ICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uIChsaW5lKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcblx0ICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbiAobGluZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuXHQgICAgICAgICAgfSkuam9pbignXFxuJyk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG5cdCAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuXHQgICAgICByZXR1cm4gc3RyO1xuXHQgICAgfVxuXG5cdCAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuXG5cdCAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcblx0ICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG5cdCAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKS5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuXHQgICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcblx0fVxuXG5cdGZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG5cdCAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cikge1xuXHQgICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSA7XG5cdCAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG5cdCAgfSwgMCk7XG5cblx0ICBpZiAobGVuZ3RoID4gNjApIHtcblx0ICAgIHJldHVybiBicmFjZXNbMF0gKyAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICsgJyAnICsgb3V0cHV0LmpvaW4oJyxcXG4gICcpICsgJyAnICsgYnJhY2VzWzFdO1xuXHQgIH1cblxuXHQgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG5cdH0gLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG5cdC8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuXG5cblx0ZnVuY3Rpb24gaXNBcnJheShhcikge1xuXHQgIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcblx0fVxuXHRmdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG5cdCAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcblx0fVxuXHRmdW5jdGlvbiBpc051bGwoYXJnKSB7XG5cdCAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcblx0fVxuXHRmdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcblx0ICByZXR1cm4gYXJnID09IG51bGw7XG5cdH1cblx0ZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG5cdCAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xuXHR9XG5cdGZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuXHQgIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcblx0fVxuXHRmdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcblx0ICByZXR1cm4gX3R5cGVvZiQxKGFyZykgPT09ICdzeW1ib2wnO1xuXHR9XG5cdGZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuXHQgIHJldHVybiBhcmcgPT09IHZvaWQgMDtcblx0fVxuXHRmdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuXHQgIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcblx0fVxuXHRmdW5jdGlvbiBpc09iamVjdChhcmcpIHtcblx0ICByZXR1cm4gX3R5cGVvZiQxKGFyZykgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcblx0fVxuXHRmdW5jdGlvbiBpc0RhdGUoZCkge1xuXHQgIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xuXHR9XG5cdGZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuXHQgIHJldHVybiBpc09iamVjdChlKSAmJiAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcblx0fVxuXHRmdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuXHQgIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xuXHR9XG5cdGZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuXHQgIHJldHVybiBhcmcgPT09IG51bGwgfHwgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8IHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8IF90eXBlb2YkMShhcmcpID09PSAnc3ltYm9sJyB8fCAvLyBFUzYgc3ltYm9sXG5cdCAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG5cdH1cblx0ZnVuY3Rpb24gaXNCdWZmZXIobWF5YmVCdWYpIHtcblx0ICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG1heWJlQnVmKTtcblx0fVxuXG5cdGZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcblx0ICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xuXHR9XG5cblx0ZnVuY3Rpb24gcGFkKG4pIHtcblx0ICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcblx0fVxuXG5cdHZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJywgJ09jdCcsICdOb3YnLCAnRGVjJ107IC8vIDI2IEZlYiAxNjoxOTozNFxuXG5cdGZ1bmN0aW9uIHRpbWVzdGFtcCQxKCkge1xuXHQgIHZhciBkID0gbmV3IERhdGUoKTtcblx0ICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSwgcGFkKGQuZ2V0TWludXRlcygpKSwgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuXHQgIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG5cdH0gLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuXG5cblx0ZnVuY3Rpb24gbG9nKCkge1xuXHQgIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wJDEoKSwgZm9ybWF0LmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuXHR9XG5cdGZ1bmN0aW9uIF9leHRlbmQob3JpZ2luLCBhZGQpIHtcblx0ICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG5cdCAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cdCAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuXHQgIHZhciBpID0ga2V5cy5sZW5ndGg7XG5cblx0ICB3aGlsZSAoaS0tKSB7XG5cdCAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG5cdCAgfVxuXG5cdCAgcmV0dXJuIG9yaWdpbjtcblx0fVxuXG5cdGZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuXHQgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcblx0fVxuXG5cdHZhciB1dGlsID0ge1xuXHQgIGluaGVyaXRzOiBpbmhlcml0cyQxLFxuXHQgIF9leHRlbmQ6IF9leHRlbmQsXG5cdCAgbG9nOiBsb2csXG5cdCAgaXNCdWZmZXI6IGlzQnVmZmVyLFxuXHQgIGlzUHJpbWl0aXZlOiBpc1ByaW1pdGl2ZSxcblx0ICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuXHQgIGlzRXJyb3I6IGlzRXJyb3IsXG5cdCAgaXNEYXRlOiBpc0RhdGUsXG5cdCAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuXHQgIGlzUmVnRXhwOiBpc1JlZ0V4cCxcblx0ICBpc1VuZGVmaW5lZDogaXNVbmRlZmluZWQsXG5cdCAgaXNTeW1ib2w6IGlzU3ltYm9sLFxuXHQgIGlzU3RyaW5nOiBpc1N0cmluZyxcblx0ICBpc051bWJlcjogaXNOdW1iZXIsXG5cdCAgaXNOdWxsT3JVbmRlZmluZWQ6IGlzTnVsbE9yVW5kZWZpbmVkLFxuXHQgIGlzTnVsbDogaXNOdWxsLFxuXHQgIGlzQm9vbGVhbjogaXNCb29sZWFuLFxuXHQgIGlzQXJyYXk6IGlzQXJyYXksXG5cdCAgaW5zcGVjdDogaW5zcGVjdCxcblx0ICBkZXByZWNhdGU6IGRlcHJlY2F0ZSxcblx0ICBmb3JtYXQ6IGZvcm1hdCxcblx0ICBkZWJ1Z2xvZzogZGVidWdsb2dcblx0fTtcblxuXHR2YXIgdXRpbCQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRcdGZvcm1hdDogZm9ybWF0LFxuXHRcdGRlcHJlY2F0ZTogZGVwcmVjYXRlLFxuXHRcdGRlYnVnbG9nOiBkZWJ1Z2xvZyxcblx0XHRpbnNwZWN0OiBpbnNwZWN0LFxuXHRcdGlzQXJyYXk6IGlzQXJyYXksXG5cdFx0aXNCb29sZWFuOiBpc0Jvb2xlYW4sXG5cdFx0aXNOdWxsOiBpc051bGwsXG5cdFx0aXNOdWxsT3JVbmRlZmluZWQ6IGlzTnVsbE9yVW5kZWZpbmVkLFxuXHRcdGlzTnVtYmVyOiBpc051bWJlcixcblx0XHRpc1N0cmluZzogaXNTdHJpbmcsXG5cdFx0aXNTeW1ib2w6IGlzU3ltYm9sLFxuXHRcdGlzVW5kZWZpbmVkOiBpc1VuZGVmaW5lZCxcblx0XHRpc1JlZ0V4cDogaXNSZWdFeHAsXG5cdFx0aXNPYmplY3Q6IGlzT2JqZWN0LFxuXHRcdGlzRGF0ZTogaXNEYXRlLFxuXHRcdGlzRXJyb3I6IGlzRXJyb3IsXG5cdFx0aXNGdW5jdGlvbjogaXNGdW5jdGlvbixcblx0XHRpc1ByaW1pdGl2ZTogaXNQcmltaXRpdmUsXG5cdFx0aXNCdWZmZXI6IGlzQnVmZmVyLFxuXHRcdGxvZzogbG9nLFxuXHRcdGluaGVyaXRzOiBpbmhlcml0cyQxLFxuXHRcdF9leHRlbmQ6IF9leHRlbmQsXG5cdFx0ZGVmYXVsdDogdXRpbFxuXHR9KTtcblxuXHR2YXIgdXRpbCQyID0gZ2V0Q2pzRXhwb3J0RnJvbU5hbWVzcGFjZSh1dGlsJDEpO1xuXG5cdGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayQyKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuXHRmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyQyKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuXHRmdW5jdGlvbiBfY3JlYXRlQ2xhc3MkMihDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzJDIoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyQyKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5cdHZhciBCdWZmZXIkMSA9IGJ1ZmZlci5CdWZmZXI7XG5cdHZhciByYW5kb21CeXRlcyQxID0gdXRpbHMucmFuZG9tQnl0ZXM7XG5cdHZhciBkZXByZWNhdGUkMSA9IHV0aWwkMi5kZXByZWNhdGU7IC8vIGNvbnN0YW50c1xuXG5cdHZhciBQUk9DRVNTX1VOSVFVRSA9IHJhbmRvbUJ5dGVzJDEoNSk7IC8vIFJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IGNoZWNrcyBmb3IgaGV4IHZhbHVlXG5cblx0dmFyIGNoZWNrRm9ySGV4UmVnRXhwID0gbmV3IFJlZ0V4cCgnXlswLTlhLWZBLUZdezI0fSQnKTtcblx0dmFyIGhhc0J1ZmZlclR5cGUgPSBmYWxzZTsgLy8gQ2hlY2sgaWYgYnVmZmVyIGV4aXN0c1xuXG5cdHRyeSB7XG5cdCAgaWYgKEJ1ZmZlciQxICYmIEJ1ZmZlciQxLmZyb20pIGhhc0J1ZmZlclR5cGUgPSB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0ICBoYXNCdWZmZXJUeXBlID0gZmFsc2U7XG5cdH0gLy8gUHJlY29tcHV0ZWQgaGV4IHRhYmxlIGVuYWJsZXMgc3BlZWR5IGhleCBzdHJpbmcgY29udmVyc2lvblxuXG5cblx0dmFyIGhleFRhYmxlID0gW107XG5cblx0Zm9yICh2YXIgX2kgPSAwOyBfaSA8IDI1NjsgX2krKykge1xuXHQgIGhleFRhYmxlW19pXSA9IChfaSA8PSAxNSA/ICcwJyA6ICcnKSArIF9pLnRvU3RyaW5nKDE2KTtcblx0fSAvLyBMb29rdXAgdGFibGVzXG5cblxuXHR2YXIgZGVjb2RlTG9va3VwID0gW107XG5cdHZhciBpID0gMDtcblxuXHR3aGlsZSAoaSA8IDEwKSB7XG5cdCAgZGVjb2RlTG9va3VwWzB4MzAgKyBpXSA9IGkrKztcblx0fVxuXG5cdHdoaWxlIChpIDwgMTYpIHtcblx0ICBkZWNvZGVMb29rdXBbMHg0MSAtIDEwICsgaV0gPSBkZWNvZGVMb29rdXBbMHg2MSAtIDEwICsgaV0gPSBpKys7XG5cdH1cblxuXHR2YXIgX0J1ZmZlciA9IEJ1ZmZlciQxO1xuXG5cdGZ1bmN0aW9uIGNvbnZlcnRUb0hleChieXRlcykge1xuXHQgIHJldHVybiBieXRlcy50b1N0cmluZygnaGV4Jyk7XG5cdH1cblxuXHRmdW5jdGlvbiBtYWtlT2JqZWN0SWRFcnJvcihpbnZhbGlkU3RyaW5nLCBpbmRleCkge1xuXHQgIHZhciBpbnZhbGlkQ2hhcmFjdGVyID0gaW52YWxpZFN0cmluZ1tpbmRleF07XG5cdCAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJPYmplY3RJZCBzdHJpbmcgXFxcIlwiLmNvbmNhdChpbnZhbGlkU3RyaW5nLCBcIlxcXCIgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXIgXFxcIlwiKS5jb25jYXQoaW52YWxpZENoYXJhY3RlciwgXCJcXFwiIHdpdGggY2hhcmFjdGVyIGNvZGUgKFwiKS5jb25jYXQoaW52YWxpZFN0cmluZy5jaGFyQ29kZUF0KGluZGV4KSwgXCIpLiBBbGwgY2hhcmFjdGVyIGNvZGVzIGZvciBhIG5vbi1oZXggc3RyaW5nIG11c3QgYmUgbGVzcyB0aGFuIDI1Ni5cIikpO1xuXHR9XG5cdC8qKlxuXHQgKiBBIGNsYXNzIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBCU09OIE9iamVjdElkIHR5cGUuXG5cdCAqL1xuXG5cblx0dmFyIE9iamVjdElkID1cblx0LyojX19QVVJFX18qL1xuXHRmdW5jdGlvbiAoKSB7XG5cdCAgLyoqXG5cdCAgICogQ3JlYXRlIGFuIE9iamVjdElkIHR5cGVcblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7KHN0cmluZ3xCdWZmZXJ8bnVtYmVyKX0gaWQgQ2FuIGJlIGEgMjQgYnl0ZSBoZXggc3RyaW5nLCAxMiBieXRlIGJpbmFyeSBCdWZmZXIsIG9yIGEgTnVtYmVyLlxuXHQgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBnZW5lcmF0aW9uVGltZSBUaGUgZ2VuZXJhdGlvbiB0aW1lIG9mIHRoaXMgT2JqZWN0SWQgaW5zdGFuY2Vcblx0ICAgKiBAcmV0dXJuIHtPYmplY3RJZH0gaW5zdGFuY2Ugb2YgT2JqZWN0SWQuXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gT2JqZWN0SWQoaWQpIHtcblx0ICAgIF9jbGFzc0NhbGxDaGVjayQyKHRoaXMsIE9iamVjdElkKTtcblxuXHQgICAgLy8gRHVjay10eXBpbmcgdG8gc3VwcG9ydCBPYmplY3RJZCBmcm9tIGRpZmZlcmVudCBucG0gcGFja2FnZXNcblx0ICAgIGlmIChpZCBpbnN0YW5jZW9mIE9iamVjdElkKSByZXR1cm4gaWQ7IC8vIFRoZSBtb3N0IGNvbW1vbiB1c2VjYXNlIChibGFuayBpZCwgbmV3IG9iamVjdElkIGluc3RhbmNlKVxuXG5cdCAgICBpZiAoaWQgPT0gbnVsbCB8fCB0eXBlb2YgaWQgPT09ICdudW1iZXInKSB7XG5cdCAgICAgIC8vIEdlbmVyYXRlIGEgbmV3IGlkXG5cdCAgICAgIHRoaXMuaWQgPSBPYmplY3RJZC5nZW5lcmF0ZShpZCk7IC8vIElmIHdlIGFyZSBjYWNoaW5nIHRoZSBoZXggc3RyaW5nXG5cblx0ICAgICAgaWYgKE9iamVjdElkLmNhY2hlSGV4U3RyaW5nKSB0aGlzLl9faWQgPSB0aGlzLnRvU3RyaW5nKCdoZXgnKTsgLy8gUmV0dXJuIHRoZSBvYmplY3RcblxuXHQgICAgICByZXR1cm47XG5cdCAgICB9IC8vIENoZWNrIGlmIHRoZSBwYXNzZWQgaW4gaWQgaXMgdmFsaWRcblxuXG5cdCAgICB2YXIgdmFsaWQgPSBPYmplY3RJZC5pc1ZhbGlkKGlkKTsgLy8gVGhyb3cgYW4gZXJyb3IgaWYgaXQncyBub3QgYSB2YWxpZCBzZXR1cFxuXG5cdCAgICBpZiAoIXZhbGlkICYmIGlkICE9IG51bGwpIHtcblx0ICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgcGFzc2VkIGluIG11c3QgYmUgYSBzaW5nbGUgU3RyaW5nIG9mIDEyIGJ5dGVzIG9yIGEgc3RyaW5nIG9mIDI0IGhleCBjaGFyYWN0ZXJzJyk7XG5cdCAgICB9IGVsc2UgaWYgKHZhbGlkICYmIHR5cGVvZiBpZCA9PT0gJ3N0cmluZycgJiYgaWQubGVuZ3RoID09PSAyNCAmJiBoYXNCdWZmZXJUeXBlKSB7XG5cdCAgICAgIHJldHVybiBuZXcgT2JqZWN0SWQoQnVmZmVyJDEuZnJvbShpZCwgJ2hleCcpKTtcblx0ICAgIH0gZWxzZSBpZiAodmFsaWQgJiYgdHlwZW9mIGlkID09PSAnc3RyaW5nJyAmJiBpZC5sZW5ndGggPT09IDI0KSB7XG5cdCAgICAgIHJldHVybiBPYmplY3RJZC5jcmVhdGVGcm9tSGV4U3RyaW5nKGlkKTtcblx0ICAgIH0gZWxzZSBpZiAoaWQgIT0gbnVsbCAmJiBpZC5sZW5ndGggPT09IDEyKSB7XG5cdCAgICAgIC8vIGFzc3VtZSAxMiBieXRlIHN0cmluZ1xuXHQgICAgICB0aGlzLmlkID0gaWQ7XG5cdCAgICB9IGVsc2UgaWYgKGlkICE9IG51bGwgJiYgaWQudG9IZXhTdHJpbmcpIHtcblx0ICAgICAgLy8gRHVjay10eXBpbmcgdG8gc3VwcG9ydCBPYmplY3RJZCBmcm9tIGRpZmZlcmVudCBucG0gcGFja2FnZXNcblx0ICAgICAgcmV0dXJuIE9iamVjdElkLmNyZWF0ZUZyb21IZXhTdHJpbmcoaWQudG9IZXhTdHJpbmcoKSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBwYXNzZWQgaW4gbXVzdCBiZSBhIHNpbmdsZSBTdHJpbmcgb2YgMTIgYnl0ZXMgb3IgYSBzdHJpbmcgb2YgMjQgaGV4IGNoYXJhY3RlcnMnKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKE9iamVjdElkLmNhY2hlSGV4U3RyaW5nKSB0aGlzLl9faWQgPSB0aGlzLnRvU3RyaW5nKCdoZXgnKTtcblx0ICB9XG5cdCAgLyoqXG5cdCAgICogUmV0dXJuIHRoZSBPYmplY3RJZCBpZCBhcyBhIDI0IGJ5dGUgaGV4IHN0cmluZyByZXByZXNlbnRhdGlvblxuXHQgICAqXG5cdCAgICogQG1ldGhvZFxuXHQgICAqIEByZXR1cm4ge3N0cmluZ30gcmV0dXJuIHRoZSAyNCBieXRlIGhleCBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG5cdCAgICovXG5cblxuXHQgIF9jcmVhdGVDbGFzcyQyKE9iamVjdElkLCBbe1xuXHQgICAga2V5OiBcInRvSGV4U3RyaW5nXCIsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gdG9IZXhTdHJpbmcoKSB7XG5cdCAgICAgIGlmIChPYmplY3RJZC5jYWNoZUhleFN0cmluZyAmJiB0aGlzLl9faWQpIHJldHVybiB0aGlzLl9faWQ7XG5cdCAgICAgIHZhciBoZXhTdHJpbmcgPSAnJztcblxuXHQgICAgICBpZiAoIXRoaXMuaWQgfHwgIXRoaXMuaWQubGVuZ3RoKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBPYmplY3RJZCwgT2JqZWN0SWQuaWQgbXVzdCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYSBCdWZmZXIsIGJ1dCBpcyBbJyArIEpTT04uc3RyaW5naWZ5KHRoaXMuaWQpICsgJ10nKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICh0aGlzLmlkIGluc3RhbmNlb2YgX0J1ZmZlcikge1xuXHQgICAgICAgIGhleFN0cmluZyA9IGNvbnZlcnRUb0hleCh0aGlzLmlkKTtcblx0ICAgICAgICBpZiAoT2JqZWN0SWQuY2FjaGVIZXhTdHJpbmcpIHRoaXMuX19pZCA9IGhleFN0cmluZztcblx0ICAgICAgICByZXR1cm4gaGV4U3RyaW5nO1xuXHQgICAgICB9XG5cblx0ICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgdGhpcy5pZC5sZW5ndGg7IF9pMisrKSB7XG5cdCAgICAgICAgdmFyIGhleENoYXIgPSBoZXhUYWJsZVt0aGlzLmlkLmNoYXJDb2RlQXQoX2kyKV07XG5cblx0ICAgICAgICBpZiAodHlwZW9mIGhleENoYXIgIT09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICB0aHJvdyBtYWtlT2JqZWN0SWRFcnJvcih0aGlzLmlkLCBfaTIpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGhleFN0cmluZyArPSBoZXhDaGFyO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKE9iamVjdElkLmNhY2hlSGV4U3RyaW5nKSB0aGlzLl9faWQgPSBoZXhTdHJpbmc7XG5cdCAgICAgIHJldHVybiBoZXhTdHJpbmc7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIFVwZGF0ZSB0aGUgT2JqZWN0SWQgaW5kZXggdXNlZCBpbiBnZW5lcmF0aW5nIG5ldyBPYmplY3RJZCdzIG9uIHRoZSBkcml2ZXJcblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kXG5cdCAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IHJldHVybnMgbmV4dCBpbmRleCB2YWx1ZS5cblx0ICAgICAqIEBpZ25vcmVcblx0ICAgICAqL1xuXG5cdCAgfSwge1xuXHQgICAga2V5OiBcInRvU3RyaW5nXCIsXG5cblx0ICAgIC8qKlxuXHQgICAgICogQ29udmVydHMgdGhlIGlkIGludG8gYSAyNCBieXRlIGhleCBzdHJpbmcgZm9yIHByaW50aW5nXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtTdHJpbmd9IGZvcm1hdCBUaGUgQnVmZmVyIHRvU3RyaW5nIGZvcm1hdCBwYXJhbWV0ZXIuXG5cdCAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybiB0aGUgMjQgYnl0ZSBoZXggc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxuXHQgICAgICogQGlnbm9yZVxuXHQgICAgICovXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoZm9ybWF0KSB7XG5cdCAgICAgIC8vIElzIHRoZSBpZCBhIGJ1ZmZlciB0aGVuIHVzZSB0aGUgYnVmZmVyIHRvU3RyaW5nIG1ldGhvZCB0byByZXR1cm4gdGhlIGZvcm1hdFxuXHQgICAgICBpZiAodGhpcy5pZCAmJiB0aGlzLmlkLmNvcHkpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5pZC50b1N0cmluZyh0eXBlb2YgZm9ybWF0ID09PSAnc3RyaW5nJyA/IGZvcm1hdCA6ICdoZXgnKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiB0aGlzLnRvSGV4U3RyaW5nKCk7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIENvbnZlcnRzIHRvIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJuIHRoZSAyNCBieXRlIGhleCBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG5cdCAgICAgKiBAaWdub3JlXG5cdCAgICAgKi9cblxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJ0b0pTT05cIixcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLnRvSGV4U3RyaW5nKCk7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIENvbXBhcmVzIHRoZSBlcXVhbGl0eSBvZiB0aGlzIE9iamVjdElkIHdpdGggYG90aGVySURgLlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2Rcblx0ICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvdGhlcklkIE9iamVjdElkIGluc3RhbmNlIHRvIGNvbXBhcmUgYWdhaW5zdC5cblx0ICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRoZSByZXN1bHQgb2YgY29tcGFyaW5nIHR3byBPYmplY3RJZCdzXG5cdCAgICAgKi9cblxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJlcXVhbHNcIixcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBlcXVhbHMob3RoZXJJZCkge1xuXHQgICAgICBpZiAob3RoZXJJZCBpbnN0YW5jZW9mIE9iamVjdElkKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKSA9PT0gb3RoZXJJZC50b1N0cmluZygpO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHR5cGVvZiBvdGhlcklkID09PSAnc3RyaW5nJyAmJiBPYmplY3RJZC5pc1ZhbGlkKG90aGVySWQpICYmIG90aGVySWQubGVuZ3RoID09PSAxMiAmJiB0aGlzLmlkIGluc3RhbmNlb2YgX0J1ZmZlcikge1xuXHQgICAgICAgIHJldHVybiBvdGhlcklkID09PSB0aGlzLmlkLnRvU3RyaW5nKCdiaW5hcnknKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICh0eXBlb2Ygb3RoZXJJZCA9PT0gJ3N0cmluZycgJiYgT2JqZWN0SWQuaXNWYWxpZChvdGhlcklkKSAmJiBvdGhlcklkLmxlbmd0aCA9PT0gMjQpIHtcblx0ICAgICAgICByZXR1cm4gb3RoZXJJZC50b0xvd2VyQ2FzZSgpID09PSB0aGlzLnRvSGV4U3RyaW5nKCk7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAodHlwZW9mIG90aGVySWQgPT09ICdzdHJpbmcnICYmIE9iamVjdElkLmlzVmFsaWQob3RoZXJJZCkgJiYgb3RoZXJJZC5sZW5ndGggPT09IDEyKSB7XG5cdCAgICAgICAgcmV0dXJuIG90aGVySWQgPT09IHRoaXMuaWQ7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAob3RoZXJJZCAhPSBudWxsICYmIChvdGhlcklkIGluc3RhbmNlb2YgT2JqZWN0SWQgfHwgb3RoZXJJZC50b0hleFN0cmluZykpIHtcblx0ICAgICAgICByZXR1cm4gb3RoZXJJZC50b0hleFN0cmluZygpID09PSB0aGlzLnRvSGV4U3RyaW5nKCk7XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIFJldHVybnMgdGhlIGdlbmVyYXRpb24gZGF0ZSAoYWNjdXJhdGUgdXAgdG8gdGhlIHNlY29uZCkgdGhhdCB0aGlzIElEIHdhcyBnZW5lcmF0ZWQuXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZFxuXHQgICAgICogQHJldHVybiB7RGF0ZX0gdGhlIGdlbmVyYXRpb24gZGF0ZVxuXHQgICAgICovXG5cblx0ICB9LCB7XG5cdCAgICBrZXk6IFwiZ2V0VGltZXN0YW1wXCIsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGltZXN0YW1wKCkge1xuXHQgICAgICB2YXIgdGltZXN0YW1wID0gbmV3IERhdGUoKTtcblx0ICAgICAgdmFyIHRpbWUgPSB0aGlzLmlkLnJlYWRVSW50MzJCRSgwKTtcblx0ICAgICAgdGltZXN0YW1wLnNldFRpbWUoTWF0aC5mbG9vcih0aW1lKSAqIDEwMDApO1xuXHQgICAgICByZXR1cm4gdGltZXN0YW1wO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBAaWdub3JlXG5cdCAgICAgKi9cblxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJ0b0V4dGVuZGVkSlNPTlwiLFxuXG5cdCAgICAvKipcblx0ICAgICAqIEBpZ25vcmVcblx0ICAgICAqL1xuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHRvRXh0ZW5kZWRKU09OKCkge1xuXHQgICAgICBpZiAodGhpcy50b0hleFN0cmluZykgcmV0dXJuIHtcblx0ICAgICAgICAkb2lkOiB0aGlzLnRvSGV4U3RyaW5nKClcblx0ICAgICAgfTtcblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAkb2lkOiB0aGlzLnRvU3RyaW5nKCdoZXgnKVxuXHQgICAgICB9O1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBAaWdub3JlXG5cdCAgICAgKi9cblxuXHQgIH1dLCBbe1xuXHQgICAga2V5OiBcImdldEluY1wiLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEluYygpIHtcblx0ICAgICAgcmV0dXJuIE9iamVjdElkLmluZGV4ID0gKE9iamVjdElkLmluZGV4ICsgMSkgJSAweGZmZmZmZjtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogR2VuZXJhdGUgYSAxMiBieXRlIGlkIGJ1ZmZlciB1c2VkIGluIE9iamVjdElkJ3Ncblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kXG5cdCAgICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWVdIG9wdGlvbmFsIHBhcmFtZXRlciBhbGxvd2luZyB0byBwYXNzIGluIGEgc2Vjb25kIGJhc2VkIHRpbWVzdGFtcC5cblx0ICAgICAqIEByZXR1cm4ge0J1ZmZlcn0gcmV0dXJuIHRoZSAxMiBieXRlIGlkIGJ1ZmZlciBzdHJpbmcuXG5cdCAgICAgKi9cblxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJnZW5lcmF0ZVwiLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGdlbmVyYXRlKHRpbWUpIHtcblx0ICAgICAgaWYgKCdudW1iZXInICE9PSB0eXBlb2YgdGltZSkge1xuXHQgICAgICAgIHRpbWUgPSB+fihEYXRlLm5vdygpIC8gMTAwMCk7XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgaW5jID0gT2JqZWN0SWQuZ2V0SW5jKCk7XG5cdCAgICAgIHZhciBidWZmZXIkJDEgPSBCdWZmZXIkMS5hbGxvYygxMik7IC8vIDQtYnl0ZSB0aW1lc3RhbXBcblxuXHQgICAgICBidWZmZXIkJDFbM10gPSB0aW1lICYgMHhmZjtcblx0ICAgICAgYnVmZmVyJCQxWzJdID0gdGltZSA+PiA4ICYgMHhmZjtcblx0ICAgICAgYnVmZmVyJCQxWzFdID0gdGltZSA+PiAxNiAmIDB4ZmY7XG5cdCAgICAgIGJ1ZmZlciQkMVswXSA9IHRpbWUgPj4gMjQgJiAweGZmOyAvLyA1LWJ5dGUgcHJvY2VzcyB1bmlxdWVcblxuXHQgICAgICBidWZmZXIkJDFbNF0gPSBQUk9DRVNTX1VOSVFVRVswXTtcblx0ICAgICAgYnVmZmVyJCQxWzVdID0gUFJPQ0VTU19VTklRVUVbMV07XG5cdCAgICAgIGJ1ZmZlciQkMVs2XSA9IFBST0NFU1NfVU5JUVVFWzJdO1xuXHQgICAgICBidWZmZXIkJDFbN10gPSBQUk9DRVNTX1VOSVFVRVszXTtcblx0ICAgICAgYnVmZmVyJCQxWzhdID0gUFJPQ0VTU19VTklRVUVbNF07IC8vIDMtYnl0ZSBjb3VudGVyXG5cblx0ICAgICAgYnVmZmVyJCQxWzExXSA9IGluYyAmIDB4ZmY7XG5cdCAgICAgIGJ1ZmZlciQkMVsxMF0gPSBpbmMgPj4gOCAmIDB4ZmY7XG5cdCAgICAgIGJ1ZmZlciQkMVs5XSA9IGluYyA+PiAxNiAmIDB4ZmY7XG5cdCAgICAgIHJldHVybiBidWZmZXIkJDE7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiBcImNyZWF0ZVBrXCIsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlUGsoKSB7XG5cdCAgICAgIHJldHVybiBuZXcgT2JqZWN0SWQoKTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogQ3JlYXRlcyBhbiBPYmplY3RJZCBmcm9tIGEgc2Vjb25kIGJhc2VkIG51bWJlciwgd2l0aCB0aGUgcmVzdCBvZiB0aGUgT2JqZWN0SWQgemVyb2VkIG91dC4gVXNlZCBmb3IgY29tcGFyaXNvbnMgb3Igc29ydGluZyB0aGUgT2JqZWN0SWQuXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZFxuXHQgICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgYW4gaW50ZWdlciBudW1iZXIgcmVwcmVzZW50aW5nIGEgbnVtYmVyIG9mIHNlY29uZHMuXG5cdCAgICAgKiBAcmV0dXJuIHtPYmplY3RJZH0gcmV0dXJuIHRoZSBjcmVhdGVkIE9iamVjdElkXG5cdCAgICAgKi9cblxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJjcmVhdGVGcm9tVGltZVwiLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUZyb21UaW1lKHRpbWUpIHtcblx0ICAgICAgdmFyIGJ1ZmZlciQkMSA9IEJ1ZmZlciQxLmZyb20oWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKTsgLy8gRW5jb2RlIHRpbWUgaW50byBmaXJzdCA0IGJ5dGVzXG5cblx0ICAgICAgYnVmZmVyJCQxWzNdID0gdGltZSAmIDB4ZmY7XG5cdCAgICAgIGJ1ZmZlciQkMVsyXSA9IHRpbWUgPj4gOCAmIDB4ZmY7XG5cdCAgICAgIGJ1ZmZlciQkMVsxXSA9IHRpbWUgPj4gMTYgJiAweGZmO1xuXHQgICAgICBidWZmZXIkJDFbMF0gPSB0aW1lID4+IDI0ICYgMHhmZjsgLy8gUmV0dXJuIHRoZSBuZXcgb2JqZWN0SWRcblxuXHQgICAgICByZXR1cm4gbmV3IE9iamVjdElkKGJ1ZmZlciQkMSk7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIENyZWF0ZXMgYW4gT2JqZWN0SWQgZnJvbSBhIGhleCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gT2JqZWN0SWQuXG5cdCAgICAgKlxuXHQgICAgICogQG1ldGhvZFxuXHQgICAgICogQHBhcmFtIHtzdHJpbmd9IGhleFN0cmluZyBjcmVhdGUgYSBPYmplY3RJZCBmcm9tIGEgcGFzc2VkIGluIDI0IGJ5dGUgaGV4c3RyaW5nLlxuXHQgICAgICogQHJldHVybiB7T2JqZWN0SWR9IHJldHVybiB0aGUgY3JlYXRlZCBPYmplY3RJZFxuXHQgICAgICovXG5cblx0ICB9LCB7XG5cdCAgICBrZXk6IFwiY3JlYXRlRnJvbUhleFN0cmluZ1wiLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUZyb21IZXhTdHJpbmcoc3RyaW5nKSB7XG5cdCAgICAgIC8vIFRocm93IGFuIGVycm9yIGlmIGl0J3Mgbm90IGEgdmFsaWQgc2V0dXBcblx0ICAgICAgaWYgKHR5cGVvZiBzdHJpbmcgPT09ICd1bmRlZmluZWQnIHx8IHN0cmluZyAhPSBudWxsICYmIHN0cmluZy5sZW5ndGggIT09IDI0KSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgcGFzc2VkIGluIG11c3QgYmUgYSBzaW5nbGUgU3RyaW5nIG9mIDEyIGJ5dGVzIG9yIGEgc3RyaW5nIG9mIDI0IGhleCBjaGFyYWN0ZXJzJyk7XG5cdCAgICAgIH0gLy8gVXNlIEJ1ZmZlci5mcm9tIG1ldGhvZCBpZiBhdmFpbGFibGVcblxuXG5cdCAgICAgIGlmIChoYXNCdWZmZXJUeXBlKSByZXR1cm4gbmV3IE9iamVjdElkKEJ1ZmZlciQxLmZyb20oc3RyaW5nLCAnaGV4JykpOyAvLyBDYWxjdWxhdGUgbGVuZ3Roc1xuXG5cdCAgICAgIHZhciBhcnJheSA9IG5ldyBfQnVmZmVyKDEyKTtcblx0ICAgICAgdmFyIG4gPSAwO1xuXHQgICAgICB2YXIgaSA9IDA7XG5cblx0ICAgICAgd2hpbGUgKGkgPCAyNCkge1xuXHQgICAgICAgIGFycmF5W24rK10gPSBkZWNvZGVMb29rdXBbc3RyaW5nLmNoYXJDb2RlQXQoaSsrKV0gPDwgNCB8IGRlY29kZUxvb2t1cFtzdHJpbmcuY2hhckNvZGVBdChpKyspXTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiBuZXcgT2JqZWN0SWQoYXJyYXkpO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBDaGVja3MgaWYgYSB2YWx1ZSBpcyBhIHZhbGlkIGJzb24gT2JqZWN0SWRcblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kXG5cdCAgICAgKiBAcmV0dXJuIHtib29sZWFufSByZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSB2YWxpZCBic29uIE9iamVjdElkLCByZXR1cm4gZmFsc2Ugb3RoZXJ3aXNlLlxuXHQgICAgICovXG5cblx0ICB9LCB7XG5cdCAgICBrZXk6IFwiaXNWYWxpZFwiLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGlzVmFsaWQoaWQpIHtcblx0ICAgICAgaWYgKGlkID09IG51bGwpIHJldHVybiBmYWxzZTtcblxuXHQgICAgICBpZiAodHlwZW9mIGlkID09PSAnbnVtYmVyJykge1xuXHQgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3N0cmluZycpIHtcblx0ICAgICAgICByZXR1cm4gaWQubGVuZ3RoID09PSAxMiB8fCBpZC5sZW5ndGggPT09IDI0ICYmIGNoZWNrRm9ySGV4UmVnRXhwLnRlc3QoaWQpO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKGlkIGluc3RhbmNlb2YgT2JqZWN0SWQpIHtcblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChpZCBpbnN0YW5jZW9mIF9CdWZmZXIgJiYgaWQubGVuZ3RoID09PSAxMikge1xuXHQgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICB9IC8vIER1Y2stVHlwaW5nIGRldGVjdGlvbiBvZiBPYmplY3RJZCBsaWtlIG9iamVjdHNcblxuXG5cdCAgICAgIGlmIChpZC50b0hleFN0cmluZykge1xuXHQgICAgICAgIHJldHVybiBpZC5pZC5sZW5ndGggPT09IDEyIHx8IGlkLmlkLmxlbmd0aCA9PT0gMjQgJiYgY2hlY2tGb3JIZXhSZWdFeHAudGVzdChpZC5pZCk7XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgfSwge1xuXHQgICAga2V5OiBcImZyb21FeHRlbmRlZEpTT05cIixcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tRXh0ZW5kZWRKU09OKGRvYykge1xuXHQgICAgICByZXR1cm4gbmV3IE9iamVjdElkKGRvYy4kb2lkKTtcblx0ICAgIH1cblx0ICB9XSk7XG5cblx0ICByZXR1cm4gT2JqZWN0SWQ7XG5cdH0oKTsgLy8gRGVwcmVjYXRlZCBtZXRob2RzXG5cblxuXHRPYmplY3RJZC5nZXRfaW5jID0gZGVwcmVjYXRlJDEoZnVuY3Rpb24gKCkge1xuXHQgIHJldHVybiBPYmplY3RJZC5nZXRJbmMoKTtcblx0fSwgJ1BsZWFzZSB1c2UgdGhlIHN0YXRpYyBgT2JqZWN0SWQuZ2V0SW5jKClgIGluc3RlYWQnKTtcblx0T2JqZWN0SWQucHJvdG90eXBlLmdldF9pbmMgPSBkZXByZWNhdGUkMShmdW5jdGlvbiAoKSB7XG5cdCAgcmV0dXJuIE9iamVjdElkLmdldEluYygpO1xuXHR9LCAnUGxlYXNlIHVzZSB0aGUgc3RhdGljIGBPYmplY3RJZC5nZXRJbmMoKWAgaW5zdGVhZCcpO1xuXHRPYmplY3RJZC5wcm90b3R5cGUuZ2V0SW5jID0gZGVwcmVjYXRlJDEoZnVuY3Rpb24gKCkge1xuXHQgIHJldHVybiBPYmplY3RJZC5nZXRJbmMoKTtcblx0fSwgJ1BsZWFzZSB1c2UgdGhlIHN0YXRpYyBgT2JqZWN0SWQuZ2V0SW5jKClgIGluc3RlYWQnKTtcblx0T2JqZWN0SWQucHJvdG90eXBlLmdlbmVyYXRlID0gZGVwcmVjYXRlJDEoZnVuY3Rpb24gKHRpbWUpIHtcblx0ICByZXR1cm4gT2JqZWN0SWQuZ2VuZXJhdGUodGltZSk7XG5cdH0sICdQbGVhc2UgdXNlIHRoZSBzdGF0aWMgYE9iamVjdElkLmdlbmVyYXRlKHRpbWUpYCBpbnN0ZWFkJyk7XG5cdC8qKlxuXHQgKiBAaWdub3JlXG5cdCAqL1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3RJZC5wcm90b3R5cGUsICdnZW5lcmF0aW9uVGltZScsIHtcblx0ICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgcmV0dXJuIHRoaXMuaWRbM10gfCB0aGlzLmlkWzJdIDw8IDggfCB0aGlzLmlkWzFdIDw8IDE2IHwgdGhpcy5pZFswXSA8PCAyNDtcblx0ICB9LFxuXHQgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG5cdCAgICAvLyBFbmNvZGUgdGltZSBpbnRvIGZpcnN0IDQgYnl0ZXNcblx0ICAgIHRoaXMuaWRbM10gPSB2YWx1ZSAmIDB4ZmY7XG5cdCAgICB0aGlzLmlkWzJdID0gdmFsdWUgPj4gOCAmIDB4ZmY7XG5cdCAgICB0aGlzLmlkWzFdID0gdmFsdWUgPj4gMTYgJiAweGZmO1xuXHQgICAgdGhpcy5pZFswXSA9IHZhbHVlID4+IDI0ICYgMHhmZjtcblx0ICB9XG5cdH0pO1xuXHQvKipcblx0ICogQ29udmVydHMgdG8gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBJZC5cblx0ICpcblx0ICogQHJldHVybiB7U3RyaW5nfSByZXR1cm4gdGhlIDI0IGJ5dGUgaGV4IHN0cmluZyByZXByZXNlbnRhdGlvbi5cblx0ICogQGlnbm9yZVxuXHQgKi9cblxuXHRPYmplY3RJZC5wcm90b3R5cGVbdXRpbCQyLmluc3BlY3QuY3VzdG9tIHx8ICdpbnNwZWN0J10gPSBPYmplY3RJZC5wcm90b3R5cGUudG9TdHJpbmc7XG5cdC8qKlxuXHQgKiBAaWdub3JlXG5cdCAqL1xuXG5cdE9iamVjdElkLmluZGV4ID0gfn4oTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmKTsgLy8gSW4gNC4wLjAgYW5kIDQuMC4xLCB0aGlzIHByb3BlcnR5IG5hbWUgd2FzIGNoYW5nZWQgdG8gT2JqZWN0SWQgdG8gbWF0Y2ggdGhlIGNsYXNzIG5hbWUuXG5cdC8vIFRoaXMgY2F1c2VkIGludGVyb3BlcmFiaWxpdHkgcHJvYmxlbXMgd2l0aCBwcmV2aW91cyB2ZXJzaW9ucyBvZiB0aGUgbGlicmFyeSwgc28gaW5cblx0Ly8gbGF0ZXIgYnVpbGRzIHdlIGNoYW5nZWQgaXQgYmFjayB0byBPYmplY3RJRCAoY2FwaXRhbCBEKSB0byBtYXRjaCBsZWdhY3kgaW1wbGVtZW50YXRpb25zLlxuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3RJZC5wcm90b3R5cGUsICdfYnNvbnR5cGUnLCB7XG5cdCAgdmFsdWU6ICdPYmplY3RJRCdcblx0fSk7XG5cdHZhciBvYmplY3RpZCA9IE9iamVjdElkO1xuXG5cdGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayQzKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuXHRmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyQzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuXHRmdW5jdGlvbiBfY3JlYXRlQ2xhc3MkMyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzJDMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyQzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5cdGZ1bmN0aW9uIGFscGhhYmV0aXplKHN0cikge1xuXHQgIHJldHVybiBzdHIuc3BsaXQoJycpLnNvcnQoKS5qb2luKCcnKTtcblx0fVxuXHQvKipcblx0ICogQSBjbGFzcyByZXByZXNlbnRhdGlvbiBvZiB0aGUgQlNPTiBSZWdFeHAgdHlwZS5cblx0ICovXG5cblxuXHR2YXIgQlNPTlJlZ0V4cCA9XG5cdC8qI19fUFVSRV9fKi9cblx0ZnVuY3Rpb24gKCkge1xuXHQgIC8qKlxuXHQgICAqIENyZWF0ZSBhIFJlZ0V4cCB0eXBlXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0dGVybiBUaGUgcmVndWxhciBleHByZXNzaW9uIHBhdHRlcm4gdG8gbWF0Y2hcblx0ICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucyBUaGUgcmVndWxhciBleHByZXNzaW9uIG9wdGlvbnNcblx0ICAgKi9cblx0ICBmdW5jdGlvbiBCU09OUmVnRXhwKHBhdHRlcm4sIG9wdGlvbnMpIHtcblx0ICAgIF9jbGFzc0NhbGxDaGVjayQzKHRoaXMsIEJTT05SZWdFeHApO1xuXG5cdCAgICAvLyBFeGVjdXRlXG5cdCAgICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuIHx8ICcnO1xuXHQgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyA/IGFscGhhYmV0aXplKG9wdGlvbnMpIDogJyc7IC8vIFZhbGlkYXRlIG9wdGlvbnNcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9wdGlvbnMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgaWYgKCEodGhpcy5vcHRpb25zW2ldID09PSAnaScgfHwgdGhpcy5vcHRpb25zW2ldID09PSAnbScgfHwgdGhpcy5vcHRpb25zW2ldID09PSAneCcgfHwgdGhpcy5vcHRpb25zW2ldID09PSAnbCcgfHwgdGhpcy5vcHRpb25zW2ldID09PSAncycgfHwgdGhpcy5vcHRpb25zW2ldID09PSAndScpKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBvcHRpb24gW1wiLmNvbmNhdCh0aGlzLm9wdGlvbnNbaV0sIFwiXSBpcyBub3Qgc3VwcG9ydGVkXCIpKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0ICAvKipcblx0ICAgKiBAaWdub3JlXG5cdCAgICovXG5cblxuXHQgIF9jcmVhdGVDbGFzcyQzKEJTT05SZWdFeHAsIFt7XG5cdCAgICBrZXk6IFwidG9FeHRlbmRlZEpTT05cIixcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiB0b0V4dGVuZGVkSlNPTigpIHtcblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAkcmVndWxhckV4cHJlc3Npb246IHtcblx0ICAgICAgICAgIHBhdHRlcm46IHRoaXMucGF0dGVybixcblx0ICAgICAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9uc1xuXHQgICAgICAgIH1cblx0ICAgICAgfTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogQGlnbm9yZVxuXHQgICAgICovXG5cblx0ICB9XSwgW3tcblx0ICAgIGtleTogXCJmcm9tRXh0ZW5kZWRKU09OXCIsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUV4dGVuZGVkSlNPTihkb2MpIHtcblx0ICAgICAgcmV0dXJuIG5ldyBCU09OUmVnRXhwKGRvYy4kcmVndWxhckV4cHJlc3Npb24ucGF0dGVybiwgZG9jLiRyZWd1bGFyRXhwcmVzc2lvbi5vcHRpb25zLnNwbGl0KCcnKS5zb3J0KCkuam9pbignJykpO1xuXHQgICAgfVxuXHQgIH1dKTtcblxuXHQgIHJldHVybiBCU09OUmVnRXhwO1xuXHR9KCk7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KEJTT05SZWdFeHAucHJvdG90eXBlLCAnX2Jzb250eXBlJywge1xuXHQgIHZhbHVlOiAnQlNPTlJlZ0V4cCdcblx0fSk7XG5cdHZhciByZWdleHAgPSBCU09OUmVnRXhwO1xuXG5cdC8qKlxuXHQgKiBBIGNsYXNzIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBCU09OIFN5bWJvbCB0eXBlLlxuXHQgKi9cblxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2skNChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cblx0ZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXMkNCh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cblx0ZnVuY3Rpb24gX2NyZWF0ZUNsYXNzJDQoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyQ0KENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMkNChDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuXHR2YXIgQlNPTlN5bWJvbCA9XG5cdC8qI19fUFVSRV9fKi9cblx0ZnVuY3Rpb24gKCkge1xuXHQgIC8qKlxuXHQgICAqIENyZWF0ZSBhIFN5bWJvbCB0eXBlXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgdGhlIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHN5bWJvbC5cblx0ICAgKi9cblx0ICBmdW5jdGlvbiBCU09OU3ltYm9sKHZhbHVlKSB7XG5cdCAgICBfY2xhc3NDYWxsQ2hlY2skNCh0aGlzLCBCU09OU3ltYm9sKTtcblxuXHQgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuXHQgIH1cblx0ICAvKipcblx0ICAgKiBBY2Nlc3MgdGhlIHdyYXBwZWQgc3RyaW5nIHZhbHVlLlxuXHQgICAqXG5cdCAgICogQG1ldGhvZFxuXHQgICAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgd3JhcHBlZCBzdHJpbmcuXG5cdCAgICovXG5cblxuXHQgIF9jcmVhdGVDbGFzcyQ0KEJTT05TeW1ib2wsIFt7XG5cdCAgICBrZXk6IFwidmFsdWVPZlwiLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlT2YoKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBAaWdub3JlXG5cdCAgICAgKi9cblxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHQgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogQGlnbm9yZVxuXHQgICAgICovXG5cblx0ICB9LCB7XG5cdCAgICBrZXk6IFwiaW5zcGVjdFwiLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBAaWdub3JlXG5cdCAgICAgKi9cblxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJ0b0pTT05cIixcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBAaWdub3JlXG5cdCAgICAgKi9cblxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJ0b0V4dGVuZGVkSlNPTlwiLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHRvRXh0ZW5kZWRKU09OKCkge1xuXHQgICAgICByZXR1cm4ge1xuXHQgICAgICAgICRzeW1ib2w6IHRoaXMudmFsdWVcblx0ICAgICAgfTtcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogQGlnbm9yZVxuXHQgICAgICovXG5cblx0ICB9XSwgW3tcblx0ICAgIGtleTogXCJmcm9tRXh0ZW5kZWRKU09OXCIsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUV4dGVuZGVkSlNPTihkb2MpIHtcblx0ICAgICAgcmV0dXJuIG5ldyBCU09OU3ltYm9sKGRvYy4kc3ltYm9sKTtcblx0ICAgIH1cblx0ICB9XSk7XG5cblx0ICByZXR1cm4gQlNPTlN5bWJvbDtcblx0fSgpO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCU09OU3ltYm9sLnByb3RvdHlwZSwgJ19ic29udHlwZScsIHtcblx0ICB2YWx1ZTogJ1N5bWJvbCdcblx0fSk7XG5cdHZhciBzeW1ib2wgPSBCU09OU3ltYm9sO1xuXG5cdC8qKlxuXHQgKiBBIGNsYXNzIHJlcHJlc2VudGF0aW9uIG9mIGEgQlNPTiBJbnQzMiB0eXBlLlxuXHQgKi9cblxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2skNShpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cblx0ZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXMkNSh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cblx0ZnVuY3Rpb24gX2NyZWF0ZUNsYXNzJDUoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyQ1KENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMkNShDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuXHR2YXIgSW50MzIgPVxuXHQvKiNfX1BVUkVfXyovXG5cdGZ1bmN0aW9uICgpIHtcblx0ICAvKipcblx0ICAgKiBDcmVhdGUgYW4gSW50MzIgdHlwZVxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIHRoZSBudW1iZXIgd2Ugd2FudCB0byByZXByZXNlbnQgYXMgYW4gaW50MzIuXG5cdCAgICogQHJldHVybiB7SW50MzJ9XG5cdCAgICovXG5cdCAgZnVuY3Rpb24gSW50MzIodmFsdWUpIHtcblx0ICAgIF9jbGFzc0NhbGxDaGVjayQ1KHRoaXMsIEludDMyKTtcblxuXHQgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuXHQgIH1cblx0ICAvKipcblx0ICAgKiBBY2Nlc3MgdGhlIG51bWJlciB2YWx1ZS5cblx0ICAgKlxuXHQgICAqIEBtZXRob2Rcblx0ICAgKiBAcmV0dXJuIHtudW1iZXJ9IHJldHVybnMgdGhlIHdyYXBwZWQgaW50MzIgbnVtYmVyLlxuXHQgICAqL1xuXG5cblx0ICBfY3JlYXRlQ2xhc3MkNShJbnQzMiwgW3tcblx0ICAgIGtleTogXCJ2YWx1ZU9mXCIsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWVPZigpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIEBpZ25vcmVcblx0ICAgICAqL1xuXG5cdCAgfSwge1xuXHQgICAga2V5OiBcInRvSlNPTlwiLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIEBpZ25vcmVcblx0ICAgICAqL1xuXG5cdCAgfSwge1xuXHQgICAga2V5OiBcInRvRXh0ZW5kZWRKU09OXCIsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gdG9FeHRlbmRlZEpTT04ob3B0aW9ucykge1xuXHQgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlbGF4ZWQpIHJldHVybiB0aGlzLnZhbHVlO1xuXHQgICAgICByZXR1cm4ge1xuXHQgICAgICAgICRudW1iZXJJbnQ6IHRoaXMudmFsdWUudG9TdHJpbmcoKVxuXHQgICAgICB9O1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBAaWdub3JlXG5cdCAgICAgKi9cblxuXHQgIH1dLCBbe1xuXHQgICAga2V5OiBcImZyb21FeHRlbmRlZEpTT05cIixcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tRXh0ZW5kZWRKU09OKGRvYywgb3B0aW9ucykge1xuXHQgICAgICByZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLnJlbGF4ZWQgPyBwYXJzZUludChkb2MuJG51bWJlckludCwgMTApIDogbmV3IEludDMyKGRvYy4kbnVtYmVySW50KTtcblx0ICAgIH1cblx0ICB9XSk7XG5cblx0ICByZXR1cm4gSW50MzI7XG5cdH0oKTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoSW50MzIucHJvdG90eXBlLCAnX2Jzb250eXBlJywge1xuXHQgIHZhbHVlOiAnSW50MzInXG5cdH0pO1xuXHR2YXIgaW50XzMyID0gSW50MzI7XG5cblx0LyoqXG5cdCAqIEEgY2xhc3MgcmVwcmVzZW50YXRpb24gb2YgdGhlIEJTT04gQ29kZSB0eXBlLlxuXHQgKi9cblxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2skNihpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cblx0ZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXMkNih0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cblx0ZnVuY3Rpb24gX2NyZWF0ZUNsYXNzJDYoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyQ2KENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMkNihDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuXHR2YXIgQ29kZSA9XG5cdC8qI19fUFVSRV9fKi9cblx0ZnVuY3Rpb24gKCkge1xuXHQgIC8qKlxuXHQgICAqIENyZWF0ZSBhIENvZGUgdHlwZVxuXHQgICAqXG5cdCAgICogQHBhcmFtIHsoc3RyaW5nfGZ1bmN0aW9uKX0gY29kZSBhIHN0cmluZyBvciBmdW5jdGlvbi5cblx0ICAgKiBAcGFyYW0ge09iamVjdH0gW3Njb3BlXSBhbiBvcHRpb25hbCBzY29wZSBmb3IgdGhlIGZ1bmN0aW9uLlxuXHQgICAqIEByZXR1cm4ge0NvZGV9XG5cdCAgICovXG5cdCAgZnVuY3Rpb24gQ29kZShjb2RlLCBzY29wZSkge1xuXHQgICAgX2NsYXNzQ2FsbENoZWNrJDYodGhpcywgQ29kZSk7XG5cblx0ICAgIHRoaXMuY29kZSA9IGNvZGU7XG5cdCAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIEBpZ25vcmVcblx0ICAgKi9cblxuXG5cdCAgX2NyZWF0ZUNsYXNzJDYoQ29kZSwgW3tcblx0ICAgIGtleTogXCJ0b0pTT05cIixcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG5cdCAgICAgIHJldHVybiB7XG5cdCAgICAgICAgc2NvcGU6IHRoaXMuc2NvcGUsXG5cdCAgICAgICAgY29kZTogdGhpcy5jb2RlXG5cdCAgICAgIH07XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIEBpZ25vcmVcblx0ICAgICAqL1xuXG5cdCAgfSwge1xuXHQgICAga2V5OiBcInRvRXh0ZW5kZWRKU09OXCIsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gdG9FeHRlbmRlZEpTT04oKSB7XG5cdCAgICAgIGlmICh0aGlzLnNjb3BlKSB7XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICRjb2RlOiB0aGlzLmNvZGUsXG5cdCAgICAgICAgICAkc2NvcGU6IHRoaXMuc2NvcGVcblx0ICAgICAgICB9O1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAkY29kZTogdGhpcy5jb2RlXG5cdCAgICAgIH07XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIEBpZ25vcmVcblx0ICAgICAqL1xuXG5cdCAgfV0sIFt7XG5cdCAgICBrZXk6IFwiZnJvbUV4dGVuZGVkSlNPTlwiLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21FeHRlbmRlZEpTT04oZG9jKSB7XG5cdCAgICAgIHJldHVybiBuZXcgQ29kZShkb2MuJGNvZGUsIGRvYy4kc2NvcGUpO1xuXHQgICAgfVxuXHQgIH1dKTtcblxuXHQgIHJldHVybiBDb2RlO1xuXHR9KCk7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KENvZGUucHJvdG90eXBlLCAnX2Jzb250eXBlJywge1xuXHQgIHZhbHVlOiAnQ29kZSdcblx0fSk7XG5cdHZhciBjb2RlID0gQ29kZTtcblxuXHR2YXIgQnVmZmVyJDIgPSBidWZmZXIuQnVmZmVyO1xuXHR2YXIgUEFSU0VfU1RSSU5HX1JFR0VYUCA9IC9eKFxcK3wtKT8oXFxkK3woXFxkKlxcLlxcZCopKT8oRXxlKT8oWy0rXSk/KFxcZCspPyQvO1xuXHR2YXIgUEFSU0VfSU5GX1JFR0VYUCA9IC9eKFxcK3wtKT8oSW5maW5pdHl8aW5mKSQvaTtcblx0dmFyIFBBUlNFX05BTl9SRUdFWFAgPSAvXihcXCt8LSk/TmFOJC9pO1xuXHR2YXIgRVhQT05FTlRfTUFYID0gNjExMTtcblx0dmFyIEVYUE9ORU5UX01JTiA9IC02MTc2O1xuXHR2YXIgRVhQT05FTlRfQklBUyA9IDYxNzY7XG5cdHZhciBNQVhfRElHSVRTID0gMzQ7IC8vIE5hbiB2YWx1ZSBiaXRzIGFzIDMyIGJpdCB2YWx1ZXMgKGR1ZSB0byBsYWNrIG9mIGxvbmdzKVxuXG5cdHZhciBOQU5fQlVGRkVSID0gWzB4N2MsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDBdLnJldmVyc2UoKTsgLy8gSW5maW5pdHkgdmFsdWUgYml0cyAzMiBiaXQgdmFsdWVzIChkdWUgdG8gbGFjayBvZiBsb25ncylcblxuXHR2YXIgSU5GX05FR0FUSVZFX0JVRkZFUiA9IFsweGY4LCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwXS5yZXZlcnNlKCk7XG5cdHZhciBJTkZfUE9TSVRJVkVfQlVGRkVSID0gWzB4NzgsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDBdLnJldmVyc2UoKTtcblx0dmFyIEVYUE9ORU5UX1JFR0VYID0gL14oWy0rXSk/KFxcZCspPyQvOyAvLyBEZXRlY3QgaWYgdGhlIHZhbHVlIGlzIGEgZGlnaXRcblxuXHRmdW5jdGlvbiBpc0RpZ2l0KHZhbHVlKSB7XG5cdCAgcmV0dXJuICFpc05hTihwYXJzZUludCh2YWx1ZSwgMTApKTtcblx0fSAvLyBEaXZpZGUgdHdvIHVpbnQxMjggdmFsdWVzXG5cblxuXHRmdW5jdGlvbiBkaXZpZGV1MTI4KHZhbHVlKSB7XG5cdCAgdmFyIERJVklTT1IgPSBsb25nXzEuZnJvbU51bWJlcigxMDAwICogMTAwMCAqIDEwMDApO1xuXG5cdCAgdmFyIF9yZW0gPSBsb25nXzEuZnJvbU51bWJlcigwKTtcblxuXHQgIGlmICghdmFsdWUucGFydHNbMF0gJiYgIXZhbHVlLnBhcnRzWzFdICYmICF2YWx1ZS5wYXJ0c1syXSAmJiAhdmFsdWUucGFydHNbM10pIHtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgIHF1b3RpZW50OiB2YWx1ZSxcblx0ICAgICAgcmVtOiBfcmVtXG5cdCAgICB9O1xuXHQgIH1cblxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDw9IDM7IGkrKykge1xuXHQgICAgLy8gQWRqdXN0IHJlbWFpbmRlciB0byBtYXRjaCB2YWx1ZSBvZiBuZXh0IGRpdmlkZW5kXG5cdCAgICBfcmVtID0gX3JlbS5zaGlmdExlZnQoMzIpOyAvLyBBZGQgdGhlIGRpdmlkZWQgdG8gX3JlbVxuXG5cdCAgICBfcmVtID0gX3JlbS5hZGQobmV3IGxvbmdfMSh2YWx1ZS5wYXJ0c1tpXSwgMCkpO1xuXHQgICAgdmFsdWUucGFydHNbaV0gPSBfcmVtLmRpdihESVZJU09SKS5sb3c7XG5cdCAgICBfcmVtID0gX3JlbS5tb2R1bG8oRElWSVNPUik7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHtcblx0ICAgIHF1b3RpZW50OiB2YWx1ZSxcblx0ICAgIHJlbTogX3JlbVxuXHQgIH07XG5cdH0gLy8gTXVsdGlwbHkgdHdvIExvbmcgdmFsdWVzIGFuZCByZXR1cm4gdGhlIDEyOCBiaXQgdmFsdWVcblxuXG5cdGZ1bmN0aW9uIG11bHRpcGx5NjR4MihsZWZ0LCByaWdodCkge1xuXHQgIGlmICghbGVmdCAmJiAhcmlnaHQpIHtcblx0ICAgIHJldHVybiB7XG5cdCAgICAgIGhpZ2g6IGxvbmdfMS5mcm9tTnVtYmVyKDApLFxuXHQgICAgICBsb3c6IGxvbmdfMS5mcm9tTnVtYmVyKDApXG5cdCAgICB9O1xuXHQgIH1cblxuXHQgIHZhciBsZWZ0SGlnaCA9IGxlZnQuc2hpZnRSaWdodFVuc2lnbmVkKDMyKTtcblx0ICB2YXIgbGVmdExvdyA9IG5ldyBsb25nXzEobGVmdC5nZXRMb3dCaXRzKCksIDApO1xuXHQgIHZhciByaWdodEhpZ2ggPSByaWdodC5zaGlmdFJpZ2h0VW5zaWduZWQoMzIpO1xuXHQgIHZhciByaWdodExvdyA9IG5ldyBsb25nXzEocmlnaHQuZ2V0TG93Qml0cygpLCAwKTtcblx0ICB2YXIgcHJvZHVjdEhpZ2ggPSBsZWZ0SGlnaC5tdWx0aXBseShyaWdodEhpZ2gpO1xuXHQgIHZhciBwcm9kdWN0TWlkID0gbGVmdEhpZ2gubXVsdGlwbHkocmlnaHRMb3cpO1xuXHQgIHZhciBwcm9kdWN0TWlkMiA9IGxlZnRMb3cubXVsdGlwbHkocmlnaHRIaWdoKTtcblx0ICB2YXIgcHJvZHVjdExvdyA9IGxlZnRMb3cubXVsdGlwbHkocmlnaHRMb3cpO1xuXHQgIHByb2R1Y3RIaWdoID0gcHJvZHVjdEhpZ2guYWRkKHByb2R1Y3RNaWQuc2hpZnRSaWdodFVuc2lnbmVkKDMyKSk7XG5cdCAgcHJvZHVjdE1pZCA9IG5ldyBsb25nXzEocHJvZHVjdE1pZC5nZXRMb3dCaXRzKCksIDApLmFkZChwcm9kdWN0TWlkMikuYWRkKHByb2R1Y3RMb3cuc2hpZnRSaWdodFVuc2lnbmVkKDMyKSk7XG5cdCAgcHJvZHVjdEhpZ2ggPSBwcm9kdWN0SGlnaC5hZGQocHJvZHVjdE1pZC5zaGlmdFJpZ2h0VW5zaWduZWQoMzIpKTtcblx0ICBwcm9kdWN0TG93ID0gcHJvZHVjdE1pZC5zaGlmdExlZnQoMzIpLmFkZChuZXcgbG9uZ18xKHByb2R1Y3RMb3cuZ2V0TG93Qml0cygpLCAwKSk7IC8vIFJldHVybiB0aGUgMTI4IGJpdCByZXN1bHRcblxuXHQgIHJldHVybiB7XG5cdCAgICBoaWdoOiBwcm9kdWN0SGlnaCxcblx0ICAgIGxvdzogcHJvZHVjdExvd1xuXHQgIH07XG5cdH1cblxuXHRmdW5jdGlvbiBsZXNzVGhhbihsZWZ0LCByaWdodCkge1xuXHQgIC8vIE1ha2UgdmFsdWVzIHVuc2lnbmVkXG5cdCAgdmFyIHVobGVmdCA9IGxlZnQuaGlnaCA+Pj4gMDtcblx0ICB2YXIgdWhyaWdodCA9IHJpZ2h0LmhpZ2ggPj4+IDA7IC8vIENvbXBhcmUgaGlnaCBiaXRzIGZpcnN0XG5cblx0ICBpZiAodWhsZWZ0IDwgdWhyaWdodCkge1xuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfSBlbHNlIGlmICh1aGxlZnQgPT09IHVocmlnaHQpIHtcblx0ICAgIHZhciB1bGxlZnQgPSBsZWZ0LmxvdyA+Pj4gMDtcblx0ICAgIHZhciB1bHJpZ2h0ID0gcmlnaHQubG93ID4+PiAwO1xuXHQgICAgaWYgKHVsbGVmdCA8IHVscmlnaHQpIHJldHVybiB0cnVlO1xuXHQgIH1cblxuXHQgIHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGludmFsaWRFcnIoc3RyaW5nLCBtZXNzYWdlKSB7XG5cdCAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlxcXCJcIi5jb25jYXQoc3RyaW5nLCBcIlxcXCIgaXMgbm90IGEgdmFsaWQgRGVjaW1hbDEyOCBzdHJpbmcgLSBcIikuY29uY2F0KG1lc3NhZ2UpKTtcblx0fVxuXHQvKipcblx0ICogQSBjbGFzcyByZXByZXNlbnRhdGlvbiBvZiB0aGUgQlNPTiBEZWNpbWFsMTI4IHR5cGUuXG5cdCAqXG5cdCAqIEBjbGFzc1xuXHQgKiBAcGFyYW0ge0J1ZmZlcn0gYnl0ZXMgYSBidWZmZXIgY29udGFpbmluZyB0aGUgcmF3IERlY2ltYWwxMjggYnl0ZXMuXG5cdCAqIEByZXR1cm4ge0RvdWJsZX1cblx0ICovXG5cblxuXHRmdW5jdGlvbiBEZWNpbWFsMTI4KGJ5dGVzKSB7XG5cdCAgdGhpcy5ieXRlcyA9IGJ5dGVzO1xuXHR9XG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBEZWNpbWFsMTI4IGluc3RhbmNlIGZyb20gYSBzdHJpbmcgcmVwcmVzZW50YXRpb25cblx0ICpcblx0ICogQG1ldGhvZFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIGEgbnVtZXJpYyBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG5cdCAqIEByZXR1cm4ge0RlY2ltYWwxMjh9IHJldHVybnMgYSBEZWNpbWFsMTI4IGluc3RhbmNlLlxuXHQgKi9cblxuXG5cdERlY2ltYWwxMjguZnJvbVN0cmluZyA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcblx0ICAvLyBQYXJzZSBzdGF0ZSB0cmFja2luZ1xuXHQgIHZhciBpc05lZ2F0aXZlID0gZmFsc2U7XG5cdCAgdmFyIHNhd1JhZGl4ID0gZmFsc2U7XG5cdCAgdmFyIGZvdW5kTm9uWmVybyA9IGZhbHNlOyAvLyBUb3RhbCBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIChubyBsZWFkaW5nIG9yIHRyYWlsaW5nIHplcm8pXG5cblx0ICB2YXIgc2lnbmlmaWNhbnREaWdpdHMgPSAwOyAvLyBUb3RhbCBudW1iZXIgb2Ygc2lnbmlmaWNhbmQgZGlnaXRzIHJlYWRcblxuXHQgIHZhciBuRGlnaXRzUmVhZCA9IDA7IC8vIFRvdGFsIG51bWJlciBvZiBkaWdpdHMgKG5vIGxlYWRpbmcgemVyb3MpXG5cblx0ICB2YXIgbkRpZ2l0cyA9IDA7IC8vIFRoZSBudW1iZXIgb2YgdGhlIGRpZ2l0cyBhZnRlciByYWRpeFxuXG5cdCAgdmFyIHJhZGl4UG9zaXRpb24gPSAwOyAvLyBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IG5vbi16ZXJvIGluICpzdHIqXG5cblx0ICB2YXIgZmlyc3ROb25aZXJvID0gMDsgLy8gRGlnaXRzIEFycmF5XG5cblx0ICB2YXIgZGlnaXRzID0gWzBdOyAvLyBUaGUgbnVtYmVyIG9mIGRpZ2l0cyBpbiBkaWdpdHNcblxuXHQgIHZhciBuRGlnaXRzU3RvcmVkID0gMDsgLy8gSW5zZXJ0aW9uIHBvaW50ZXIgZm9yIGRpZ2l0c1xuXG5cdCAgdmFyIGRpZ2l0c0luc2VydCA9IDA7IC8vIFRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgbm9uLXplcm8gZGlnaXRcblxuXHQgIHZhciBmaXJzdERpZ2l0ID0gMDsgLy8gVGhlIGluZGV4IG9mIHRoZSBsYXN0IGRpZ2l0XG5cblx0ICB2YXIgbGFzdERpZ2l0ID0gMDsgLy8gRXhwb25lbnRcblxuXHQgIHZhciBleHBvbmVudCA9IDA7IC8vIGxvb3AgaW5kZXggb3ZlciBhcnJheVxuXG5cdCAgdmFyIGkgPSAwOyAvLyBUaGUgaGlnaCAxNyBkaWdpdHMgb2YgdGhlIHNpZ25pZmljYW5kXG5cblx0ICB2YXIgc2lnbmlmaWNhbmRIaWdoID0gWzAsIDBdOyAvLyBUaGUgbG93IDE3IGRpZ2l0cyBvZiB0aGUgc2lnbmlmaWNhbmRcblxuXHQgIHZhciBzaWduaWZpY2FuZExvdyA9IFswLCAwXTsgLy8gVGhlIGJpYXNlZCBleHBvbmVudFxuXG5cdCAgdmFyIGJpYXNlZEV4cG9uZW50ID0gMDsgLy8gUmVhZCBpbmRleFxuXG5cdCAgdmFyIGluZGV4ID0gMDsgLy8gTmFpdmVseSBwcmV2ZW50IGFnYWluc3QgUkVET1MgYXR0YWNrcy5cblx0ICAvLyBUT0RPOiBpbXBsZW1lbnRpbmcgYSBjdXN0b20gcGFyc2luZyBmb3IgdGhpcywgb3IgcmVmYWN0b3JpbmcgdGhlIHJlZ2V4IHdvdWxkIHlpZWxkXG5cdCAgLy8gICAgICAgZnVydGhlciBnYWlucy5cblxuXHQgIGlmIChzdHJpbmcubGVuZ3RoID49IDcwMDApIHtcblx0ICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJycgKyBzdHJpbmcgKyAnIG5vdCBhIHZhbGlkIERlY2ltYWwxMjggc3RyaW5nJyk7XG5cdCAgfSAvLyBSZXN1bHRzXG5cblxuXHQgIHZhciBzdHJpbmdNYXRjaCA9IHN0cmluZy5tYXRjaChQQVJTRV9TVFJJTkdfUkVHRVhQKTtcblx0ICB2YXIgaW5mTWF0Y2ggPSBzdHJpbmcubWF0Y2goUEFSU0VfSU5GX1JFR0VYUCk7XG5cdCAgdmFyIG5hbk1hdGNoID0gc3RyaW5nLm1hdGNoKFBBUlNFX05BTl9SRUdFWFApOyAvLyBWYWxpZGF0ZSB0aGUgc3RyaW5nXG5cblx0ICBpZiAoIXN0cmluZ01hdGNoICYmICFpbmZNYXRjaCAmJiAhbmFuTWF0Y2ggfHwgc3RyaW5nLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignJyArIHN0cmluZyArICcgbm90IGEgdmFsaWQgRGVjaW1hbDEyOCBzdHJpbmcnKTtcblx0ICB9XG5cblx0ICBpZiAoc3RyaW5nTWF0Y2gpIHtcblx0ICAgIC8vIGZ1bGxfbWF0Y2ggPSBzdHJpbmdNYXRjaFswXVxuXHQgICAgLy8gc2lnbiA9IHN0cmluZ01hdGNoWzFdXG5cdCAgICB2YXIgdW5zaWduZWROdW1iZXIgPSBzdHJpbmdNYXRjaFsyXTsgLy8gc3RyaW5nTWF0Y2hbM10gaXMgdW5kZWZpbmVkIGlmIGEgd2hvbGUgbnVtYmVyIChleCBcIjFcIiwgMTJcIilcblx0ICAgIC8vIGJ1dCBkZWZpbmVkIGlmIGEgbnVtYmVyIHcvIGRlY2ltYWwgaW4gaXQgKGV4IFwiMS4wLCAxMi4yXCIpXG5cblx0ICAgIHZhciBlID0gc3RyaW5nTWF0Y2hbNF07XG5cdCAgICB2YXIgZXhwU2lnbiA9IHN0cmluZ01hdGNoWzVdO1xuXHQgICAgdmFyIGV4cE51bWJlciA9IHN0cmluZ01hdGNoWzZdOyAvLyB0aGV5IHByb3ZpZGVkIGUsIGJ1dCBkaWRuJ3QgZ2l2ZSBhbiBleHBvbmVudCBudW1iZXIuIGZvciBleCBcIjFlXCJcblxuXHQgICAgaWYgKGUgJiYgZXhwTnVtYmVyID09PSB1bmRlZmluZWQpIGludmFsaWRFcnIoc3RyaW5nLCAnbWlzc2luZyBleHBvbmVudCBwb3dlcicpOyAvLyB0aGV5IHByb3ZpZGVkIGUsIGJ1dCBkaWRuJ3QgZ2l2ZSBhIG51bWJlciBiZWZvcmUgaXQuIGZvciBleCBcImUxXCJcblxuXHQgICAgaWYgKGUgJiYgdW5zaWduZWROdW1iZXIgPT09IHVuZGVmaW5lZCkgaW52YWxpZEVycihzdHJpbmcsICdtaXNzaW5nIGV4cG9uZW50IGJhc2UnKTtcblxuXHQgICAgaWYgKGUgPT09IHVuZGVmaW5lZCAmJiAoZXhwU2lnbiB8fCBleHBOdW1iZXIpKSB7XG5cdCAgICAgIGludmFsaWRFcnIoc3RyaW5nLCAnbWlzc2luZyBlIGJlZm9yZSBleHBvbmVudCcpO1xuXHQgICAgfVxuXHQgIH0gLy8gR2V0IHRoZSBuZWdhdGl2ZSBvciBwb3NpdGl2ZSBzaWduXG5cblxuXHQgIGlmIChzdHJpbmdbaW5kZXhdID09PSAnKycgfHwgc3RyaW5nW2luZGV4XSA9PT0gJy0nKSB7XG5cdCAgICBpc05lZ2F0aXZlID0gc3RyaW5nW2luZGV4KytdID09PSAnLSc7XG5cdCAgfSAvLyBDaGVjayBpZiB1c2VyIHBhc3NlZCBJbmZpbml0eSBvciBOYU5cblxuXG5cdCAgaWYgKCFpc0RpZ2l0KHN0cmluZ1tpbmRleF0pICYmIHN0cmluZ1tpbmRleF0gIT09ICcuJykge1xuXHQgICAgaWYgKHN0cmluZ1tpbmRleF0gPT09ICdpJyB8fCBzdHJpbmdbaW5kZXhdID09PSAnSScpIHtcblx0ICAgICAgcmV0dXJuIG5ldyBEZWNpbWFsMTI4KEJ1ZmZlciQyLmZyb20oaXNOZWdhdGl2ZSA/IElORl9ORUdBVElWRV9CVUZGRVIgOiBJTkZfUE9TSVRJVkVfQlVGRkVSKSk7XG5cdCAgICB9IGVsc2UgaWYgKHN0cmluZ1tpbmRleF0gPT09ICdOJykge1xuXHQgICAgICByZXR1cm4gbmV3IERlY2ltYWwxMjgoQnVmZmVyJDIuZnJvbShOQU5fQlVGRkVSKSk7XG5cdCAgICB9XG5cdCAgfSAvLyBSZWFkIGFsbCB0aGUgZGlnaXRzXG5cblxuXHQgIHdoaWxlIChpc0RpZ2l0KHN0cmluZ1tpbmRleF0pIHx8IHN0cmluZ1tpbmRleF0gPT09ICcuJykge1xuXHQgICAgaWYgKHN0cmluZ1tpbmRleF0gPT09ICcuJykge1xuXHQgICAgICBpZiAoc2F3UmFkaXgpIGludmFsaWRFcnIoc3RyaW5nLCAnY29udGFpbnMgbXVsdGlwbGUgcGVyaW9kcycpO1xuXHQgICAgICBzYXdSYWRpeCA9IHRydWU7XG5cdCAgICAgIGluZGV4ID0gaW5kZXggKyAxO1xuXHQgICAgICBjb250aW51ZTtcblx0ICAgIH1cblxuXHQgICAgaWYgKG5EaWdpdHNTdG9yZWQgPCAzNCkge1xuXHQgICAgICBpZiAoc3RyaW5nW2luZGV4XSAhPT0gJzAnIHx8IGZvdW5kTm9uWmVybykge1xuXHQgICAgICAgIGlmICghZm91bmROb25aZXJvKSB7XG5cdCAgICAgICAgICBmaXJzdE5vblplcm8gPSBuRGlnaXRzUmVhZDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBmb3VuZE5vblplcm8gPSB0cnVlOyAvLyBPbmx5IHN0b3JlIDM0IGRpZ2l0c1xuXG5cdCAgICAgICAgZGlnaXRzW2RpZ2l0c0luc2VydCsrXSA9IHBhcnNlSW50KHN0cmluZ1tpbmRleF0sIDEwKTtcblx0ICAgICAgICBuRGlnaXRzU3RvcmVkID0gbkRpZ2l0c1N0b3JlZCArIDE7XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKGZvdW5kTm9uWmVybykgbkRpZ2l0cyA9IG5EaWdpdHMgKyAxO1xuXHQgICAgaWYgKHNhd1JhZGl4KSByYWRpeFBvc2l0aW9uID0gcmFkaXhQb3NpdGlvbiArIDE7XG5cdCAgICBuRGlnaXRzUmVhZCA9IG5EaWdpdHNSZWFkICsgMTtcblx0ICAgIGluZGV4ID0gaW5kZXggKyAxO1xuXHQgIH1cblxuXHQgIGlmIChzYXdSYWRpeCAmJiAhbkRpZ2l0c1JlYWQpIHRocm93IG5ldyBUeXBlRXJyb3IoJycgKyBzdHJpbmcgKyAnIG5vdCBhIHZhbGlkIERlY2ltYWwxMjggc3RyaW5nJyk7IC8vIFJlYWQgZXhwb25lbnQgaWYgZXhpc3RzXG5cblx0ICBpZiAoc3RyaW5nW2luZGV4XSA9PT0gJ2UnIHx8IHN0cmluZ1tpbmRleF0gPT09ICdFJykge1xuXHQgICAgLy8gUmVhZCBleHBvbmVudCBkaWdpdHNcblx0ICAgIHZhciBtYXRjaCA9IHN0cmluZy5zdWJzdHIoKytpbmRleCkubWF0Y2goRVhQT05FTlRfUkVHRVgpOyAvLyBObyBkaWdpdHMgcmVhZFxuXG5cdCAgICBpZiAoIW1hdGNoIHx8ICFtYXRjaFsyXSkgcmV0dXJuIG5ldyBEZWNpbWFsMTI4KEJ1ZmZlciQyLmZyb20oTkFOX0JVRkZFUikpOyAvLyBHZXQgZXhwb25lbnRcblxuXHQgICAgZXhwb25lbnQgPSBwYXJzZUludChtYXRjaFswXSwgMTApOyAvLyBBZGp1c3QgdGhlIGluZGV4XG5cblx0ICAgIGluZGV4ID0gaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG5cdCAgfSAvLyBSZXR1cm4gbm90IGEgbnVtYmVyXG5cblxuXHQgIGlmIChzdHJpbmdbaW5kZXhdKSByZXR1cm4gbmV3IERlY2ltYWwxMjgoQnVmZmVyJDIuZnJvbShOQU5fQlVGRkVSKSk7IC8vIERvbmUgcmVhZGluZyBpbnB1dFxuXHQgIC8vIEZpbmQgZmlyc3Qgbm9uLXplcm8gZGlnaXQgaW4gZGlnaXRzXG5cblx0ICBmaXJzdERpZ2l0ID0gMDtcblxuXHQgIGlmICghbkRpZ2l0c1N0b3JlZCkge1xuXHQgICAgZmlyc3REaWdpdCA9IDA7XG5cdCAgICBsYXN0RGlnaXQgPSAwO1xuXHQgICAgZGlnaXRzWzBdID0gMDtcblx0ICAgIG5EaWdpdHMgPSAxO1xuXHQgICAgbkRpZ2l0c1N0b3JlZCA9IDE7XG5cdCAgICBzaWduaWZpY2FudERpZ2l0cyA9IDA7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGxhc3REaWdpdCA9IG5EaWdpdHNTdG9yZWQgLSAxO1xuXHQgICAgc2lnbmlmaWNhbnREaWdpdHMgPSBuRGlnaXRzO1xuXG5cdCAgICBpZiAoc2lnbmlmaWNhbnREaWdpdHMgIT09IDEpIHtcblx0ICAgICAgd2hpbGUgKHN0cmluZ1tmaXJzdE5vblplcm8gKyBzaWduaWZpY2FudERpZ2l0cyAtIDFdID09PSAnMCcpIHtcblx0ICAgICAgICBzaWduaWZpY2FudERpZ2l0cyA9IHNpZ25pZmljYW50RGlnaXRzIC0gMTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0gLy8gTm9ybWFsaXphdGlvbiBvZiBleHBvbmVudFxuXHQgIC8vIENvcnJlY3QgZXhwb25lbnQgYmFzZWQgb24gcmFkaXggcG9zaXRpb24sIGFuZCBzaGlmdCBzaWduaWZpY2FuZCBhcyBuZWVkZWRcblx0ICAvLyB0byByZXByZXNlbnQgdXNlciBpbnB1dFxuXHQgIC8vIE92ZXJmbG93IHByZXZlbnRpb25cblxuXG5cdCAgaWYgKGV4cG9uZW50IDw9IHJhZGl4UG9zaXRpb24gJiYgcmFkaXhQb3NpdGlvbiAtIGV4cG9uZW50ID4gMSA8PCAxNCkge1xuXHQgICAgZXhwb25lbnQgPSBFWFBPTkVOVF9NSU47XG5cdCAgfSBlbHNlIHtcblx0ICAgIGV4cG9uZW50ID0gZXhwb25lbnQgLSByYWRpeFBvc2l0aW9uO1xuXHQgIH0gLy8gQXR0ZW1wdCB0byBub3JtYWxpemUgdGhlIGV4cG9uZW50XG5cblxuXHQgIHdoaWxlIChleHBvbmVudCA+IEVYUE9ORU5UX01BWCkge1xuXHQgICAgLy8gU2hpZnQgZXhwb25lbnQgdG8gc2lnbmlmaWNhbmQgYW5kIGRlY3JlYXNlXG5cdCAgICBsYXN0RGlnaXQgPSBsYXN0RGlnaXQgKyAxO1xuXG5cdCAgICBpZiAobGFzdERpZ2l0IC0gZmlyc3REaWdpdCA+IE1BWF9ESUdJVFMpIHtcblx0ICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBhIHplcm8gdGhlbiBqdXN0IGhhcmQgY2xhbXAsIG90aGVyd2lzZSBmYWlsXG5cdCAgICAgIHZhciBkaWdpdHNTdHJpbmcgPSBkaWdpdHMuam9pbignJyk7XG5cblx0ICAgICAgaWYgKGRpZ2l0c1N0cmluZy5tYXRjaCgvXjArJC8pKSB7XG5cdCAgICAgICAgZXhwb25lbnQgPSBFWFBPTkVOVF9NQVg7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIH1cblxuXHQgICAgICBpbnZhbGlkRXJyKHN0cmluZywgJ292ZXJmbG93Jyk7XG5cdCAgICB9XG5cblx0ICAgIGV4cG9uZW50ID0gZXhwb25lbnQgLSAxO1xuXHQgIH1cblxuXHQgIHdoaWxlIChleHBvbmVudCA8IEVYUE9ORU5UX01JTiB8fCBuRGlnaXRzU3RvcmVkIDwgbkRpZ2l0cykge1xuXHQgICAgLy8gU2hpZnQgbGFzdCBkaWdpdC4gY2FuIG9ubHkgZG8gdGhpcyBpZiA8IHNpZ25pZmljYW50IGRpZ2l0cyB0aGFuICMgc3RvcmVkLlxuXHQgICAgaWYgKGxhc3REaWdpdCA9PT0gMCAmJiBzaWduaWZpY2FudERpZ2l0cyA8IG5EaWdpdHNTdG9yZWQpIHtcblx0ICAgICAgZXhwb25lbnQgPSBFWFBPTkVOVF9NSU47XG5cdCAgICAgIHNpZ25pZmljYW50RGlnaXRzID0gMDtcblx0ICAgICAgYnJlYWs7XG5cdCAgICB9XG5cblx0ICAgIGlmIChuRGlnaXRzU3RvcmVkIDwgbkRpZ2l0cykge1xuXHQgICAgICAvLyBhZGp1c3QgdG8gbWF0Y2ggZGlnaXRzIG5vdCBzdG9yZWRcblx0ICAgICAgbkRpZ2l0cyA9IG5EaWdpdHMgLSAxO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLy8gYWRqdXN0IHRvIHJvdW5kXG5cdCAgICAgIGxhc3REaWdpdCA9IGxhc3REaWdpdCAtIDE7XG5cdCAgICB9XG5cblx0ICAgIGlmIChleHBvbmVudCA8IEVYUE9ORU5UX01BWCkge1xuXHQgICAgICBleHBvbmVudCA9IGV4cG9uZW50ICsgMTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgYSB6ZXJvIHRoZW4ganVzdCBoYXJkIGNsYW1wLCBvdGhlcndpc2UgZmFpbFxuXHQgICAgICB2YXIgX2RpZ2l0c1N0cmluZyA9IGRpZ2l0cy5qb2luKCcnKTtcblxuXHQgICAgICBpZiAoX2RpZ2l0c1N0cmluZy5tYXRjaCgvXjArJC8pKSB7XG5cdCAgICAgICAgZXhwb25lbnQgPSBFWFBPTkVOVF9NQVg7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIH1cblxuXHQgICAgICBpbnZhbGlkRXJyKHN0cmluZywgJ292ZXJmbG93Jyk7XG5cdCAgICB9XG5cdCAgfSAvLyBSb3VuZFxuXHQgIC8vIFdlJ3ZlIG5vcm1hbGl6ZWQgdGhlIGV4cG9uZW50LCBidXQgbWlnaHQgc3RpbGwgbmVlZCB0byByb3VuZC5cblxuXG5cdCAgaWYgKGxhc3REaWdpdCAtIGZpcnN0RGlnaXQgKyAxIDwgc2lnbmlmaWNhbnREaWdpdHMpIHtcblx0ICAgIHZhciBlbmRPZlN0cmluZyA9IG5EaWdpdHNSZWFkOyAvLyBJZiB3ZSBoYXZlIHNlZW4gYSByYWRpeCBwb2ludCwgJ3N0cmluZycgaXMgMSBsb25nZXIgdGhhbiB3ZSBoYXZlXG5cdCAgICAvLyBkb2N1bWVudGVkIHdpdGggbmRpZ2l0c19yZWFkLCBzbyBpbmMgdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBub256ZXJvXG5cdCAgICAvLyBkaWdpdCBhbmQgdGhlIHBvc2l0aW9uIHRoYXQgZGlnaXRzIGFyZSByZWFkIHRvLlxuXG5cdCAgICBpZiAoc2F3UmFkaXgpIHtcblx0ICAgICAgZmlyc3ROb25aZXJvID0gZmlyc3ROb25aZXJvICsgMTtcblx0ICAgICAgZW5kT2ZTdHJpbmcgPSBlbmRPZlN0cmluZyArIDE7XG5cdCAgICB9IC8vIGlmIG5lZ2F0aXZlLCB3ZSBuZWVkIHRvIGluY3JlbWVudCBhZ2FpbiB0byBhY2NvdW50IGZvciAtIHNpZ24gYXQgc3RhcnQuXG5cblxuXHQgICAgaWYgKGlzTmVnYXRpdmUpIHtcblx0ICAgICAgZmlyc3ROb25aZXJvID0gZmlyc3ROb25aZXJvICsgMTtcblx0ICAgICAgZW5kT2ZTdHJpbmcgPSBlbmRPZlN0cmluZyArIDE7XG5cdCAgICB9XG5cblx0ICAgIHZhciByb3VuZERpZ2l0ID0gcGFyc2VJbnQoc3RyaW5nW2ZpcnN0Tm9uWmVybyArIGxhc3REaWdpdCArIDFdLCAxMCk7XG5cdCAgICB2YXIgcm91bmRCaXQgPSAwO1xuXG5cdCAgICBpZiAocm91bmREaWdpdCA+PSA1KSB7XG5cdCAgICAgIHJvdW5kQml0ID0gMTtcblxuXHQgICAgICBpZiAocm91bmREaWdpdCA9PT0gNSkge1xuXHQgICAgICAgIHJvdW5kQml0ID0gZGlnaXRzW2xhc3REaWdpdF0gJSAyID09PSAxO1xuXG5cdCAgICAgICAgZm9yIChpID0gZmlyc3ROb25aZXJvICsgbGFzdERpZ2l0ICsgMjsgaSA8IGVuZE9mU3RyaW5nOyBpKyspIHtcblx0ICAgICAgICAgIGlmIChwYXJzZUludChzdHJpbmdbaV0sIDEwKSkge1xuXHQgICAgICAgICAgICByb3VuZEJpdCA9IDE7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAocm91bmRCaXQpIHtcblx0ICAgICAgdmFyIGRJZHggPSBsYXN0RGlnaXQ7XG5cblx0ICAgICAgZm9yICg7IGRJZHggPj0gMDsgZElkeC0tKSB7XG5cdCAgICAgICAgaWYgKCsrZGlnaXRzW2RJZHhdID4gOSkge1xuXHQgICAgICAgICAgZGlnaXRzW2RJZHhdID0gMDsgLy8gb3ZlcmZsb3dlZCBtb3N0IHNpZ25pZmljYW50IGRpZ2l0XG5cblx0ICAgICAgICAgIGlmIChkSWR4ID09PSAwKSB7XG5cdCAgICAgICAgICAgIGlmIChleHBvbmVudCA8IEVYUE9ORU5UX01BWCkge1xuXHQgICAgICAgICAgICAgIGV4cG9uZW50ID0gZXhwb25lbnQgKyAxO1xuXHQgICAgICAgICAgICAgIGRpZ2l0c1tkSWR4XSA9IDE7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNpbWFsMTI4KEJ1ZmZlciQyLmZyb20oaXNOZWdhdGl2ZSA/IElORl9ORUdBVElWRV9CVUZGRVIgOiBJTkZfUE9TSVRJVkVfQlVGRkVSKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9IC8vIEVuY29kZSBzaWduaWZpY2FuZFxuXHQgIC8vIFRoZSBoaWdoIDE3IGRpZ2l0cyBvZiB0aGUgc2lnbmlmaWNhbmRcblxuXG5cdCAgc2lnbmlmaWNhbmRIaWdoID0gbG9uZ18xLmZyb21OdW1iZXIoMCk7IC8vIFRoZSBsb3cgMTcgZGlnaXRzIG9mIHRoZSBzaWduaWZpY2FuZFxuXG5cdCAgc2lnbmlmaWNhbmRMb3cgPSBsb25nXzEuZnJvbU51bWJlcigwKTsgLy8gcmVhZCBhIHplcm9cblxuXHQgIGlmIChzaWduaWZpY2FudERpZ2l0cyA9PT0gMCkge1xuXHQgICAgc2lnbmlmaWNhbmRIaWdoID0gbG9uZ18xLmZyb21OdW1iZXIoMCk7XG5cdCAgICBzaWduaWZpY2FuZExvdyA9IGxvbmdfMS5mcm9tTnVtYmVyKDApO1xuXHQgIH0gZWxzZSBpZiAobGFzdERpZ2l0IC0gZmlyc3REaWdpdCA8IDE3KSB7XG5cdCAgICB2YXIgX2RJZHggPSBmaXJzdERpZ2l0O1xuXHQgICAgc2lnbmlmaWNhbmRMb3cgPSBsb25nXzEuZnJvbU51bWJlcihkaWdpdHNbX2RJZHgrK10pO1xuXHQgICAgc2lnbmlmaWNhbmRIaWdoID0gbmV3IGxvbmdfMSgwLCAwKTtcblxuXHQgICAgZm9yICg7IF9kSWR4IDw9IGxhc3REaWdpdDsgX2RJZHgrKykge1xuXHQgICAgICBzaWduaWZpY2FuZExvdyA9IHNpZ25pZmljYW5kTG93Lm11bHRpcGx5KGxvbmdfMS5mcm9tTnVtYmVyKDEwKSk7XG5cdCAgICAgIHNpZ25pZmljYW5kTG93ID0gc2lnbmlmaWNhbmRMb3cuYWRkKGxvbmdfMS5mcm9tTnVtYmVyKGRpZ2l0c1tfZElkeF0pKTtcblx0ICAgIH1cblx0ICB9IGVsc2Uge1xuXHQgICAgdmFyIF9kSWR4MiA9IGZpcnN0RGlnaXQ7XG5cdCAgICBzaWduaWZpY2FuZEhpZ2ggPSBsb25nXzEuZnJvbU51bWJlcihkaWdpdHNbX2RJZHgyKytdKTtcblxuXHQgICAgZm9yICg7IF9kSWR4MiA8PSBsYXN0RGlnaXQgLSAxNzsgX2RJZHgyKyspIHtcblx0ICAgICAgc2lnbmlmaWNhbmRIaWdoID0gc2lnbmlmaWNhbmRIaWdoLm11bHRpcGx5KGxvbmdfMS5mcm9tTnVtYmVyKDEwKSk7XG5cdCAgICAgIHNpZ25pZmljYW5kSGlnaCA9IHNpZ25pZmljYW5kSGlnaC5hZGQobG9uZ18xLmZyb21OdW1iZXIoZGlnaXRzW19kSWR4Ml0pKTtcblx0ICAgIH1cblxuXHQgICAgc2lnbmlmaWNhbmRMb3cgPSBsb25nXzEuZnJvbU51bWJlcihkaWdpdHNbX2RJZHgyKytdKTtcblxuXHQgICAgZm9yICg7IF9kSWR4MiA8PSBsYXN0RGlnaXQ7IF9kSWR4MisrKSB7XG5cdCAgICAgIHNpZ25pZmljYW5kTG93ID0gc2lnbmlmaWNhbmRMb3cubXVsdGlwbHkobG9uZ18xLmZyb21OdW1iZXIoMTApKTtcblx0ICAgICAgc2lnbmlmaWNhbmRMb3cgPSBzaWduaWZpY2FuZExvdy5hZGQobG9uZ18xLmZyb21OdW1iZXIoZGlnaXRzW19kSWR4Ml0pKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICB2YXIgc2lnbmlmaWNhbmQgPSBtdWx0aXBseTY0eDIoc2lnbmlmaWNhbmRIaWdoLCBsb25nXzEuZnJvbVN0cmluZygnMTAwMDAwMDAwMDAwMDAwMDAwJykpO1xuXHQgIHNpZ25pZmljYW5kLmxvdyA9IHNpZ25pZmljYW5kLmxvdy5hZGQoc2lnbmlmaWNhbmRMb3cpO1xuXG5cdCAgaWYgKGxlc3NUaGFuKHNpZ25pZmljYW5kLmxvdywgc2lnbmlmaWNhbmRMb3cpKSB7XG5cdCAgICBzaWduaWZpY2FuZC5oaWdoID0gc2lnbmlmaWNhbmQuaGlnaC5hZGQobG9uZ18xLmZyb21OdW1iZXIoMSkpO1xuXHQgIH0gLy8gQmlhc2VkIGV4cG9uZW50XG5cblxuXHQgIGJpYXNlZEV4cG9uZW50ID0gZXhwb25lbnQgKyBFWFBPTkVOVF9CSUFTO1xuXHQgIHZhciBkZWMgPSB7XG5cdCAgICBsb3c6IGxvbmdfMS5mcm9tTnVtYmVyKDApLFxuXHQgICAgaGlnaDogbG9uZ18xLmZyb21OdW1iZXIoMClcblx0ICB9OyAvLyBFbmNvZGUgY29tYmluYXRpb24sIGV4cG9uZW50LCBhbmQgc2lnbmlmaWNhbmQuXG5cblx0ICBpZiAoc2lnbmlmaWNhbmQuaGlnaC5zaGlmdFJpZ2h0VW5zaWduZWQoNDkpLmFuZChsb25nXzEuZnJvbU51bWJlcigxKSkuZXF1YWxzKGxvbmdfMS5mcm9tTnVtYmVyKDEpKSkge1xuXHQgICAgLy8gRW5jb2RlICcxMScgaW50byBiaXRzIDEgdG8gM1xuXHQgICAgZGVjLmhpZ2ggPSBkZWMuaGlnaC5vcihsb25nXzEuZnJvbU51bWJlcigweDMpLnNoaWZ0TGVmdCg2MSkpO1xuXHQgICAgZGVjLmhpZ2ggPSBkZWMuaGlnaC5vcihsb25nXzEuZnJvbU51bWJlcihiaWFzZWRFeHBvbmVudCkuYW5kKGxvbmdfMS5mcm9tTnVtYmVyKDB4M2ZmZikuc2hpZnRMZWZ0KDQ3KSkpO1xuXHQgICAgZGVjLmhpZ2ggPSBkZWMuaGlnaC5vcihzaWduaWZpY2FuZC5oaWdoLmFuZChsb25nXzEuZnJvbU51bWJlcigweDdmZmZmZmZmZmZmZikpKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgZGVjLmhpZ2ggPSBkZWMuaGlnaC5vcihsb25nXzEuZnJvbU51bWJlcihiaWFzZWRFeHBvbmVudCAmIDB4M2ZmZikuc2hpZnRMZWZ0KDQ5KSk7XG5cdCAgICBkZWMuaGlnaCA9IGRlYy5oaWdoLm9yKHNpZ25pZmljYW5kLmhpZ2guYW5kKGxvbmdfMS5mcm9tTnVtYmVyKDB4MWZmZmZmZmZmZmZmZikpKTtcblx0ICB9XG5cblx0ICBkZWMubG93ID0gc2lnbmlmaWNhbmQubG93OyAvLyBFbmNvZGUgc2lnblxuXG5cdCAgaWYgKGlzTmVnYXRpdmUpIHtcblx0ICAgIGRlYy5oaWdoID0gZGVjLmhpZ2gub3IobG9uZ18xLmZyb21TdHJpbmcoJzkyMjMzNzIwMzY4NTQ3NzU4MDgnKSk7XG5cdCAgfSAvLyBFbmNvZGUgaW50byBhIGJ1ZmZlclxuXG5cblx0ICB2YXIgYnVmZmVyJCQxID0gQnVmZmVyJDIuYWxsb2MoMTYpO1xuXHQgIGluZGV4ID0gMDsgLy8gRW5jb2RlIHRoZSBsb3cgNjQgYml0cyBvZiB0aGUgZGVjaW1hbFxuXHQgIC8vIEVuY29kZSBsb3cgYml0c1xuXG5cdCAgYnVmZmVyJCQxW2luZGV4KytdID0gZGVjLmxvdy5sb3cgJiAweGZmO1xuXHQgIGJ1ZmZlciQkMVtpbmRleCsrXSA9IGRlYy5sb3cubG93ID4+IDggJiAweGZmO1xuXHQgIGJ1ZmZlciQkMVtpbmRleCsrXSA9IGRlYy5sb3cubG93ID4+IDE2ICYgMHhmZjtcblx0ICBidWZmZXIkJDFbaW5kZXgrK10gPSBkZWMubG93LmxvdyA+PiAyNCAmIDB4ZmY7IC8vIEVuY29kZSBoaWdoIGJpdHNcblxuXHQgIGJ1ZmZlciQkMVtpbmRleCsrXSA9IGRlYy5sb3cuaGlnaCAmIDB4ZmY7XG5cdCAgYnVmZmVyJCQxW2luZGV4KytdID0gZGVjLmxvdy5oaWdoID4+IDggJiAweGZmO1xuXHQgIGJ1ZmZlciQkMVtpbmRleCsrXSA9IGRlYy5sb3cuaGlnaCA+PiAxNiAmIDB4ZmY7XG5cdCAgYnVmZmVyJCQxW2luZGV4KytdID0gZGVjLmxvdy5oaWdoID4+IDI0ICYgMHhmZjsgLy8gRW5jb2RlIHRoZSBoaWdoIDY0IGJpdHMgb2YgdGhlIGRlY2ltYWxcblx0ICAvLyBFbmNvZGUgbG93IGJpdHNcblxuXHQgIGJ1ZmZlciQkMVtpbmRleCsrXSA9IGRlYy5oaWdoLmxvdyAmIDB4ZmY7XG5cdCAgYnVmZmVyJCQxW2luZGV4KytdID0gZGVjLmhpZ2gubG93ID4+IDggJiAweGZmO1xuXHQgIGJ1ZmZlciQkMVtpbmRleCsrXSA9IGRlYy5oaWdoLmxvdyA+PiAxNiAmIDB4ZmY7XG5cdCAgYnVmZmVyJCQxW2luZGV4KytdID0gZGVjLmhpZ2gubG93ID4+IDI0ICYgMHhmZjsgLy8gRW5jb2RlIGhpZ2ggYml0c1xuXG5cdCAgYnVmZmVyJCQxW2luZGV4KytdID0gZGVjLmhpZ2guaGlnaCAmIDB4ZmY7XG5cdCAgYnVmZmVyJCQxW2luZGV4KytdID0gZGVjLmhpZ2guaGlnaCA+PiA4ICYgMHhmZjtcblx0ICBidWZmZXIkJDFbaW5kZXgrK10gPSBkZWMuaGlnaC5oaWdoID4+IDE2ICYgMHhmZjtcblx0ICBidWZmZXIkJDFbaW5kZXgrK10gPSBkZWMuaGlnaC5oaWdoID4+IDI0ICYgMHhmZjsgLy8gUmV0dXJuIHRoZSBuZXcgRGVjaW1hbDEyOFxuXG5cdCAgcmV0dXJuIG5ldyBEZWNpbWFsMTI4KGJ1ZmZlciQkMSk7XG5cdH07IC8vIEV4dHJhY3QgbGVhc3Qgc2lnbmlmaWNhbnQgNSBiaXRzXG5cblxuXHR2YXIgQ09NQklOQVRJT05fTUFTSyA9IDB4MWY7IC8vIEV4dHJhY3QgbGVhc3Qgc2lnbmlmaWNhbnQgMTQgYml0c1xuXG5cdHZhciBFWFBPTkVOVF9NQVNLID0gMHgzZmZmOyAvLyBWYWx1ZSBvZiBjb21iaW5hdGlvbiBmaWVsZCBmb3IgSW5mXG5cblx0dmFyIENPTUJJTkFUSU9OX0lORklOSVRZID0gMzA7IC8vIFZhbHVlIG9mIGNvbWJpbmF0aW9uIGZpZWxkIGZvciBOYU5cblxuXHR2YXIgQ09NQklOQVRJT05fTkFOID0gMzE7XG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHJhdyBEZWNpbWFsMTI4IHZhbHVlXG5cdCAqXG5cdCAqIEBtZXRob2Rcblx0ICogQHJldHVybiB7c3RyaW5nfSByZXR1cm5zIGEgRGVjaW1hbDEyOCBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG5cdCAqL1xuXG5cdERlY2ltYWwxMjgucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHQgIC8vIE5vdGU6IGJpdHMgaW4gdGhpcyByb3V0aW5lIGFyZSByZWZlcnJlZCB0byBzdGFydGluZyBhdCAwLFxuXHQgIC8vIGZyb20gdGhlIHNpZ24gYml0LCB0b3dhcmRzIHRoZSBjb2VmZmljaWVudC5cblx0ICAvLyBiaXRzIDAgLSAzMVxuXHQgIHZhciBoaWdoOyAvLyBiaXRzIDMyIC0gNjNcblxuXHQgIHZhciBtaWRoOyAvLyBiaXRzIDY0IC0gOTVcblxuXHQgIHZhciBtaWRsOyAvLyBiaXRzIDk2IC0gMTI3XG5cblx0ICB2YXIgbG93OyAvLyBiaXRzIDEgLSA1XG5cblx0ICB2YXIgY29tYmluYXRpb247IC8vIGRlY29kZWQgYmlhc2VkIGV4cG9uZW50ICgxNCBiaXRzKVxuXG5cdCAgdmFyIGJpYXNlZF9leHBvbmVudDsgLy8gdGhlIG51bWJlciBvZiBzaWduaWZpY2FuZCBkaWdpdHNcblxuXHQgIHZhciBzaWduaWZpY2FuZF9kaWdpdHMgPSAwOyAvLyB0aGUgYmFzZS0xMCBkaWdpdHMgaW4gdGhlIHNpZ25pZmljYW5kXG5cblx0ICB2YXIgc2lnbmlmaWNhbmQgPSBuZXcgQXJyYXkoMzYpO1xuXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWduaWZpY2FuZC5sZW5ndGg7IGkrKykge1xuXHQgICAgc2lnbmlmaWNhbmRbaV0gPSAwO1xuXHQgIH0gLy8gcmVhZCBwb2ludGVyIGludG8gc2lnbmlmaWNhbmRcblxuXG5cdCAgdmFyIGluZGV4ID0gMDsgLy8gdW5iaWFzZWQgZXhwb25lbnRcblxuXHQgIHZhciBleHBvbmVudDsgLy8gdGhlIGV4cG9uZW50IGlmIHNjaWVudGlmaWMgbm90YXRpb24gaXMgdXNlZFxuXG5cdCAgdmFyIHNjaWVudGlmaWNfZXhwb25lbnQ7IC8vIHRydWUgaWYgdGhlIG51bWJlciBpcyB6ZXJvXG5cblx0ICB2YXIgaXNfemVybyA9IGZhbHNlOyAvLyB0aGUgbW9zdCBzaWduaWZjYW50IHNpZ25pZmljYW5kIGJpdHMgKDUwLTQ2KVxuXG5cdCAgdmFyIHNpZ25pZmljYW5kX21zYjsgLy8gdGVtcG9yYXJ5IHN0b3JhZ2UgZm9yIHNpZ25pZmljYW5kIGRlY29kaW5nXG5cblx0ICB2YXIgc2lnbmlmaWNhbmQxMjggPSB7XG5cdCAgICBwYXJ0czogbmV3IEFycmF5KDQpXG5cdCAgfTsgLy8gaW5kZXhpbmcgdmFyaWFibGVzXG5cblx0ICB2YXIgaiwgazsgLy8gT3V0cHV0IHN0cmluZ1xuXG5cdCAgdmFyIHN0cmluZyA9IFtdOyAvLyBVbnBhY2sgaW5kZXhcblxuXHQgIGluZGV4ID0gMDsgLy8gQnVmZmVyIHJlZmVyZW5jZVxuXG5cdCAgdmFyIGJ1ZmZlciQkMSA9IHRoaXMuYnl0ZXM7IC8vIFVucGFjayB0aGUgbG93IDY0Yml0cyBpbnRvIGEgbG9uZ1xuXG5cdCAgbG93ID0gYnVmZmVyJCQxW2luZGV4KytdIHwgYnVmZmVyJCQxW2luZGV4KytdIDw8IDggfCBidWZmZXIkJDFbaW5kZXgrK10gPDwgMTYgfCBidWZmZXIkJDFbaW5kZXgrK10gPDwgMjQ7XG5cdCAgbWlkbCA9IGJ1ZmZlciQkMVtpbmRleCsrXSB8IGJ1ZmZlciQkMVtpbmRleCsrXSA8PCA4IHwgYnVmZmVyJCQxW2luZGV4KytdIDw8IDE2IHwgYnVmZmVyJCQxW2luZGV4KytdIDw8IDI0OyAvLyBVbnBhY2sgdGhlIGhpZ2ggNjRiaXRzIGludG8gYSBsb25nXG5cblx0ICBtaWRoID0gYnVmZmVyJCQxW2luZGV4KytdIHwgYnVmZmVyJCQxW2luZGV4KytdIDw8IDggfCBidWZmZXIkJDFbaW5kZXgrK10gPDwgMTYgfCBidWZmZXIkJDFbaW5kZXgrK10gPDwgMjQ7XG5cdCAgaGlnaCA9IGJ1ZmZlciQkMVtpbmRleCsrXSB8IGJ1ZmZlciQkMVtpbmRleCsrXSA8PCA4IHwgYnVmZmVyJCQxW2luZGV4KytdIDw8IDE2IHwgYnVmZmVyJCQxW2luZGV4KytdIDw8IDI0OyAvLyBVbnBhY2sgaW5kZXhcblxuXHQgIGluZGV4ID0gMDsgLy8gQ3JlYXRlIHRoZSBzdGF0ZSBvZiB0aGUgZGVjaW1hbFxuXG5cdCAgdmFyIGRlYyA9IHtcblx0ICAgIGxvdzogbmV3IGxvbmdfMShsb3csIG1pZGwpLFxuXHQgICAgaGlnaDogbmV3IGxvbmdfMShtaWRoLCBoaWdoKVxuXHQgIH07XG5cblx0ICBpZiAoZGVjLmhpZ2gubGVzc1RoYW4obG9uZ18xLlpFUk8pKSB7XG5cdCAgICBzdHJpbmcucHVzaCgnLScpO1xuXHQgIH0gLy8gRGVjb2RlIGNvbWJpbmF0aW9uIGZpZWxkIGFuZCBleHBvbmVudFxuXG5cblx0ICBjb21iaW5hdGlvbiA9IGhpZ2ggPj4gMjYgJiBDT01CSU5BVElPTl9NQVNLO1xuXG5cdCAgaWYgKGNvbWJpbmF0aW9uID4+IDMgPT09IDMpIHtcblx0ICAgIC8vIENoZWNrIGZvciAnc3BlY2lhbCcgdmFsdWVzXG5cdCAgICBpZiAoY29tYmluYXRpb24gPT09IENPTUJJTkFUSU9OX0lORklOSVRZKSB7XG5cdCAgICAgIHJldHVybiBzdHJpbmcuam9pbignJykgKyAnSW5maW5pdHknO1xuXHQgICAgfSBlbHNlIGlmIChjb21iaW5hdGlvbiA9PT0gQ09NQklOQVRJT05fTkFOKSB7XG5cdCAgICAgIHJldHVybiAnTmFOJztcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGJpYXNlZF9leHBvbmVudCA9IGhpZ2ggPj4gMTUgJiBFWFBPTkVOVF9NQVNLO1xuXHQgICAgICBzaWduaWZpY2FuZF9tc2IgPSAweDA4ICsgKGhpZ2ggPj4gMTQgJiAweDAxKTtcblx0ICAgIH1cblx0ICB9IGVsc2Uge1xuXHQgICAgc2lnbmlmaWNhbmRfbXNiID0gaGlnaCA+PiAxNCAmIDB4MDc7XG5cdCAgICBiaWFzZWRfZXhwb25lbnQgPSBoaWdoID4+IDE3ICYgRVhQT05FTlRfTUFTSztcblx0ICB9XG5cblx0ICBleHBvbmVudCA9IGJpYXNlZF9leHBvbmVudCAtIEVYUE9ORU5UX0JJQVM7IC8vIENyZWF0ZSBzdHJpbmcgb2Ygc2lnbmlmaWNhbmQgZGlnaXRzXG5cdCAgLy8gQ29udmVydCB0aGUgMTE0LWJpdCBiaW5hcnkgbnVtYmVyIHJlcHJlc2VudGVkIGJ5XG5cdCAgLy8gKHNpZ25pZmljYW5kX2hpZ2gsIHNpZ25pZmljYW5kX2xvdykgdG8gYXQgbW9zdCAzNCBkZWNpbWFsXG5cdCAgLy8gZGlnaXRzIHRocm91Z2ggbW9kdWxvIGFuZCBkaXZpc2lvbi5cblxuXHQgIHNpZ25pZmljYW5kMTI4LnBhcnRzWzBdID0gKGhpZ2ggJiAweDNmZmYpICsgKChzaWduaWZpY2FuZF9tc2IgJiAweGYpIDw8IDE0KTtcblx0ICBzaWduaWZpY2FuZDEyOC5wYXJ0c1sxXSA9IG1pZGg7XG5cdCAgc2lnbmlmaWNhbmQxMjgucGFydHNbMl0gPSBtaWRsO1xuXHQgIHNpZ25pZmljYW5kMTI4LnBhcnRzWzNdID0gbG93O1xuXG5cdCAgaWYgKHNpZ25pZmljYW5kMTI4LnBhcnRzWzBdID09PSAwICYmIHNpZ25pZmljYW5kMTI4LnBhcnRzWzFdID09PSAwICYmIHNpZ25pZmljYW5kMTI4LnBhcnRzWzJdID09PSAwICYmIHNpZ25pZmljYW5kMTI4LnBhcnRzWzNdID09PSAwKSB7XG5cdCAgICBpc196ZXJvID0gdHJ1ZTtcblx0ICB9IGVsc2Uge1xuXHQgICAgZm9yIChrID0gMzsgayA+PSAwOyBrLS0pIHtcblx0ICAgICAgdmFyIGxlYXN0X2RpZ2l0cyA9IDA7IC8vIFBlZm9ybSB0aGUgZGl2aWRlXG5cblx0ICAgICAgdmFyIHJlc3VsdCA9IGRpdmlkZXUxMjgoc2lnbmlmaWNhbmQxMjgpO1xuXHQgICAgICBzaWduaWZpY2FuZDEyOCA9IHJlc3VsdC5xdW90aWVudDtcblx0ICAgICAgbGVhc3RfZGlnaXRzID0gcmVzdWx0LnJlbS5sb3c7IC8vIFdlIG5vdyBoYXZlIHRoZSA5IGxlYXN0IHNpZ25pZmljYW50IGRpZ2l0cyAoaW4gYmFzZSAyKS5cblx0ICAgICAgLy8gQ29udmVydCBhbmQgb3V0cHV0IHRvIHN0cmluZy5cblxuXHQgICAgICBpZiAoIWxlYXN0X2RpZ2l0cykgY29udGludWU7XG5cblx0ICAgICAgZm9yIChqID0gODsgaiA+PSAwOyBqLS0pIHtcblx0ICAgICAgICAvLyBzaWduaWZpY2FuZFtrICogOSArIGpdID0gTWF0aC5yb3VuZChsZWFzdF9kaWdpdHMgJSAxMCk7XG5cdCAgICAgICAgc2lnbmlmaWNhbmRbayAqIDkgKyBqXSA9IGxlYXN0X2RpZ2l0cyAlIDEwOyAvLyBsZWFzdF9kaWdpdHMgPSBNYXRoLnJvdW5kKGxlYXN0X2RpZ2l0cyAvIDEwKTtcblxuXHQgICAgICAgIGxlYXN0X2RpZ2l0cyA9IE1hdGguZmxvb3IobGVhc3RfZGlnaXRzIC8gMTApO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSAvLyBPdXRwdXQgZm9ybWF0IG9wdGlvbnM6XG5cdCAgLy8gU2NpZW50aWZpYyAtIFstXWQuZGRkRSgrLy0pZGQgb3IgWy1dZEUoKy8tKWRkXG5cdCAgLy8gUmVndWxhciAgICAtIGRkZC5kZGRcblxuXG5cdCAgaWYgKGlzX3plcm8pIHtcblx0ICAgIHNpZ25pZmljYW5kX2RpZ2l0cyA9IDE7XG5cdCAgICBzaWduaWZpY2FuZFtpbmRleF0gPSAwO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBzaWduaWZpY2FuZF9kaWdpdHMgPSAzNjtcblxuXHQgICAgd2hpbGUgKCFzaWduaWZpY2FuZFtpbmRleF0pIHtcblx0ICAgICAgc2lnbmlmaWNhbmRfZGlnaXRzID0gc2lnbmlmaWNhbmRfZGlnaXRzIC0gMTtcblx0ICAgICAgaW5kZXggPSBpbmRleCArIDE7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgc2NpZW50aWZpY19leHBvbmVudCA9IHNpZ25pZmljYW5kX2RpZ2l0cyAtIDEgKyBleHBvbmVudDsgLy8gVGhlIHNjaWVudGlmaWMgZXhwb25lbnQgY2hlY2tzIGFyZSBkaWN0YXRlZCBieSB0aGUgc3RyaW5nIGNvbnZlcnNpb25cblx0ICAvLyBzcGVjaWZpY2F0aW9uIGFuZCBhcmUgc29tZXdoYXQgYXJiaXRyYXJ5IGN1dG9mZnMuXG5cdCAgLy9cblx0ICAvLyBXZSBtdXN0IGNoZWNrIGV4cG9uZW50ID4gMCwgYmVjYXVzZSBpZiB0aGlzIGlzIHRoZSBjYXNlLCB0aGUgbnVtYmVyXG5cdCAgLy8gaGFzIHRyYWlsaW5nIHplcm9zLiAgSG93ZXZlciwgd2UgKmNhbm5vdCogb3V0cHV0IHRoZXNlIHRyYWlsaW5nIHplcm9zLFxuXHQgIC8vIGJlY2F1c2UgZG9pbmcgc28gd291bGQgY2hhbmdlIHRoZSBwcmVjaXNpb24gb2YgdGhlIHZhbHVlLCBhbmQgd291bGRcblx0ICAvLyBjaGFuZ2Ugc3RvcmVkIGRhdGEgaWYgdGhlIHN0cmluZyBjb252ZXJ0ZWQgbnVtYmVyIGlzIHJvdW5kIHRyaXBwZWQuXG5cblx0ICBpZiAoc2NpZW50aWZpY19leHBvbmVudCA+PSAzNCB8fCBzY2llbnRpZmljX2V4cG9uZW50IDw9IC03IHx8IGV4cG9uZW50ID4gMCkge1xuXHQgICAgLy8gU2NpZW50aWZpYyBmb3JtYXRcblx0ICAgIC8vIGlmIHRoZXJlIGFyZSB0b28gbWFueSBzaWduaWZpY2FudCBkaWdpdHMsIHdlIHNob3VsZCBqdXN0IGJlIHRyZWF0aW5nIG51bWJlcnNcblx0ICAgIC8vIGFzICsgb3IgLSAwIGFuZCB1c2luZyB0aGUgbm9uLXNjaWVudGlmaWMgZXhwb25lbnQgKHRoaXMgaXMgZm9yIHRoZSBcImludmFsaWRcblx0ICAgIC8vIHJlcHJlc2VudGF0aW9uIHNob3VsZCBiZSB0cmVhdGVkIGFzIDAvLTBcIiBzcGVjIGNhc2VzIGluIGRlY2ltYWwxMjgtMS5qc29uKVxuXHQgICAgaWYgKHNpZ25pZmljYW5kX2RpZ2l0cyA+IDM0KSB7XG5cdCAgICAgIHN0cmluZy5wdXNoKDApO1xuXHQgICAgICBpZiAoZXhwb25lbnQgPiAwKSBzdHJpbmcucHVzaCgnRSsnICsgZXhwb25lbnQpO2Vsc2UgaWYgKGV4cG9uZW50IDwgMCkgc3RyaW5nLnB1c2goJ0UnICsgZXhwb25lbnQpO1xuXHQgICAgICByZXR1cm4gc3RyaW5nLmpvaW4oJycpO1xuXHQgICAgfVxuXG5cdCAgICBzdHJpbmcucHVzaChzaWduaWZpY2FuZFtpbmRleCsrXSk7XG5cdCAgICBzaWduaWZpY2FuZF9kaWdpdHMgPSBzaWduaWZpY2FuZF9kaWdpdHMgLSAxO1xuXG5cdCAgICBpZiAoc2lnbmlmaWNhbmRfZGlnaXRzKSB7XG5cdCAgICAgIHN0cmluZy5wdXNoKCcuJyk7XG5cdCAgICB9XG5cblx0ICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBzaWduaWZpY2FuZF9kaWdpdHM7IF9pKyspIHtcblx0ICAgICAgc3RyaW5nLnB1c2goc2lnbmlmaWNhbmRbaW5kZXgrK10pO1xuXHQgICAgfSAvLyBFeHBvbmVudFxuXG5cblx0ICAgIHN0cmluZy5wdXNoKCdFJyk7XG5cblx0ICAgIGlmIChzY2llbnRpZmljX2V4cG9uZW50ID4gMCkge1xuXHQgICAgICBzdHJpbmcucHVzaCgnKycgKyBzY2llbnRpZmljX2V4cG9uZW50KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHN0cmluZy5wdXNoKHNjaWVudGlmaWNfZXhwb25lbnQpO1xuXHQgICAgfVxuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBSZWd1bGFyIGZvcm1hdCB3aXRoIG5vIGRlY2ltYWwgcGxhY2Vcblx0ICAgIGlmIChleHBvbmVudCA+PSAwKSB7XG5cdCAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHNpZ25pZmljYW5kX2RpZ2l0czsgX2kyKyspIHtcblx0ICAgICAgICBzdHJpbmcucHVzaChzaWduaWZpY2FuZFtpbmRleCsrXSk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHZhciByYWRpeF9wb3NpdGlvbiA9IHNpZ25pZmljYW5kX2RpZ2l0cyArIGV4cG9uZW50OyAvLyBub24temVybyBkaWdpdHMgYmVmb3JlIHJhZGl4XG5cblx0ICAgICAgaWYgKHJhZGl4X3Bvc2l0aW9uID4gMCkge1xuXHQgICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IHJhZGl4X3Bvc2l0aW9uOyBfaTMrKykge1xuXHQgICAgICAgICAgc3RyaW5nLnB1c2goc2lnbmlmaWNhbmRbaW5kZXgrK10pO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBzdHJpbmcucHVzaCgnMCcpO1xuXHQgICAgICB9XG5cblx0ICAgICAgc3RyaW5nLnB1c2goJy4nKTsgLy8gYWRkIGxlYWRpbmcgemVyb3MgYWZ0ZXIgcmFkaXhcblxuXHQgICAgICB3aGlsZSAocmFkaXhfcG9zaXRpb24rKyA8IDApIHtcblx0ICAgICAgICBzdHJpbmcucHVzaCgnMCcpO1xuXHQgICAgICB9XG5cblx0ICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgc2lnbmlmaWNhbmRfZGlnaXRzIC0gTWF0aC5tYXgocmFkaXhfcG9zaXRpb24gLSAxLCAwKTsgX2k0KyspIHtcblx0ICAgICAgICBzdHJpbmcucHVzaChzaWduaWZpY2FuZFtpbmRleCsrXSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cblx0ICByZXR1cm4gc3RyaW5nLmpvaW4oJycpO1xuXHR9O1xuXG5cdERlY2ltYWwxMjgucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcblx0ICByZXR1cm4ge1xuXHQgICAgJG51bWJlckRlY2ltYWw6IHRoaXMudG9TdHJpbmcoKVxuXHQgIH07XG5cdH07XG5cdC8qKlxuXHQgKiBAaWdub3JlXG5cdCAqL1xuXG5cblx0RGVjaW1hbDEyOC5wcm90b3R5cGUudG9FeHRlbmRlZEpTT04gPSBmdW5jdGlvbiAoKSB7XG5cdCAgcmV0dXJuIHtcblx0ICAgICRudW1iZXJEZWNpbWFsOiB0aGlzLnRvU3RyaW5nKClcblx0ICB9O1xuXHR9O1xuXHQvKipcblx0ICogQGlnbm9yZVxuXHQgKi9cblxuXG5cdERlY2ltYWwxMjguZnJvbUV4dGVuZGVkSlNPTiA9IGZ1bmN0aW9uIChkb2MpIHtcblx0ICByZXR1cm4gRGVjaW1hbDEyOC5mcm9tU3RyaW5nKGRvYy4kbnVtYmVyRGVjaW1hbCk7XG5cdH07XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KERlY2ltYWwxMjgucHJvdG90eXBlLCAnX2Jzb250eXBlJywge1xuXHQgIHZhbHVlOiAnRGVjaW1hbDEyOCdcblx0fSk7XG5cdHZhciBkZWNpbWFsMTI4ID0gRGVjaW1hbDEyODtcblxuXHQvKipcblx0ICogQSBjbGFzcyByZXByZXNlbnRhdGlvbiBvZiB0aGUgQlNPTiBNaW5LZXkgdHlwZS5cblx0ICovXG5cblx0ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrJDcoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5cdGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzJDcodGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5cdGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyQ3KENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMkNyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzJDcoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cblx0dmFyIE1pbktleSA9XG5cdC8qI19fUFVSRV9fKi9cblx0ZnVuY3Rpb24gKCkge1xuXHQgIC8qKlxuXHQgICAqIENyZWF0ZSBhIE1pbktleSB0eXBlXG5cdCAgICpcblx0ICAgKiBAcmV0dXJuIHtNaW5LZXl9IEEgTWluS2V5IGluc3RhbmNlXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gTWluS2V5KCkge1xuXHQgICAgX2NsYXNzQ2FsbENoZWNrJDcodGhpcywgTWluS2V5KTtcblx0ICB9XG5cdCAgLyoqXG5cdCAgICogQGlnbm9yZVxuXHQgICAqL1xuXG5cblx0ICBfY3JlYXRlQ2xhc3MkNyhNaW5LZXksIFt7XG5cdCAgICBrZXk6IFwidG9FeHRlbmRlZEpTT05cIixcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiB0b0V4dGVuZGVkSlNPTigpIHtcblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAkbWluS2V5OiAxXG5cdCAgICAgIH07XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIEBpZ25vcmVcblx0ICAgICAqL1xuXG5cdCAgfV0sIFt7XG5cdCAgICBrZXk6IFwiZnJvbUV4dGVuZGVkSlNPTlwiLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21FeHRlbmRlZEpTT04oKSB7XG5cdCAgICAgIHJldHVybiBuZXcgTWluS2V5KCk7XG5cdCAgICB9XG5cdCAgfV0pO1xuXG5cdCAgcmV0dXJuIE1pbktleTtcblx0fSgpO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNaW5LZXkucHJvdG90eXBlLCAnX2Jzb250eXBlJywge1xuXHQgIHZhbHVlOiAnTWluS2V5J1xuXHR9KTtcblx0dmFyIG1pbl9rZXkgPSBNaW5LZXk7XG5cblx0LyoqXG5cdCAqIEEgY2xhc3MgcmVwcmVzZW50YXRpb24gb2YgdGhlIEJTT04gTWF4S2V5IHR5cGUuXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayQ4KGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuXHRmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyQ4KHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuXHRmdW5jdGlvbiBfY3JlYXRlQ2xhc3MkOChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzJDgoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyQ4KENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5cdHZhciBNYXhLZXkgPVxuXHQvKiNfX1BVUkVfXyovXG5cdGZ1bmN0aW9uICgpIHtcblx0ICAvKipcblx0ICAgKiBDcmVhdGUgYSBNYXhLZXkgdHlwZVxuXHQgICAqXG5cdCAgICogQHJldHVybiB7TWF4S2V5fSBBIE1heEtleSBpbnN0YW5jZVxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIE1heEtleSgpIHtcblx0ICAgIF9jbGFzc0NhbGxDaGVjayQ4KHRoaXMsIE1heEtleSk7XG5cdCAgfVxuXHQgIC8qKlxuXHQgICAqIEBpZ25vcmVcblx0ICAgKi9cblxuXG5cdCAgX2NyZWF0ZUNsYXNzJDgoTWF4S2V5LCBbe1xuXHQgICAga2V5OiBcInRvRXh0ZW5kZWRKU09OXCIsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gdG9FeHRlbmRlZEpTT04oKSB7XG5cdCAgICAgIHJldHVybiB7XG5cdCAgICAgICAgJG1heEtleTogMVxuXHQgICAgICB9O1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBAaWdub3JlXG5cdCAgICAgKi9cblxuXHQgIH1dLCBbe1xuXHQgICAga2V5OiBcImZyb21FeHRlbmRlZEpTT05cIixcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tRXh0ZW5kZWRKU09OKCkge1xuXHQgICAgICByZXR1cm4gbmV3IE1heEtleSgpO1xuXHQgICAgfVxuXHQgIH1dKTtcblxuXHQgIHJldHVybiBNYXhLZXk7XG5cdH0oKTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoTWF4S2V5LnByb3RvdHlwZSwgJ19ic29udHlwZScsIHtcblx0ICB2YWx1ZTogJ01heEtleSdcblx0fSk7XG5cdHZhciBtYXhfa2V5ID0gTWF4S2V5O1xuXG5cdC8qKlxuXHQgKiBBIGNsYXNzIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBCU09OIERCUmVmIHR5cGUuXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayQ5KGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuXHRmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyQ5KHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuXHRmdW5jdGlvbiBfY3JlYXRlQ2xhc3MkOShDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzJDkoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyQ5KENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5cdHZhciBEQlJlZiA9XG5cdC8qI19fUFVSRV9fKi9cblx0ZnVuY3Rpb24gKCkge1xuXHQgIC8qKlxuXHQgICAqIENyZWF0ZSBhIERCUmVmIHR5cGVcblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uIHRoZSBjb2xsZWN0aW9uIG5hbWUuXG5cdCAgICogQHBhcmFtIHtPYmplY3RJZH0gb2lkIHRoZSByZWZlcmVuY2UgT2JqZWN0SWQuXG5cdCAgICogQHBhcmFtIHtzdHJpbmd9IFtkYl0gb3B0aW9uYWwgZGIgbmFtZSwgaWYgb21pdHRlZCB0aGUgcmVmZXJlbmNlIGlzIGxvY2FsIHRvIHRoZSBjdXJyZW50IGRiLlxuXHQgICAqIEByZXR1cm4ge0RCUmVmfVxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIERCUmVmKGNvbGxlY3Rpb24sIG9pZCwgZGIsIGZpZWxkcykge1xuXHQgICAgX2NsYXNzQ2FsbENoZWNrJDkodGhpcywgREJSZWYpO1xuXG5cdCAgICAvLyBjaGVjayBpZiBuYW1lc3BhY2UgaGFzIGJlZW4gcHJvdmlkZWRcblx0ICAgIHZhciBwYXJ0cyA9IGNvbGxlY3Rpb24uc3BsaXQoJy4nKTtcblxuXHQgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikge1xuXHQgICAgICBkYiA9IHBhcnRzLnNoaWZ0KCk7XG5cdCAgICAgIGNvbGxlY3Rpb24gPSBwYXJ0cy5zaGlmdCgpO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLmNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xuXHQgICAgdGhpcy5vaWQgPSBvaWQ7XG5cdCAgICB0aGlzLmRiID0gZGI7XG5cdCAgICB0aGlzLmZpZWxkcyA9IGZpZWxkcyB8fCB7fTtcblx0ICB9XG5cdCAgLyoqXG5cdCAgICogQGlnbm9yZVxuXHQgICAqIEBhcGkgcHJpdmF0ZVxuXHQgICAqL1xuXG5cblx0ICBfY3JlYXRlQ2xhc3MkOShEQlJlZiwgW3tcblx0ICAgIGtleTogXCJ0b0pTT05cIixcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG5cdCAgICAgIHZhciBvID0gT2JqZWN0LmFzc2lnbih7XG5cdCAgICAgICAgJHJlZjogdGhpcy5jb2xsZWN0aW9uLFxuXHQgICAgICAgICRpZDogdGhpcy5vaWRcblx0ICAgICAgfSwgdGhpcy5maWVsZHMpO1xuXHQgICAgICBpZiAodGhpcy5kYiAhPSBudWxsKSBvLiRkYiA9IHRoaXMuZGI7XG5cdCAgICAgIHJldHVybiBvO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBAaWdub3JlXG5cdCAgICAgKi9cblxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJ0b0V4dGVuZGVkSlNPTlwiLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHRvRXh0ZW5kZWRKU09OKCkge1xuXHQgICAgICB2YXIgbyA9IHtcblx0ICAgICAgICAkcmVmOiB0aGlzLmNvbGxlY3Rpb24sXG5cdCAgICAgICAgJGlkOiB0aGlzLm9pZFxuXHQgICAgICB9O1xuXHQgICAgICBpZiAodGhpcy5kYikgby4kZGIgPSB0aGlzLmRiO1xuXHQgICAgICBvID0gT2JqZWN0LmFzc2lnbihvLCB0aGlzLmZpZWxkcyk7XG5cdCAgICAgIHJldHVybiBvO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBAaWdub3JlXG5cdCAgICAgKi9cblxuXHQgIH1dLCBbe1xuXHQgICAga2V5OiBcImZyb21FeHRlbmRlZEpTT05cIixcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tRXh0ZW5kZWRKU09OKGRvYykge1xuXHQgICAgICB2YXIgY29weSA9IE9iamVjdC5hc3NpZ24oe30sIGRvYyk7XG5cdCAgICAgIFsnJHJlZicsICckaWQnLCAnJGRiJ10uZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHQgICAgICAgIHJldHVybiBkZWxldGUgY29weVtrXTtcblx0ICAgICAgfSk7XG5cdCAgICAgIHJldHVybiBuZXcgREJSZWYoZG9jLiRyZWYsIGRvYy4kaWQsIGRvYy4kZGIsIGNvcHkpO1xuXHQgICAgfVxuXHQgIH1dKTtcblxuXHQgIHJldHVybiBEQlJlZjtcblx0fSgpO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEQlJlZi5wcm90b3R5cGUsICdfYnNvbnR5cGUnLCB7XG5cdCAgdmFsdWU6ICdEQlJlZidcblx0fSk7IC8vIHRoZSAxLnggcGFyc2VyIHVzZWQgYSBcIm5hbWVzcGFjZVwiIHByb3BlcnR5LCB3aGlsZSA0LnggdXNlcyBcImNvbGxlY3Rpb25cIi4gVG8gZW5zdXJlIGJhY2t3YXJkc1xuXHQvLyBjb21wYXRpYmlsaXR5LCBsZXQncyBleHBvc2UgXCJuYW1lc3BhY2VcIlxuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEQlJlZi5wcm90b3R5cGUsICduYW1lc3BhY2UnLCB7XG5cdCAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jb2xsZWN0aW9uO1xuXHQgIH0sXG5cdCAgc2V0OiBmdW5jdGlvbiBzZXQodmFsKSB7XG5cdCAgICB0aGlzLmNvbGxlY3Rpb24gPSB2YWw7XG5cdCAgfSxcblx0ICBjb25maWd1cmFibGU6IGZhbHNlXG5cdH0pO1xuXHR2YXIgZGJfcmVmID0gREJSZWY7XG5cblx0ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrJGEoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5cdGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzJGEodGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5cdGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyRhKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMkYShDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzJGEoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cblx0dmFyIEJ1ZmZlciQzID0gYnVmZmVyLkJ1ZmZlcjtcblx0LyoqXG5cdCAqIEEgY2xhc3MgcmVwcmVzZW50YXRpb24gb2YgdGhlIEJTT04gQmluYXJ5IHR5cGUuXG5cdCAqL1xuXG5cdHZhciBCaW5hcnkgPVxuXHQvKiNfX1BVUkVfXyovXG5cdGZ1bmN0aW9uICgpIHtcblx0ICAvKipcblx0ICAgKiBDcmVhdGUgYSBCaW5hcnkgdHlwZVxuXHQgICAqXG5cdCAgICogU3ViIHR5cGVzXG5cdCAgICogIC0gKipCU09OLkJTT05fQklOQVJZX1NVQlRZUEVfREVGQVVMVCoqLCBkZWZhdWx0IEJTT04gdHlwZS5cblx0ICAgKiAgLSAqKkJTT04uQlNPTl9CSU5BUllfU1VCVFlQRV9GVU5DVElPTioqLCBCU09OIGZ1bmN0aW9uIHR5cGUuXG5cdCAgICogIC0gKipCU09OLkJTT05fQklOQVJZX1NVQlRZUEVfQllURV9BUlJBWSoqLCBCU09OIGJ5dGUgYXJyYXkgdHlwZS5cblx0ICAgKiAgLSAqKkJTT04uQlNPTl9CSU5BUllfU1VCVFlQRV9VVUlEKiosIEJTT04gdXVpZCB0eXBlLlxuXHQgICAqICAtICoqQlNPTi5CU09OX0JJTkFSWV9TVUJUWVBFX01ENSoqLCBCU09OIG1kNSB0eXBlLlxuXHQgICAqICAtICoqQlNPTi5CU09OX0JJTkFSWV9TVUJUWVBFX1VTRVJfREVGSU5FRCoqLCBCU09OIHVzZXIgZGVmaW5lZCB0eXBlLlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBhIGJ1ZmZlciBvYmplY3QgY29udGFpbmluZyB0aGUgYmluYXJ5IGRhdGEuXG5cdCAgICogQHBhcmFtIHtOdW1iZXJ9IFtzdWJUeXBlXSB0aGUgb3B0aW9uIGJpbmFyeSB0eXBlLlxuXHQgICAqIEByZXR1cm4ge0JpbmFyeX1cblx0ICAgKi9cblx0ICBmdW5jdGlvbiBCaW5hcnkoYnVmZmVyJCQxLCBzdWJUeXBlKSB7XG5cdCAgICBfY2xhc3NDYWxsQ2hlY2skYSh0aGlzLCBCaW5hcnkpO1xuXG5cdCAgICBpZiAoYnVmZmVyJCQxICE9IG51bGwgJiYgISh0eXBlb2YgYnVmZmVyJCQxID09PSAnc3RyaW5nJykgJiYgIUJ1ZmZlciQzLmlzQnVmZmVyKGJ1ZmZlciQkMSkgJiYgIShidWZmZXIkJDEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSAmJiAhQXJyYXkuaXNBcnJheShidWZmZXIkJDEpKSB7XG5cdCAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29ubHkgU3RyaW5nLCBCdWZmZXIsIFVpbnQ4QXJyYXkgb3IgQXJyYXkgYWNjZXB0ZWQnKTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5zdWJfdHlwZSA9IHN1YlR5cGUgPT0gbnVsbCA/IEJTT05fQklOQVJZX1NVQlRZUEVfREVGQVVMVCA6IHN1YlR5cGU7XG5cdCAgICB0aGlzLnBvc2l0aW9uID0gMDtcblxuXHQgICAgaWYgKGJ1ZmZlciQkMSAhPSBudWxsICYmICEoYnVmZmVyJCQxIGluc3RhbmNlb2YgTnVtYmVyKSkge1xuXHQgICAgICAvLyBPbmx5IGFjY2VwdCBCdWZmZXIsIFVpbnQ4QXJyYXkgb3IgQXJyYXlzXG5cdCAgICAgIGlmICh0eXBlb2YgYnVmZmVyJCQxID09PSAnc3RyaW5nJykge1xuXHQgICAgICAgIC8vIERpZmZlcmVudCB3YXlzIG9mIHdyaXRpbmcgdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nIGZvciB0aGUgZGlmZmVyZW50IHR5cGVzXG5cdCAgICAgICAgaWYgKHR5cGVvZiBCdWZmZXIkMyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgICAgICAgIHRoaXMuYnVmZmVyID0gQnVmZmVyJDMuZnJvbShidWZmZXIkJDEpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnIHx8IEFycmF5LmlzQXJyYXkoYnVmZmVyJCQxKSkge1xuXHQgICAgICAgICAgdGhpcy5idWZmZXIgPSB3cml0ZVN0cmluZ1RvQXJyYXkoYnVmZmVyJCQxKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb25seSBTdHJpbmcsIEJ1ZmZlciwgVWludDhBcnJheSBvciBBcnJheSBhY2NlcHRlZCcpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlciQkMTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHRoaXMucG9zaXRpb24gPSBidWZmZXIkJDEubGVuZ3RoO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgaWYgKHR5cGVvZiBCdWZmZXIkMyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgICAgICB0aGlzLmJ1ZmZlciA9IEJ1ZmZlciQzLmFsbG9jKEJpbmFyeS5CVUZGRVJfU0laRSk7XG5cdCAgICAgIH0gZWxzZSBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShuZXcgQXJyYXlCdWZmZXIoQmluYXJ5LkJVRkZFUl9TSVpFKSk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgQXJyYXkoQmluYXJ5LkJVRkZFUl9TSVpFKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0ICAvKipcblx0ICAgKiBVcGRhdGVzIHRoaXMgYmluYXJ5IHdpdGggYnl0ZV92YWx1ZS5cblx0ICAgKlxuXHQgICAqIEBtZXRob2Rcblx0ICAgKiBAcGFyYW0ge3N0cmluZ30gYnl0ZV92YWx1ZSBhIHNpbmdsZSBieXRlIHdlIHdpc2ggdG8gd3JpdGUuXG5cdCAgICovXG5cblxuXHQgIF9jcmVhdGVDbGFzcyRhKEJpbmFyeSwgW3tcblx0ICAgIGtleTogXCJwdXRcIixcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiBwdXQoYnl0ZV92YWx1ZSkge1xuXHQgICAgICAvLyBJZiBpdCdzIGEgc3RyaW5nIGFuZCBhIGhhcyBtb3JlIHRoYW4gb25lIGNoYXJhY3RlciB0aHJvdyBhbiBlcnJvclxuXHQgICAgICBpZiAoYnl0ZV92YWx1ZVsnbGVuZ3RoJ10gIT0gbnVsbCAmJiB0eXBlb2YgYnl0ZV92YWx1ZSAhPT0gJ251bWJlcicgJiYgYnl0ZV92YWx1ZS5sZW5ndGggIT09IDEpIHRocm93IG5ldyBUeXBlRXJyb3IoJ29ubHkgYWNjZXB0cyBzaW5nbGUgY2hhcmFjdGVyIFN0cmluZywgVWludDhBcnJheSBvciBBcnJheScpO1xuXHQgICAgICBpZiAodHlwZW9mIGJ5dGVfdmFsdWUgIT09ICdudW1iZXInICYmIGJ5dGVfdmFsdWUgPCAwIHx8IGJ5dGVfdmFsdWUgPiAyNTUpIHRocm93IG5ldyBUeXBlRXJyb3IoJ29ubHkgYWNjZXB0cyBudW1iZXIgaW4gYSB2YWxpZCB1bnNpZ25lZCBieXRlIHJhbmdlIDAtMjU1Jyk7IC8vIERlY29kZSB0aGUgYnl0ZSB2YWx1ZSBvbmNlXG5cblx0ICAgICAgdmFyIGRlY29kZWRfYnl0ZSA9IG51bGw7XG5cblx0ICAgICAgaWYgKHR5cGVvZiBieXRlX3ZhbHVlID09PSAnc3RyaW5nJykge1xuXHQgICAgICAgIGRlY29kZWRfYnl0ZSA9IGJ5dGVfdmFsdWUuY2hhckNvZGVBdCgwKTtcblx0ICAgICAgfSBlbHNlIGlmIChieXRlX3ZhbHVlWydsZW5ndGgnXSAhPSBudWxsKSB7XG5cdCAgICAgICAgZGVjb2RlZF9ieXRlID0gYnl0ZV92YWx1ZVswXTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBkZWNvZGVkX2J5dGUgPSBieXRlX3ZhbHVlO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCA+IHRoaXMucG9zaXRpb24pIHtcblx0ICAgICAgICB0aGlzLmJ1ZmZlclt0aGlzLnBvc2l0aW9uKytdID0gZGVjb2RlZF9ieXRlO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGlmICh0eXBlb2YgQnVmZmVyJDMgIT09ICd1bmRlZmluZWQnICYmIEJ1ZmZlciQzLmlzQnVmZmVyKHRoaXMuYnVmZmVyKSkge1xuXHQgICAgICAgICAgLy8gQ3JlYXRlIGFkZGl0aW9uYWwgb3ZlcmZsb3cgYnVmZmVyXG5cdCAgICAgICAgICB2YXIgYnVmZmVyJCQxID0gQnVmZmVyJDMuYWxsb2MoQmluYXJ5LkJVRkZFUl9TSVpFICsgdGhpcy5idWZmZXIubGVuZ3RoKTsgLy8gQ29tYmluZSB0aGUgdHdvIGJ1ZmZlcnMgdG9nZXRoZXJcblxuXHQgICAgICAgICAgdGhpcy5idWZmZXIuY29weShidWZmZXIkJDEsIDAsIDAsIHRoaXMuYnVmZmVyLmxlbmd0aCk7XG5cdCAgICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlciQkMTtcblx0ICAgICAgICAgIHRoaXMuYnVmZmVyW3RoaXMucG9zaXRpb24rK10gPSBkZWNvZGVkX2J5dGU7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHZhciBfYnVmZmVyID0gbnVsbDsgLy8gQ3JlYXRlIGEgbmV3IGJ1ZmZlciAodHlwZWQgb3Igbm9ybWFsIGFycmF5KVxuXG5cdCAgICAgICAgICBpZiAoaXNVaW50OEFycmF5KHRoaXMuYnVmZmVyKSkge1xuXHQgICAgICAgICAgICBfYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkobmV3IEFycmF5QnVmZmVyKEJpbmFyeS5CVUZGRVJfU0laRSArIHRoaXMuYnVmZmVyLmxlbmd0aCkpO1xuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgX2J1ZmZlciA9IG5ldyBBcnJheShCaW5hcnkuQlVGRkVSX1NJWkUgKyB0aGlzLmJ1ZmZlci5sZW5ndGgpO1xuXHQgICAgICAgICAgfSAvLyBXZSBuZWVkIHRvIGNvcHkgYWxsIHRoZSBjb250ZW50IHRvIHRoZSBuZXcgYXJyYXlcblxuXG5cdCAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYnVmZmVyLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIF9idWZmZXJbaV0gPSB0aGlzLmJ1ZmZlcltpXTtcblx0ICAgICAgICAgIH0gLy8gUmVhc3NpZ24gdGhlIGJ1ZmZlclxuXG5cblx0ICAgICAgICAgIHRoaXMuYnVmZmVyID0gX2J1ZmZlcjsgLy8gV3JpdGUgdGhlIGJ5dGVcblxuXHQgICAgICAgICAgdGhpcy5idWZmZXJbdGhpcy5wb3NpdGlvbisrXSA9IGRlY29kZWRfYnl0ZTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogV3JpdGVzIGEgYnVmZmVyIG9yIHN0cmluZyB0byB0aGUgYmluYXJ5LlxuXHQgICAgICpcblx0ICAgICAqIEBtZXRob2Rcblx0ICAgICAqIEBwYXJhbSB7KEJ1ZmZlcnxzdHJpbmcpfSBzdHJpbmcgYSBzdHJpbmcgb3IgYnVmZmVyIHRvIGJlIHdyaXR0ZW4gdG8gdGhlIEJpbmFyeSBCU09OIG9iamVjdC5cblx0ICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgc3BlY2lmeSB0aGUgYmluYXJ5IG9mIHdoZXJlIHRvIHdyaXRlIHRoZSBjb250ZW50LlxuXHQgICAgICogQHJldHVybiB7bnVsbH1cblx0ICAgICAqL1xuXG5cdCAgfSwge1xuXHQgICAga2V5OiBcIndyaXRlXCIsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gd3JpdGUoc3RyaW5nLCBvZmZzZXQpIHtcblx0ICAgICAgb2Zmc2V0ID0gdHlwZW9mIG9mZnNldCA9PT0gJ251bWJlcicgPyBvZmZzZXQgOiB0aGlzLnBvc2l0aW9uOyAvLyBJZiB0aGUgYnVmZmVyIGlzIHRvIHNtYWxsIGxldCdzIGV4dGVuZCB0aGUgYnVmZmVyXG5cblx0ICAgICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCA8IG9mZnNldCArIHN0cmluZy5sZW5ndGgpIHtcblx0ICAgICAgICB2YXIgYnVmZmVyJCQxID0gbnVsbDsgLy8gSWYgd2UgYXJlIGluIG5vZGUuanNcblxuXHQgICAgICAgIGlmICh0eXBlb2YgQnVmZmVyJDMgIT09ICd1bmRlZmluZWQnICYmIEJ1ZmZlciQzLmlzQnVmZmVyKHRoaXMuYnVmZmVyKSkge1xuXHQgICAgICAgICAgYnVmZmVyJCQxID0gQnVmZmVyJDMuYWxsb2ModGhpcy5idWZmZXIubGVuZ3RoICsgc3RyaW5nLmxlbmd0aCk7XG5cdCAgICAgICAgICB0aGlzLmJ1ZmZlci5jb3B5KGJ1ZmZlciQkMSwgMCwgMCwgdGhpcy5idWZmZXIubGVuZ3RoKTtcblx0ICAgICAgICB9IGVsc2UgaWYgKGlzVWludDhBcnJheSh0aGlzLmJ1ZmZlcikpIHtcblx0ICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBidWZmZXJcblx0ICAgICAgICAgIGJ1ZmZlciQkMSA9IG5ldyBVaW50OEFycmF5KG5ldyBBcnJheUJ1ZmZlcih0aGlzLmJ1ZmZlci5sZW5ndGggKyBzdHJpbmcubGVuZ3RoKSk7IC8vIENvcHkgdGhlIGNvbnRlbnRcblxuXHQgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBvc2l0aW9uOyBpKyspIHtcblx0ICAgICAgICAgICAgYnVmZmVyJCQxW2ldID0gdGhpcy5idWZmZXJbaV07XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSAvLyBBc3NpZ24gdGhlIG5ldyBidWZmZXJcblxuXG5cdCAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXIkJDE7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAodHlwZW9mIEJ1ZmZlciQzICE9PSAndW5kZWZpbmVkJyAmJiBCdWZmZXIkMy5pc0J1ZmZlcihzdHJpbmcpICYmIEJ1ZmZlciQzLmlzQnVmZmVyKHRoaXMuYnVmZmVyKSkge1xuXHQgICAgICAgIHN0cmluZy5jb3B5KHRoaXMuYnVmZmVyLCBvZmZzZXQsIDAsIHN0cmluZy5sZW5ndGgpO1xuXHQgICAgICAgIHRoaXMucG9zaXRpb24gPSBvZmZzZXQgKyBzdHJpbmcubGVuZ3RoID4gdGhpcy5wb3NpdGlvbiA/IG9mZnNldCArIHN0cmluZy5sZW5ndGggOiB0aGlzLnBvc2l0aW9uOyAvLyBvZmZzZXQgPSBzdHJpbmcubGVuZ3RoXG5cdCAgICAgIH0gZWxzZSBpZiAodHlwZW9mIEJ1ZmZlciQzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygc3RyaW5nID09PSAnc3RyaW5nJyAmJiBCdWZmZXIkMy5pc0J1ZmZlcih0aGlzLmJ1ZmZlcikpIHtcblx0ICAgICAgICB0aGlzLmJ1ZmZlci53cml0ZShzdHJpbmcsIG9mZnNldCwgJ2JpbmFyeScpO1xuXHQgICAgICAgIHRoaXMucG9zaXRpb24gPSBvZmZzZXQgKyBzdHJpbmcubGVuZ3RoID4gdGhpcy5wb3NpdGlvbiA/IG9mZnNldCArIHN0cmluZy5sZW5ndGggOiB0aGlzLnBvc2l0aW9uOyAvLyBvZmZzZXQgPSBzdHJpbmcubGVuZ3RoO1xuXHQgICAgICB9IGVsc2UgaWYgKGlzVWludDhBcnJheShzdHJpbmcpIHx8IEFycmF5LmlzQXJyYXkoc3RyaW5nKSAmJiB0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuXHQgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBzdHJpbmcubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgICAgICB0aGlzLmJ1ZmZlcltvZmZzZXQrK10gPSBzdHJpbmdbX2ldO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRoaXMucG9zaXRpb24gPSBvZmZzZXQgPiB0aGlzLnBvc2l0aW9uID8gb2Zmc2V0IDogdGhpcy5wb3NpdGlvbjtcblx0ICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3RyaW5nID09PSAnc3RyaW5nJykge1xuXHQgICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHN0cmluZy5sZW5ndGg7IF9pMisrKSB7XG5cdCAgICAgICAgICB0aGlzLmJ1ZmZlcltvZmZzZXQrK10gPSBzdHJpbmcuY2hhckNvZGVBdChfaTIpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRoaXMucG9zaXRpb24gPSBvZmZzZXQgPiB0aGlzLnBvc2l0aW9uID8gb2Zmc2V0IDogdGhpcy5wb3NpdGlvbjtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBSZWFkcyAqKmxlbmd0aCoqIGJ5dGVzIHN0YXJ0aW5nIGF0ICoqcG9zaXRpb24qKi5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kXG5cdCAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb24gcmVhZCBmcm9tIHRoZSBnaXZlbiBwb3NpdGlvbiBpbiB0aGUgQmluYXJ5LlxuXHQgICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQuXG5cdCAgICAgKiBAcmV0dXJuIHtCdWZmZXJ9XG5cdCAgICAgKi9cblxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJyZWFkXCIsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gcmVhZChwb3NpdGlvbiwgbGVuZ3RoKSB7XG5cdCAgICAgIGxlbmd0aCA9IGxlbmd0aCAmJiBsZW5ndGggPiAwID8gbGVuZ3RoIDogdGhpcy5wb3NpdGlvbjsgLy8gTGV0J3MgcmV0dXJuIHRoZSBkYXRhIGJhc2VkIG9uIHRoZSB0eXBlIHdlIGhhdmVcblxuXHQgICAgICBpZiAodGhpcy5idWZmZXJbJ3NsaWNlJ10pIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIuc2xpY2UocG9zaXRpb24sIHBvc2l0aW9uICsgbGVuZ3RoKTtcblx0ICAgICAgfSAvLyBDcmVhdGUgYSBidWZmZXIgdG8ga2VlcCB0aGUgcmVzdWx0XG5cblxuXHQgICAgICB2YXIgYnVmZmVyJCQxID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gbmV3IFVpbnQ4QXJyYXkobmV3IEFycmF5QnVmZmVyKGxlbmd0aCkpIDogbmV3IEFycmF5KGxlbmd0aCk7XG5cblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHQgICAgICAgIGJ1ZmZlciQkMVtpXSA9IHRoaXMuYnVmZmVyW3Bvc2l0aW9uKytdO1xuXHQgICAgICB9IC8vIFJldHVybiB0aGUgYnVmZmVyXG5cblxuXHQgICAgICByZXR1cm4gYnVmZmVyJCQxO1xuXHQgICAgfVxuXHQgICAgLyoqXG5cdCAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGlzIGJpbmFyeSBhcyBhIHN0cmluZy5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kXG5cdCAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAgICAgKi9cblxuXHQgIH0sIHtcblx0ICAgIGtleTogXCJ2YWx1ZVwiLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKGFzUmF3KSB7XG5cdCAgICAgIGFzUmF3ID0gYXNSYXcgPT0gbnVsbCA/IGZhbHNlIDogYXNSYXc7IC8vIE9wdGltaXplIHRvIHNlcmlhbGl6ZSBmb3IgdGhlIHNpdHVhdGlvbiB3aGVyZSB0aGUgZGF0YSA9PSBzaXplIG9mIGJ1ZmZlclxuXG5cdCAgICAgIGlmIChhc1JhdyAmJiB0eXBlb2YgQnVmZmVyJDMgIT09ICd1bmRlZmluZWQnICYmIEJ1ZmZlciQzLmlzQnVmZmVyKHRoaXMuYnVmZmVyKSAmJiB0aGlzLmJ1ZmZlci5sZW5ndGggPT09IHRoaXMucG9zaXRpb24pIHJldHVybiB0aGlzLmJ1ZmZlcjsgLy8gSWYgaXQncyBhIG5vZGUuanMgYnVmZmVyIG9iamVjdFxuXG5cdCAgICAgIGlmICh0eXBlb2YgQnVmZmVyJDMgIT09ICd1bmRlZmluZWQnICYmIEJ1ZmZlciQzLmlzQnVmZmVyKHRoaXMuYnVmZmVyKSkge1xuXHQgICAgICAgIHJldHVybiBhc1JhdyA/IHRoaXMuYnVmZmVyLnNsaWNlKDAsIHRoaXMucG9zaXRpb24pIDogdGhpcy5idWZmZXIudG9TdHJpbmcoJ2JpbmFyeScsIDAsIHRoaXMucG9zaXRpb24pO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGlmIChhc1Jhdykge1xuXHQgICAgICAgICAgLy8gd2Ugc3VwcG9ydCB0aGUgc2xpY2UgY29tbWFuZCB1c2UgaXRcblx0ICAgICAgICAgIGlmICh0aGlzLmJ1ZmZlclsnc2xpY2UnXSAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5zbGljZSgwLCB0aGlzLnBvc2l0aW9uKTtcblx0ICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBidWZmZXIgdG8gY29weSBjb250ZW50IHRvXG5cdCAgICAgICAgICAgIHZhciBuZXdCdWZmZXIgPSBpc1VpbnQ4QXJyYXkodGhpcy5idWZmZXIpID8gbmV3IFVpbnQ4QXJyYXkobmV3IEFycmF5QnVmZmVyKHRoaXMucG9zaXRpb24pKSA6IG5ldyBBcnJheSh0aGlzLnBvc2l0aW9uKTsgLy8gQ29weSBjb250ZW50XG5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBvc2l0aW9uOyBpKyspIHtcblx0ICAgICAgICAgICAgICBuZXdCdWZmZXJbaV0gPSB0aGlzLmJ1ZmZlcltpXTtcblx0ICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGJ1ZmZlclxuXG5cblx0ICAgICAgICAgICAgcmV0dXJuIG5ld0J1ZmZlcjtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgcmV0dXJuIGNvbnZlcnRBcnJheXRvVXRmOEJpbmFyeVN0cmluZyh0aGlzLmJ1ZmZlciwgMCwgdGhpcy5wb3NpdGlvbik7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIExlbmd0aC5cblx0ICAgICAqXG5cdCAgICAgKiBAbWV0aG9kXG5cdCAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBsZW5ndGggb2YgdGhlIGJpbmFyeS5cblx0ICAgICAqL1xuXG5cdCAgfSwge1xuXHQgICAga2V5OiBcImxlbmd0aFwiLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGxlbmd0aCgpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb247XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIEBpZ25vcmVcblx0ICAgICAqL1xuXG5cdCAgfSwge1xuXHQgICAga2V5OiBcInRvSlNPTlwiLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyICE9IG51bGwgPyB0aGlzLmJ1ZmZlci50b1N0cmluZygnYmFzZTY0JykgOiAnJztcblx0ICAgIH1cblx0ICAgIC8qKlxuXHQgICAgICogQGlnbm9yZVxuXHQgICAgICovXG5cblx0ICB9LCB7XG5cdCAgICBrZXk6IFwidG9TdHJpbmdcIixcblx0ICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZyhmb3JtYXQpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyICE9IG51bGwgPyB0aGlzLmJ1ZmZlci5zbGljZSgwLCB0aGlzLnBvc2l0aW9uKS50b1N0cmluZyhmb3JtYXQpIDogJyc7XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIEBpZ25vcmVcblx0ICAgICAqL1xuXG5cdCAgfSwge1xuXHQgICAga2V5OiBcInRvRXh0ZW5kZWRKU09OXCIsXG5cdCAgICB2YWx1ZTogZnVuY3Rpb24gdG9FeHRlbmRlZEpTT04oKSB7XG5cdCAgICAgIHZhciBiYXNlNjRTdHJpbmcgPSBCdWZmZXIkMy5pc0J1ZmZlcih0aGlzLmJ1ZmZlcikgPyB0aGlzLmJ1ZmZlci50b1N0cmluZygnYmFzZTY0JykgOiBCdWZmZXIkMy5mcm9tKHRoaXMuYnVmZmVyKS50b1N0cmluZygnYmFzZTY0Jyk7XG5cdCAgICAgIHZhciBzdWJUeXBlID0gTnVtYmVyKHRoaXMuc3ViX3R5cGUpLnRvU3RyaW5nKDE2KTtcblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAkYmluYXJ5OiB7XG5cdCAgICAgICAgICBiYXNlNjQ6IGJhc2U2NFN0cmluZyxcblx0ICAgICAgICAgIHN1YlR5cGU6IHN1YlR5cGUubGVuZ3RoID09PSAxID8gJzAnICsgc3ViVHlwZSA6IHN1YlR5cGVcblx0ICAgICAgICB9XG5cdCAgICAgIH07XG5cdCAgICB9XG5cdCAgICAvKipcblx0ICAgICAqIEBpZ25vcmVcblx0ICAgICAqL1xuXG5cdCAgfV0sIFt7XG5cdCAgICBrZXk6IFwiZnJvbUV4dGVuZGVkSlNPTlwiLFxuXHQgICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21FeHRlbmRlZEpTT04oZG9jKSB7XG5cdCAgICAgIHZhciB0eXBlID0gZG9jLiRiaW5hcnkuc3ViVHlwZSA/IHBhcnNlSW50KGRvYy4kYmluYXJ5LnN1YlR5cGUsIDE2KSA6IDA7XG5cdCAgICAgIHZhciBkYXRhID0gQnVmZmVyJDMuZnJvbShkb2MuJGJpbmFyeS5iYXNlNjQsICdiYXNlNjQnKTtcblx0ICAgICAgcmV0dXJuIG5ldyBCaW5hcnkoZGF0YSwgdHlwZSk7XG5cdCAgICB9XG5cdCAgfV0pO1xuXG5cdCAgcmV0dXJuIEJpbmFyeTtcblx0fSgpO1xuXHQvKipcblx0ICogQmluYXJ5IGRlZmF1bHQgc3VidHlwZVxuXHQgKiBAaWdub3JlXG5cdCAqL1xuXG5cblx0dmFyIEJTT05fQklOQVJZX1NVQlRZUEVfREVGQVVMVCA9IDA7XG5cblx0ZnVuY3Rpb24gaXNVaW50OEFycmF5KG9iaikge1xuXHQgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgVWludDhBcnJheV0nO1xuXHR9XG5cdC8qKlxuXHQgKiBAaWdub3JlXG5cdCAqL1xuXG5cblx0ZnVuY3Rpb24gd3JpdGVTdHJpbmdUb0FycmF5KGRhdGEpIHtcblx0ICAvLyBDcmVhdGUgYSBidWZmZXJcblx0ICB2YXIgYnVmZmVyJCQxID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gbmV3IFVpbnQ4QXJyYXkobmV3IEFycmF5QnVmZmVyKGRhdGEubGVuZ3RoKSkgOiBuZXcgQXJyYXkoZGF0YS5sZW5ndGgpOyAvLyBXcml0ZSB0aGUgY29udGVudCB0byB0aGUgYnVmZmVyXG5cblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcblx0ICAgIGJ1ZmZlciQkMVtpXSA9IGRhdGEuY2hhckNvZGVBdChpKTtcblx0ICB9IC8vIFdyaXRlIHRoZSBzdHJpbmcgdG8gdGhlIGJ1ZmZlclxuXG5cblx0ICByZXR1cm4gYnVmZmVyJCQxO1xuXHR9XG5cdC8qKlxuXHQgKiBDb252ZXJ0IEFycmF5IG90IFVpbnQ4QXJyYXkgdG8gQmluYXJ5IFN0cmluZ1xuXHQgKlxuXHQgKiBAaWdub3JlXG5cdCAqL1xuXG5cblx0ZnVuY3Rpb24gY29udmVydEFycmF5dG9VdGY4QmluYXJ5U3RyaW5nKGJ5dGVBcnJheSwgc3RhcnRJbmRleCwgZW5kSW5kZXgpIHtcblx0ICB2YXIgcmVzdWx0ID0gJyc7XG5cblx0ICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4OyBpKyspIHtcblx0ICAgIHJlc3VsdCA9IHJlc3VsdCArIFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZUFycmF5W2ldKTtcblx0ICB9XG5cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0QmluYXJ5LkJVRkZFUl9TSVpFID0gMjU2O1xuXHQvKipcblx0ICogRGVmYXVsdCBCU09OIHR5cGVcblx0ICpcblx0ICogQGNsYXNzY29uc3RhbnQgU1VCVFlQRV9ERUZBVUxUXG5cdCAqKi9cblxuXHRCaW5hcnkuU1VCVFlQRV9ERUZBVUxUID0gMDtcblx0LyoqXG5cdCAqIEZ1bmN0aW9uIEJTT04gdHlwZVxuXHQgKlxuXHQgKiBAY2xhc3Njb25zdGFudCBTVUJUWVBFX0RFRkFVTFRcblx0ICoqL1xuXG5cdEJpbmFyeS5TVUJUWVBFX0ZVTkNUSU9OID0gMTtcblx0LyoqXG5cdCAqIEJ5dGUgQXJyYXkgQlNPTiB0eXBlXG5cdCAqXG5cdCAqIEBjbGFzc2NvbnN0YW50IFNVQlRZUEVfREVGQVVMVFxuXHQgKiovXG5cblx0QmluYXJ5LlNVQlRZUEVfQllURV9BUlJBWSA9IDI7XG5cdC8qKlxuXHQgKiBPTEQgVVVJRCBCU09OIHR5cGVcblx0ICpcblx0ICogQGNsYXNzY29uc3RhbnQgU1VCVFlQRV9ERUZBVUxUXG5cdCAqKi9cblxuXHRCaW5hcnkuU1VCVFlQRV9VVUlEX09MRCA9IDM7XG5cdC8qKlxuXHQgKiBVVUlEIEJTT04gdHlwZVxuXHQgKlxuXHQgKiBAY2xhc3Njb25zdGFudCBTVUJUWVBFX0RFRkFVTFRcblx0ICoqL1xuXG5cdEJpbmFyeS5TVUJUWVBFX1VVSUQgPSA0O1xuXHQvKipcblx0ICogTUQ1IEJTT04gdHlwZVxuXHQgKlxuXHQgKiBAY2xhc3Njb25zdGFudCBTVUJUWVBFX0RFRkFVTFRcblx0ICoqL1xuXG5cdEJpbmFyeS5TVUJUWVBFX01ENSA9IDU7XG5cdC8qKlxuXHQgKiBVc2VyIEJTT04gdHlwZVxuXHQgKlxuXHQgKiBAY2xhc3Njb25zdGFudCBTVUJUWVBFX0RFRkFVTFRcblx0ICoqL1xuXG5cdEJpbmFyeS5TVUJUWVBFX1VTRVJfREVGSU5FRCA9IDEyODtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KEJpbmFyeS5wcm90b3R5cGUsICdfYnNvbnR5cGUnLCB7XG5cdCAgdmFsdWU6ICdCaW5hcnknXG5cdH0pO1xuXHR2YXIgYmluYXJ5ID0gQmluYXJ5O1xuXG5cdHZhciBjb25zdGFudHMgPSB7XG5cdCAgLy8gQlNPTiBNQVggVkFMVUVTXG5cdCAgQlNPTl9JTlQzMl9NQVg6IDB4N2ZmZmZmZmYsXG5cdCAgQlNPTl9JTlQzMl9NSU46IC0weDgwMDAwMDAwLFxuXHQgIEJTT05fSU5UNjRfTUFYOiBNYXRoLnBvdygyLCA2MykgLSAxLFxuXHQgIEJTT05fSU5UNjRfTUlOOiAtTWF0aC5wb3coMiwgNjMpLFxuXHQgIC8vIEpTIE1BWCBQUkVDSVNFIFZBTFVFU1xuXHQgIEpTX0lOVF9NQVg6IDB4MjAwMDAwMDAwMDAwMDAsXG5cdCAgLy8gQW55IGludGVnZXIgdXAgdG8gMl41MyBjYW4gYmUgcHJlY2lzZWx5IHJlcHJlc2VudGVkIGJ5IGEgZG91YmxlLlxuXHQgIEpTX0lOVF9NSU46IC0weDIwMDAwMDAwMDAwMDAwLFxuXHQgIC8vIEFueSBpbnRlZ2VyIGRvd24gdG8gLTJeNTMgY2FuIGJlIHByZWNpc2VseSByZXByZXNlbnRlZCBieSBhIGRvdWJsZS5cblxuXHQgIC8qKlxuXHQgICAqIE51bWJlciBCU09OIFR5cGVcblx0ICAgKlxuXHQgICAqIEBjbGFzc2NvbnN0YW50IEJTT05fREFUQV9OVU1CRVJcblx0ICAgKiovXG5cdCAgQlNPTl9EQVRBX05VTUJFUjogMSxcblxuXHQgIC8qKlxuXHQgICAqIFN0cmluZyBCU09OIFR5cGVcblx0ICAgKlxuXHQgICAqIEBjbGFzc2NvbnN0YW50IEJTT05fREFUQV9TVFJJTkdcblx0ICAgKiovXG5cdCAgQlNPTl9EQVRBX1NUUklORzogMixcblxuXHQgIC8qKlxuXHQgICAqIE9iamVjdCBCU09OIFR5cGVcblx0ICAgKlxuXHQgICAqIEBjbGFzc2NvbnN0YW50IEJTT05fREFUQV9PQkpFQ1Rcblx0ICAgKiovXG5cdCAgQlNPTl9EQVRBX09CSkVDVDogMyxcblxuXHQgIC8qKlxuXHQgICAqIEFycmF5IEJTT04gVHlwZVxuXHQgICAqXG5cdCAgICogQGNsYXNzY29uc3RhbnQgQlNPTl9EQVRBX0FSUkFZXG5cdCAgICoqL1xuXHQgIEJTT05fREFUQV9BUlJBWTogNCxcblxuXHQgIC8qKlxuXHQgICAqIEJpbmFyeSBCU09OIFR5cGVcblx0ICAgKlxuXHQgICAqIEBjbGFzc2NvbnN0YW50IEJTT05fREFUQV9CSU5BUllcblx0ICAgKiovXG5cdCAgQlNPTl9EQVRBX0JJTkFSWTogNSxcblxuXHQgIC8qKlxuXHQgICAqIEJpbmFyeSBCU09OIFR5cGVcblx0ICAgKlxuXHQgICAqIEBjbGFzc2NvbnN0YW50IEJTT05fREFUQV9VTkRFRklORURcblx0ICAgKiovXG5cdCAgQlNPTl9EQVRBX1VOREVGSU5FRDogNixcblxuXHQgIC8qKlxuXHQgICAqIE9iamVjdElkIEJTT04gVHlwZVxuXHQgICAqXG5cdCAgICogQGNsYXNzY29uc3RhbnQgQlNPTl9EQVRBX09JRFxuXHQgICAqKi9cblx0ICBCU09OX0RBVEFfT0lEOiA3LFxuXG5cdCAgLyoqXG5cdCAgICogQm9vbGVhbiBCU09OIFR5cGVcblx0ICAgKlxuXHQgICAqIEBjbGFzc2NvbnN0YW50IEJTT05fREFUQV9CT09MRUFOXG5cdCAgICoqL1xuXHQgIEJTT05fREFUQV9CT09MRUFOOiA4LFxuXG5cdCAgLyoqXG5cdCAgICogRGF0ZSBCU09OIFR5cGVcblx0ICAgKlxuXHQgICAqIEBjbGFzc2NvbnN0YW50IEJTT05fREFUQV9EQVRFXG5cdCAgICoqL1xuXHQgIEJTT05fREFUQV9EQVRFOiA5LFxuXG5cdCAgLyoqXG5cdCAgICogbnVsbCBCU09OIFR5cGVcblx0ICAgKlxuXHQgICAqIEBjbGFzc2NvbnN0YW50IEJTT05fREFUQV9OVUxMXG5cdCAgICoqL1xuXHQgIEJTT05fREFUQV9OVUxMOiAxMCxcblxuXHQgIC8qKlxuXHQgICAqIFJlZ0V4cCBCU09OIFR5cGVcblx0ICAgKlxuXHQgICAqIEBjbGFzc2NvbnN0YW50IEJTT05fREFUQV9SRUdFWFBcblx0ICAgKiovXG5cdCAgQlNPTl9EQVRBX1JFR0VYUDogMTEsXG5cblx0ICAvKipcblx0ICAgKiBDb2RlIEJTT04gVHlwZVxuXHQgICAqXG5cdCAgICogQGNsYXNzY29uc3RhbnQgQlNPTl9EQVRBX0RCUE9JTlRFUlxuXHQgICAqKi9cblx0ICBCU09OX0RBVEFfREJQT0lOVEVSOiAxMixcblxuXHQgIC8qKlxuXHQgICAqIENvZGUgQlNPTiBUeXBlXG5cdCAgICpcblx0ICAgKiBAY2xhc3Njb25zdGFudCBCU09OX0RBVEFfQ09ERVxuXHQgICAqKi9cblx0ICBCU09OX0RBVEFfQ09ERTogMTMsXG5cblx0ICAvKipcblx0ICAgKiBTeW1ib2wgQlNPTiBUeXBlXG5cdCAgICpcblx0ICAgKiBAY2xhc3Njb25zdGFudCBCU09OX0RBVEFfU1lNQk9MXG5cdCAgICoqL1xuXHQgIEJTT05fREFUQV9TWU1CT0w6IDE0LFxuXG5cdCAgLyoqXG5cdCAgICogQ29kZSB3aXRoIFNjb3BlIEJTT04gVHlwZVxuXHQgICAqXG5cdCAgICogQGNsYXNzY29uc3RhbnQgQlNPTl9EQVRBX0NPREVfV19TQ09QRVxuXHQgICAqKi9cblx0ICBCU09OX0RBVEFfQ09ERV9XX1NDT1BFOiAxNSxcblxuXHQgIC8qKlxuXHQgICAqIDMyIGJpdCBJbnRlZ2VyIEJTT04gVHlwZVxuXHQgICAqXG5cdCAgICogQGNsYXNzY29uc3RhbnQgQlNPTl9EQVRBX0lOVFxuXHQgICAqKi9cblx0ICBCU09OX0RBVEFfSU5UOiAxNixcblxuXHQgIC8qKlxuXHQgICAqIFRpbWVzdGFtcCBCU09OIFR5cGVcblx0ICAgKlxuXHQgICAqIEBjbGFzc2NvbnN0YW50IEJTT05fREFUQV9USU1FU1RBTVBcblx0ICAgKiovXG5cdCAgQlNPTl9EQVRBX1RJTUVTVEFNUDogMTcsXG5cblx0ICAvKipcblx0ICAgKiBMb25nIEJTT04gVHlwZVxuXHQgICAqXG5cdCAgICogQGNsYXNzY29uc3RhbnQgQlNPTl9EQVRBX0xPTkdcblx0ICAgKiovXG5cdCAgQlNPTl9EQVRBX0xPTkc6IDE4LFxuXG5cdCAgLyoqXG5cdCAgICogTG9uZyBCU09OIFR5cGVcblx0ICAgKlxuXHQgICAqIEBjbGFzc2NvbnN0YW50IEJTT05fREFUQV9ERUNJTUFMMTI4XG5cdCAgICoqL1xuXHQgIEJTT05fREFUQV9ERUNJTUFMMTI4OiAxOSxcblxuXHQgIC8qKlxuXHQgICAqIE1pbktleSBCU09OIFR5cGVcblx0ICAgKlxuXHQgICAqIEBjbGFzc2NvbnN0YW50IEJTT05fREFUQV9NSU5fS0VZXG5cdCAgICoqL1xuXHQgIEJTT05fREFUQV9NSU5fS0VZOiAweGZmLFxuXG5cdCAgLyoqXG5cdCAgICogTWF4S2V5IEJTT04gVHlwZVxuXHQgICAqXG5cdCAgICogQGNsYXNzY29uc3RhbnQgQlNPTl9EQVRBX01BWF9LRVlcblx0ICAgKiovXG5cdCAgQlNPTl9EQVRBX01BWF9LRVk6IDB4N2YsXG5cblx0ICAvKipcblx0ICAgKiBCaW5hcnkgRGVmYXVsdCBUeXBlXG5cdCAgICpcblx0ICAgKiBAY2xhc3Njb25zdGFudCBCU09OX0JJTkFSWV9TVUJUWVBFX0RFRkFVTFRcblx0ICAgKiovXG5cdCAgQlNPTl9CSU5BUllfU1VCVFlQRV9ERUZBVUxUOiAwLFxuXG5cdCAgLyoqXG5cdCAgICogQmluYXJ5IEZ1bmN0aW9uIFR5cGVcblx0ICAgKlxuXHQgICAqIEBjbGFzc2NvbnN0YW50IEJTT05fQklOQVJZX1NVQlRZUEVfRlVOQ1RJT05cblx0ICAgKiovXG5cdCAgQlNPTl9CSU5BUllfU1VCVFlQRV9GVU5DVElPTjogMSxcblxuXHQgIC8qKlxuXHQgICAqIEJpbmFyeSBCeXRlIEFycmF5IFR5cGVcblx0ICAgKlxuXHQgICAqIEBjbGFzc2NvbnN0YW50IEJTT05fQklOQVJZX1NVQlRZUEVfQllURV9BUlJBWVxuXHQgICAqKi9cblx0ICBCU09OX0JJTkFSWV9TVUJUWVBFX0JZVEVfQVJSQVk6IDIsXG5cblx0ICAvKipcblx0ICAgKiBCaW5hcnkgVVVJRCBUeXBlXG5cdCAgICpcblx0ICAgKiBAY2xhc3Njb25zdGFudCBCU09OX0JJTkFSWV9TVUJUWVBFX1VVSURcblx0ICAgKiovXG5cdCAgQlNPTl9CSU5BUllfU1VCVFlQRV9VVUlEOiAzLFxuXG5cdCAgLyoqXG5cdCAgICogQmluYXJ5IE1ENSBUeXBlXG5cdCAgICpcblx0ICAgKiBAY2xhc3Njb25zdGFudCBCU09OX0JJTkFSWV9TVUJUWVBFX01ENVxuXHQgICAqKi9cblx0ICBCU09OX0JJTkFSWV9TVUJUWVBFX01ENTogNCxcblxuXHQgIC8qKlxuXHQgICAqIEJpbmFyeSBVc2VyIERlZmluZWQgVHlwZVxuXHQgICAqXG5cdCAgICogQGNsYXNzY29uc3RhbnQgQlNPTl9CSU5BUllfU1VCVFlQRV9VU0VSX0RFRklORURcblx0ICAgKiovXG5cdCAgQlNPTl9CSU5BUllfU1VCVFlQRV9VU0VSX0RFRklORUQ6IDEyOFxuXHR9O1xuXG5cdGZ1bmN0aW9uIF90eXBlb2YkMihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YkMiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mJDIgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZiQyKG9iaik7IH1cblx0Ly8gY29uc3QgTWFwID0gcmVxdWlyZSgnLi9tYXAnKTtcblxuXHQvKipcblx0ICogQG5hbWVzcGFjZSBFSlNPTlxuXHQgKi9cblx0Ly8gYWxsIHRoZSB0eXBlcyB3aGVyZSB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueSBzcGVjaWFsIHByb2Nlc3NpbmcgYW5kIGNhbiBqdXN0IHBhc3MgdGhlIEVKU09OXG5cdC8vc3RyYWlnaHQgdG8gdHlwZS5mcm9tRXh0ZW5kZWRKU09OXG5cblxuXHR2YXIga2V5c1RvQ29kZWNzID0ge1xuXHQgICRvaWQ6IG9iamVjdGlkLFxuXHQgICRiaW5hcnk6IGJpbmFyeSxcblx0ICAkc3ltYm9sOiBzeW1ib2wsXG5cdCAgJG51bWJlckludDogaW50XzMyLFxuXHQgICRudW1iZXJEZWNpbWFsOiBkZWNpbWFsMTI4LFxuXHQgICRudW1iZXJEb3VibGU6IGRvdWJsZV8xLFxuXHQgICRudW1iZXJMb25nOiBsb25nXzEsXG5cdCAgJG1pbktleTogbWluX2tleSxcblx0ICAkbWF4S2V5OiBtYXhfa2V5LFxuXHQgICRyZWd1bGFyRXhwcmVzc2lvbjogcmVnZXhwLFxuXHQgICR0aW1lc3RhbXA6IHRpbWVzdGFtcFxuXHR9O1xuXG5cdGZ1bmN0aW9uIGRlc2VyaWFsaXplVmFsdWUoc2VsZiwga2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuXHQgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG5cdCAgICBpZiAob3B0aW9ucy5yZWxheGVkKSB7XG5cdCAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgIH0gLy8gaWYgaXQncyBhbiBpbnRlZ2VyLCBzaG91bGQgaW50ZXJwcmV0IGFzIHNtYWxsZXN0IEJTT04gaW50ZWdlclxuXHQgICAgLy8gdGhhdCBjYW4gcmVwcmVzZW50IGl0IGV4YWN0bHkuIChpZiBvdXQgb2YgcmFuZ2UsIGludGVycHJldCBhcyBkb3VibGUuKVxuXG5cblx0ICAgIGlmIChNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUpIHtcblx0ICAgICAgaWYgKHZhbHVlID49IEJTT05fSU5UMzJfTUlOICYmIHZhbHVlIDw9IEJTT05fSU5UMzJfTUFYKSByZXR1cm4gbmV3IGludF8zMih2YWx1ZSk7XG5cdCAgICAgIGlmICh2YWx1ZSA+PSBCU09OX0lOVDY0X01JTiAmJiB2YWx1ZSA8PSBCU09OX0lOVDY0X01BWCkgcmV0dXJuIG5ldyBsb25nXzEuZnJvbU51bWJlcih2YWx1ZSk7XG5cdCAgICB9IC8vIElmIHRoZSBudW1iZXIgaXMgYSBub24taW50ZWdlciBvciBvdXQgb2YgaW50ZWdlciByYW5nZSwgc2hvdWxkIGludGVycHJldCBhcyBCU09OIERvdWJsZS5cblxuXG5cdCAgICByZXR1cm4gbmV3IGRvdWJsZV8xKHZhbHVlKTtcblx0ICB9IC8vIGZyb20gaGVyZSBvbiBvdXQgd2UncmUgbG9va2luZyBmb3IgYnNvbiB0eXBlcywgc28gYmFpbCBpZiBpdHMgbm90IGFuIG9iamVjdFxuXG5cblx0ICBpZiAodmFsdWUgPT0gbnVsbCB8fCBfdHlwZW9mJDIodmFsdWUpICE9PSAnb2JqZWN0JykgcmV0dXJuIHZhbHVlOyAvLyB1cGdyYWRlIGRlcHJlY2F0ZWQgdW5kZWZpbmVkIHRvIG51bGxcblxuXHQgIGlmICh2YWx1ZS4kdW5kZWZpbmVkKSByZXR1cm4gbnVsbDtcblx0ICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKS5maWx0ZXIoZnVuY3Rpb24gKGspIHtcblx0ICAgIHJldHVybiBrLnN0YXJ0c1dpdGgoJyQnKSAmJiB2YWx1ZVtrXSAhPSBudWxsO1xuXHQgIH0pO1xuXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICB2YXIgYyA9IGtleXNUb0NvZGVjc1trZXlzW2ldXTtcblx0ICAgIGlmIChjKSByZXR1cm4gYy5mcm9tRXh0ZW5kZWRKU09OKHZhbHVlLCBvcHRpb25zKTtcblx0ICB9XG5cblx0ICBpZiAodmFsdWUuJGRhdGUgIT0gbnVsbCkge1xuXHQgICAgdmFyIGQgPSB2YWx1ZS4kZGF0ZTtcblx0ICAgIHZhciBkYXRlID0gbmV3IERhdGUoKTtcblx0ICAgIGlmICh0eXBlb2YgZCA9PT0gJ3N0cmluZycpIGRhdGUuc2V0VGltZShEYXRlLnBhcnNlKGQpKTtlbHNlIGlmIChsb25nXzEuaXNMb25nKGQpKSBkYXRlLnNldFRpbWUoZC50b051bWJlcigpKTtlbHNlIGlmICh0eXBlb2YgZCA9PT0gJ251bWJlcicgJiYgb3B0aW9ucy5yZWxheGVkKSBkYXRlLnNldFRpbWUoZCk7XG5cdCAgICByZXR1cm4gZGF0ZTtcblx0ICB9XG5cblx0ICBpZiAodmFsdWUuJGNvZGUgIT0gbnVsbCkge1xuXHQgICAgdmFyIGNvcHkgPSBPYmplY3QuYXNzaWduKHt9LCB2YWx1ZSk7XG5cblx0ICAgIGlmICh2YWx1ZS4kc2NvcGUpIHtcblx0ICAgICAgY29weS4kc2NvcGUgPSBkZXNlcmlhbGl6ZVZhbHVlKHNlbGYsIG51bGwsIHZhbHVlLiRzY29wZSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBjb2RlLmZyb21FeHRlbmRlZEpTT04odmFsdWUpO1xuXHQgIH1cblxuXHQgIGlmICh2YWx1ZS4kcmVmICE9IG51bGwgfHwgdmFsdWUuJGRiUG9pbnRlciAhPSBudWxsKSB7XG5cdCAgICB2YXIgdiA9IHZhbHVlLiRyZWYgPyB2YWx1ZSA6IHZhbHVlLiRkYlBvaW50ZXI7IC8vIHdlIHJ1biBpbnRvIHRoaXMgaW4gYSBcImRlZ2VuZXJhdGUgRUpTT05cIiBjYXNlICh3aXRoICRpZCBhbmQgJHJlZiBvcmRlciBmbGlwcGVkKVxuXHQgICAgLy8gYmVjYXVzZSBvZiB0aGUgb3JkZXIgSlNPTi5wYXJzZSBnb2VzIHRocm91Z2ggdGhlIGRvY3VtZW50XG5cblx0ICAgIGlmICh2IGluc3RhbmNlb2YgZGJfcmVmKSByZXR1cm4gdjtcblx0ICAgIHZhciBkb2xsYXJLZXlzID0gT2JqZWN0LmtleXModikuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG5cdCAgICAgIHJldHVybiBrLnN0YXJ0c1dpdGgoJyQnKTtcblx0ICAgIH0pO1xuXHQgICAgdmFyIHZhbGlkID0gdHJ1ZTtcblx0ICAgIGRvbGxhcktleXMuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHQgICAgICBpZiAoWyckcmVmJywgJyRpZCcsICckZGInXS5pbmRleE9mKGspID09PSAtMSkgdmFsaWQgPSBmYWxzZTtcblx0ICAgIH0pOyAvLyBvbmx5IG1ha2UgREJSZWYgaWYgJCBrZXlzIGFyZSBhbGwgdmFsaWRcblxuXHQgICAgaWYgKHZhbGlkKSByZXR1cm4gZGJfcmVmLmZyb21FeHRlbmRlZEpTT04odik7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHZhbHVlO1xuXHR9XG5cdC8qKlxuXHQgKiBQYXJzZSBhbiBFeHRlbmRlZCBKU09OIHN0cmluZywgY29uc3RydWN0aW5nIHRoZSBKYXZhU2NyaXB0IHZhbHVlIG9yIG9iamVjdCBkZXNjcmliZWQgYnkgdGhhdFxuXHQgKiBzdHJpbmcuXG5cdCAqXG5cdCAqIEBtZW1iZXJvZiBFSlNPTlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuXHQgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIE9wdGlvbmFsIHNldHRpbmdzXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVsYXhlZD10cnVlXSBBdHRlbXB0IHRvIHJldHVybiBuYXRpdmUgSlMgdHlwZXMgd2hlcmUgcG9zc2libGUsIHJhdGhlciB0aGFuIEJTT04gdHlwZXMgKGlmIHRydWUpXG5cdCAqIEByZXR1cm4ge29iamVjdH1cblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICogY29uc3QgeyBFSlNPTiB9ID0gcmVxdWlyZSgnYnNvbicpO1xuXHQgKiBjb25zdCB0ZXh0ID0gJ3sgXCJpbnQzMlwiOiB7IFwiJG51bWJlckludFwiOiBcIjEwXCIgfSB9Jztcblx0ICpcblx0ICogLy8gcHJpbnRzIHsgaW50MzI6IHsgW1N0cmluZzogJzEwJ10gX2Jzb250eXBlOiAnSW50MzInLCB2YWx1ZTogJzEwJyB9IH1cblx0ICogY29uc29sZS5sb2coRUpTT04ucGFyc2UodGV4dCwgeyByZWxheGVkOiBmYWxzZSB9KSk7XG5cdCAqXG5cdCAqIC8vIHByaW50cyB7IGludDMyOiAxMCB9XG5cdCAqIGNvbnNvbGUubG9nKEVKU09OLnBhcnNlKHRleHQpKTtcblx0ICovXG5cblxuXHRmdW5jdGlvbiBwYXJzZSh0ZXh0LCBvcHRpb25zKSB7XG5cdCAgdmFyIF90aGlzID0gdGhpcztcblxuXHQgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB7XG5cdCAgICByZWxheGVkOiB0cnVlXG5cdCAgfSwgb3B0aW9ucyk7IC8vIHJlbGF4ZWQgaW1wbGllcyBub3Qgc3RyaWN0XG5cblx0ICBpZiAodHlwZW9mIG9wdGlvbnMucmVsYXhlZCA9PT0gJ2Jvb2xlYW4nKSBvcHRpb25zLnN0cmljdCA9ICFvcHRpb25zLnJlbGF4ZWQ7XG5cdCAgaWYgKHR5cGVvZiBvcHRpb25zLnN0cmljdCA9PT0gJ2Jvb2xlYW4nKSBvcHRpb25zLnJlbGF4ZWQgPSAhb3B0aW9ucy5zdHJpY3Q7XG5cdCAgcmV0dXJuIEpTT04ucGFyc2UodGV4dCwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblx0ICAgIHJldHVybiBkZXNlcmlhbGl6ZVZhbHVlKF90aGlzLCBrZXksIHZhbHVlLCBvcHRpb25zKTtcblx0ICB9KTtcblx0fSAvL1xuXHQvLyBTZXJpYWxpemVyXG5cdC8vXG5cdC8vIE1BWCBJTlQzMiBib3VuZGFyaWVzXG5cblxuXHR2YXIgQlNPTl9JTlQzMl9NQVggPSAweDdmZmZmZmZmLFxuXHQgICAgQlNPTl9JTlQzMl9NSU4gPSAtMHg4MDAwMDAwMCxcblx0ICAgIEJTT05fSU5UNjRfTUFYID0gMHg3ZmZmZmZmZmZmZmZmZmZmLFxuXHQgICAgQlNPTl9JTlQ2NF9NSU4gPSAtMHg4MDAwMDAwMDAwMDAwMDAwO1xuXHQvKipcblx0ICogQ29udmVydHMgYSBCU09OIGRvY3VtZW50IHRvIGFuIEV4dGVuZGVkIEpTT04gc3RyaW5nLCBvcHRpb25hbGx5IHJlcGxhY2luZyB2YWx1ZXMgaWYgYSByZXBsYWNlclxuXHQgKiBmdW5jdGlvbiBpcyBzcGVjaWZpZWQgb3Igb3B0aW9uYWxseSBpbmNsdWRpbmcgb25seSB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMgaWYgYSByZXBsYWNlciBhcnJheVxuXHQgKiBpcyBzcGVjaWZpZWQuXG5cdCAqXG5cdCAqIEBtZW1iZXJvZiBFSlNPTlxuXHQgKiBAcGFyYW0ge29iamVjdH0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gZXh0ZW5kZWQgSlNPTlxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufGFycmF5fSBbcmVwbGFjZXJdIEEgZnVuY3Rpb24gdGhhdCBhbHRlcnMgdGhlIGJlaGF2aW9yIG9mIHRoZSBzdHJpbmdpZmljYXRpb24gcHJvY2Vzcywgb3IgYW4gYXJyYXkgb2YgU3RyaW5nIGFuZCBOdW1iZXIgb2JqZWN0cyB0aGF0IHNlcnZlIGFzIGEgd2hpdGVsaXN0IGZvciBzZWxlY3RpbmcvZmlsdGVyaW5nIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSB2YWx1ZSBvYmplY3QgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIEpTT04gc3RyaW5nLiBJZiB0aGlzIHZhbHVlIGlzIG51bGwgb3Igbm90IHByb3ZpZGVkLCBhbGwgcHJvcGVydGllcyBvZiB0aGUgb2JqZWN0IGFyZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0aW5nIEpTT04gc3RyaW5nXG5cdCAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW3NwYWNlXSBBIFN0cmluZyBvciBOdW1iZXIgb2JqZWN0IHRoYXQncyB1c2VkIHRvIGluc2VydCB3aGl0ZSBzcGFjZSBpbnRvIHRoZSBvdXRwdXQgSlNPTiBzdHJpbmcgZm9yIHJlYWRhYmlsaXR5IHB1cnBvc2VzLlxuXHQgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIE9wdGlvbmFsIHNldHRpbmdzXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVsYXhlZD10cnVlXSBFbmFibGVkIEV4dGVuZGVkIEpTT04ncyBgcmVsYXhlZGAgbW9kZVxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKlxuXHQgKiBAZXhhbXBsZVxuXHQgKiBjb25zdCB7IEVKU09OIH0gPSByZXF1aXJlKCdic29uJyk7XG5cdCAqIGNvbnN0IEludDMyID0gcmVxdWlyZSgnbW9uZ29kYicpLkludDMyO1xuXHQgKiBjb25zdCBkb2MgPSB7IGludDMyOiBuZXcgSW50MzIoMTApIH07XG5cdCAqXG5cdCAqIC8vIHByaW50cyAne1wiaW50MzJcIjp7XCIkbnVtYmVySW50XCI6XCIxMFwifX0nXG5cdCAqIGNvbnNvbGUubG9nKEVKU09OLnN0cmluZ2lmeShkb2MsIHsgcmVsYXhlZDogZmFsc2UgfSkpO1xuXHQgKlxuXHQgKiAvLyBwcmludHMgJ3tcImludDMyXCI6MTB9J1xuXHQgKiBjb25zb2xlLmxvZyhFSlNPTi5zdHJpbmdpZnkoZG9jKSk7XG5cdCAqL1xuXG5cdGZ1bmN0aW9uIHN0cmluZ2lmeSh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlLCBvcHRpb25zKSB7XG5cdCAgaWYgKHNwYWNlICE9IG51bGwgJiYgX3R5cGVvZiQyKHNwYWNlKSA9PT0gJ29iamVjdCcpIHtcblx0ICAgIG9wdGlvbnMgPSBzcGFjZTtcblx0ICAgIHNwYWNlID0gMDtcblx0ICB9XG5cblx0ICBpZiAocmVwbGFjZXIgIT0gbnVsbCAmJiBfdHlwZW9mJDIocmVwbGFjZXIpID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShyZXBsYWNlcikpIHtcblx0ICAgIG9wdGlvbnMgPSByZXBsYWNlcjtcblx0ICAgIHJlcGxhY2VyID0gbnVsbDtcblx0ICAgIHNwYWNlID0gMDtcblx0ICB9XG5cblx0ICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwge1xuXHQgICAgcmVsYXhlZDogdHJ1ZVxuXHQgIH0sIG9wdGlvbnMpO1xuXHQgIHZhciBkb2MgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHNlcmlhbGl6ZUFycmF5KHZhbHVlLCBvcHRpb25zKSA6IHNlcmlhbGl6ZURvY3VtZW50KHZhbHVlLCBvcHRpb25zKTtcblx0ICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZG9jLCByZXBsYWNlciwgc3BhY2UpO1xuXHR9XG5cdC8qKlxuXHQgKiBTZXJpYWxpemVzIGFuIG9iamVjdCB0byBhbiBFeHRlbmRlZCBKU09OIHN0cmluZywgYW5kIHJlcGFyc2UgaXQgYXMgYSBKYXZhU2NyaXB0IG9iamVjdC5cblx0ICpcblx0ICogQG1lbWJlcm9mIEVKU09OXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBic29uIFRoZSBvYmplY3QgdG8gc2VyaWFsaXplXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gT3B0aW9uYWwgc2V0dGluZ3MgcGFzc2VkIHRvIHRoZSBgc3RyaW5naWZ5YCBmdW5jdGlvblxuXHQgKiBAcmV0dXJuIHtvYmplY3R9XG5cdCAqL1xuXG5cblx0ZnVuY3Rpb24gc2VyaWFsaXplKGJzb24sIG9wdGlvbnMpIHtcblx0ICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0ICByZXR1cm4gSlNPTi5wYXJzZShzdHJpbmdpZnkoYnNvbiwgb3B0aW9ucykpO1xuXHR9XG5cdC8qKlxuXHQgKiBEZXNlcmlhbGl6ZXMgYW4gRXh0ZW5kZWQgSlNPTiBvYmplY3QgaW50byBhIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0IHdpdGggbmF0aXZlL0JTT04gdHlwZXNcblx0ICpcblx0ICogQG1lbWJlcm9mIEVKU09OXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBlanNvbiBUaGUgRXh0ZW5kZWQgSlNPTiBvYmplY3QgdG8gZGVzZXJpYWxpemVcblx0ICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBPcHRpb25hbCBzZXR0aW5ncyBwYXNzZWQgdG8gdGhlIHBhcnNlIG1ldGhvZFxuXHQgKiBAcmV0dXJuIHtvYmplY3R9XG5cdCAqL1xuXG5cblx0ZnVuY3Rpb24gZGVzZXJpYWxpemUoZWpzb24sIG9wdGlvbnMpIHtcblx0ICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0ICByZXR1cm4gcGFyc2UoSlNPTi5zdHJpbmdpZnkoZWpzb24pLCBvcHRpb25zKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNlcmlhbGl6ZUFycmF5KGFycmF5LCBvcHRpb25zKSB7XG5cdCAgcmV0dXJuIGFycmF5Lm1hcChmdW5jdGlvbiAodikge1xuXHQgICAgcmV0dXJuIHNlcmlhbGl6ZVZhbHVlKHYsIG9wdGlvbnMpO1xuXHQgIH0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0SVNPU3RyaW5nKGRhdGUpIHtcblx0ICB2YXIgaXNvU3RyID0gZGF0ZS50b0lTT1N0cmluZygpOyAvLyB3ZSBzaG91bGQgb25seSBzaG93IG1pbGxpc2Vjb25kcyBpbiB0aW1lc3RhbXAgaWYgdGhleSdyZSBub24temVyb1xuXG5cdCAgcmV0dXJuIGRhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKCkgIT09IDAgPyBpc29TdHIgOiBpc29TdHIuc2xpY2UoMCwgLTUpICsgJ1onO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2VyaWFsaXplVmFsdWUodmFsdWUsIG9wdGlvbnMpIHtcblx0ICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHJldHVybiBzZXJpYWxpemVBcnJheSh2YWx1ZSwgb3B0aW9ucyk7XG5cdCAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBudWxsO1xuXG5cdCAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuXHQgICAgdmFyIGRhdGVOdW0gPSB2YWx1ZS5nZXRUaW1lKCksXG5cdCAgICAgICAgLy8gaXMgaXQgaW4geWVhciByYW5nZSAxOTcwLTk5OTk/XG5cdCAgICBpblJhbmdlID0gZGF0ZU51bSA+IC0xICYmIGRhdGVOdW0gPCAyNTM0MDIzMTg4MDAwMDA7XG5cdCAgICByZXR1cm4gb3B0aW9ucy5yZWxheGVkICYmIGluUmFuZ2UgPyB7XG5cdCAgICAgICRkYXRlOiBnZXRJU09TdHJpbmcodmFsdWUpXG5cdCAgICB9IDoge1xuXHQgICAgICAkZGF0ZToge1xuXHQgICAgICAgICRudW1iZXJMb25nOiB2YWx1ZS5nZXRUaW1lKCkudG9TdHJpbmcoKVxuXHQgICAgICB9XG5cdCAgICB9O1xuXHQgIH1cblxuXHQgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFvcHRpb25zLnJlbGF4ZWQpIHtcblx0ICAgIC8vIGl0J3MgYW4gaW50ZWdlclxuXHQgICAgaWYgKE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSkge1xuXHQgICAgICB2YXIgaW50MzJSYW5nZSA9IHZhbHVlID49IEJTT05fSU5UMzJfTUlOICYmIHZhbHVlIDw9IEJTT05fSU5UMzJfTUFYLFxuXHQgICAgICAgICAgaW50NjRSYW5nZSA9IHZhbHVlID49IEJTT05fSU5UNjRfTUlOICYmIHZhbHVlIDw9IEJTT05fSU5UNjRfTUFYOyAvLyBpbnRlcnByZXQgYXMgYmVpbmcgb2YgdGhlIHNtYWxsZXN0IEJTT04gaW50ZWdlciB0eXBlIHRoYXQgY2FuIHJlcHJlc2VudCB0aGUgbnVtYmVyIGV4YWN0bHlcblxuXHQgICAgICBpZiAoaW50MzJSYW5nZSkgcmV0dXJuIHtcblx0ICAgICAgICAkbnVtYmVySW50OiB2YWx1ZS50b1N0cmluZygpXG5cdCAgICAgIH07XG5cdCAgICAgIGlmIChpbnQ2NFJhbmdlKSByZXR1cm4ge1xuXHQgICAgICAgICRudW1iZXJMb25nOiB2YWx1ZS50b1N0cmluZygpXG5cdCAgICAgIH07XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB7XG5cdCAgICAgICRudW1iZXJEb3VibGU6IHZhbHVlLnRvU3RyaW5nKClcblx0ICAgIH07XG5cdCAgfVxuXG5cdCAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG5cdCAgICB2YXIgZmxhZ3MgPSB2YWx1ZS5mbGFncztcblxuXHQgICAgaWYgKGZsYWdzID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgZmxhZ3MgPSB2YWx1ZS50b1N0cmluZygpLm1hdGNoKC9bZ2ltdXldKiQvKVswXTtcblx0ICAgIH1cblxuXHQgICAgdmFyIHJ4ID0gbmV3IHJlZ2V4cCh2YWx1ZS5zb3VyY2UsIGZsYWdzKTtcblx0ICAgIHJldHVybiByeC50b0V4dGVuZGVkSlNPTigpO1xuXHQgIH1cblxuXHQgIGlmICh2YWx1ZSAhPSBudWxsICYmIF90eXBlb2YkMih2YWx1ZSkgPT09ICdvYmplY3QnKSByZXR1cm4gc2VyaWFsaXplRG9jdW1lbnQodmFsdWUsIG9wdGlvbnMpO1xuXHQgIHJldHVybiB2YWx1ZTtcblx0fVxuXG5cdHZhciBCU09OX1RZUEVfTUFQUElOR1MgPSB7XG5cdCAgQmluYXJ5OiBmdW5jdGlvbiBCaW5hcnkobykge1xuXHQgICAgcmV0dXJuIG5ldyBiaW5hcnkoby52YWx1ZSgpLCBvLnN1YnR5cGUpO1xuXHQgIH0sXG5cdCAgQ29kZTogZnVuY3Rpb24gQ29kZShvKSB7XG5cdCAgICByZXR1cm4gbmV3IGNvZGUoby5jb2RlLCBvLnNjb3BlKTtcblx0ICB9LFxuXHQgIERCUmVmOiBmdW5jdGlvbiBEQlJlZihvKSB7XG5cdCAgICByZXR1cm4gbmV3IGRiX3JlZihvLmNvbGxlY3Rpb24gfHwgby5uYW1lc3BhY2UsIG8ub2lkLCBvLmRiLCBvLmZpZWxkcyk7XG5cdCAgfSxcblx0ICAvLyBcIm5hbWVzcGFjZVwiIGZvciAxLnggbGlicmFyeSBiYWNrd2FyZHMgY29tcGF0XG5cdCAgRGVjaW1hbDEyODogZnVuY3Rpb24gRGVjaW1hbDEyOChvKSB7XG5cdCAgICByZXR1cm4gbmV3IGRlY2ltYWwxMjgoby5ieXRlcyk7XG5cdCAgfSxcblx0ICBEb3VibGU6IGZ1bmN0aW9uIERvdWJsZShvKSB7XG5cdCAgICByZXR1cm4gbmV3IGRvdWJsZV8xKG8udmFsdWUpO1xuXHQgIH0sXG5cdCAgSW50MzI6IGZ1bmN0aW9uIEludDMyKG8pIHtcblx0ICAgIHJldHVybiBuZXcgaW50XzMyKG8udmFsdWUpO1xuXHQgIH0sXG5cdCAgTG9uZzogZnVuY3Rpb24gTG9uZyhvKSB7XG5cdCAgICByZXR1cm4gbG9uZ18xLmZyb21CaXRzKCAvLyB1bmRlcnNjb3JlIHZhcmlhbnRzIGZvciAxLnggYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0ICAgIG8ubG93ICE9IG51bGwgPyBvLmxvdyA6IG8ubG93Xywgby5sb3cgIT0gbnVsbCA/IG8uaGlnaCA6IG8uaGlnaF8sIG8ubG93ICE9IG51bGwgPyBvLnVuc2lnbmVkIDogby51bnNpZ25lZF8pO1xuXHQgIH0sXG5cdCAgTWF4S2V5OiBmdW5jdGlvbiBNYXhLZXkoKSB7XG5cdCAgICByZXR1cm4gbmV3IG1heF9rZXkoKTtcblx0ICB9LFxuXHQgIE1pbktleTogZnVuY3Rpb24gTWluS2V5KCkge1xuXHQgICAgcmV0dXJuIG5ldyBtaW5fa2V5KCk7XG5cdCAgfSxcblx0ICBPYmplY3RJRDogZnVuY3Rpb24gT2JqZWN0SUQobykge1xuXHQgICAgcmV0dXJuIG5ldyBvYmplY3RpZChvKTtcblx0ICB9LFxuXHQgIE9iamVjdElkOiBmdW5jdGlvbiBPYmplY3RJZChvKSB7XG5cdCAgICByZXR1cm4gbmV3IG9iamVjdGlkKG8pO1xuXHQgIH0sXG5cdCAgLy8gc3VwcG9ydCA0LjAuMC80LjAuMSBiZWZvcmUgX2Jzb250eXBlIHdhcyByZXZlcnRlZCBiYWNrIHRvIE9iamVjdElEXG5cdCAgQlNPTlJlZ0V4cDogZnVuY3Rpb24gQlNPTlJlZ0V4cChvKSB7XG5cdCAgICByZXR1cm4gbmV3IHJlZ2V4cChvLnBhdHRlcm4sIG8ub3B0aW9ucyk7XG5cdCAgfSxcblx0ICBTeW1ib2w6IGZ1bmN0aW9uIFN5bWJvbChvKSB7XG5cdCAgICByZXR1cm4gbmV3IHN5bWJvbChvLnZhbHVlKTtcblx0ICB9LFxuXHQgIFRpbWVzdGFtcDogZnVuY3Rpb24gVGltZXN0YW1wKG8pIHtcblx0ICAgIHJldHVybiB0aW1lc3RhbXAuZnJvbUJpdHMoby5sb3csIG8uaGlnaCk7XG5cdCAgfVxuXHR9O1xuXG5cdGZ1bmN0aW9uIHNlcmlhbGl6ZURvY3VtZW50KGRvYywgb3B0aW9ucykge1xuXHQgIGlmIChkb2MgPT0gbnVsbCB8fCBfdHlwZW9mJDIoZG9jKSAhPT0gJ29iamVjdCcpIHRocm93IG5ldyBFcnJvcignbm90IGFuIG9iamVjdCBpbnN0YW5jZScpO1xuXHQgIHZhciBic29udHlwZSA9IGRvYy5fYnNvbnR5cGU7XG5cblx0ICBpZiAodHlwZW9mIGJzb250eXBlID09PSAndW5kZWZpbmVkJykge1xuXHQgICAgLy8gSXQncyBhIHJlZ3VsYXIgb2JqZWN0LiBSZWN1cnNpdmVseSBzZXJpYWxpemUgaXRzIHByb3BlcnR5IHZhbHVlcy5cblx0ICAgIHZhciBfZG9jID0ge307XG5cblx0ICAgIGZvciAodmFyIG5hbWUgaW4gZG9jKSB7XG5cdCAgICAgIF9kb2NbbmFtZV0gPSBzZXJpYWxpemVWYWx1ZShkb2NbbmFtZV0sIG9wdGlvbnMpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gX2RvYztcblx0ICB9IGVsc2UgaWYgKHR5cGVvZiBic29udHlwZSA9PT0gJ3N0cmluZycpIHtcblx0ICAgIC8vIHRoZSBcImRvY3VtZW50XCIgaXMgcmVhbGx5IGp1c3QgYSBCU09OIHR5cGUgb2JqZWN0XG5cdCAgICB2YXIgX2RvYzIgPSBkb2M7XG5cblx0ICAgIGlmICh0eXBlb2YgX2RvYzIudG9FeHRlbmRlZEpTT04gIT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgLy8gVGhlcmUncyBubyBFSlNPTiBzZXJpYWxpemF0aW9uIGZ1bmN0aW9uIG9uIHRoZSBvYmplY3QuIEl0J3MgcHJvYmFibHkgYW5cblx0ICAgICAgLy8gb2JqZWN0IGNyZWF0ZWQgYnkgYSBwcmV2aW91cyB2ZXJzaW9uIG9mIHRoaXMgbGlicmFyeSAob3IgYW5vdGhlciBsaWJyYXJ5KVxuXHQgICAgICAvLyB0aGF0J3MgZHVjay10eXBpbmcgb2JqZWN0cyB0byBsb29rIGxpa2UgdGhleSB3ZXJlIGdlbmVyYXRlZCBieSB0aGlzIGxpYnJhcnkpLlxuXHQgICAgICAvLyBDb3B5IHRoZSBvYmplY3QgaW50byB0aGlzIGxpYnJhcnkncyB2ZXJzaW9uIG9mIHRoYXQgdHlwZS5cblx0ICAgICAgdmFyIG1hcHBlciA9IEJTT05fVFlQRV9NQVBQSU5HU1tic29udHlwZV07XG5cblx0ICAgICAgaWYgKCFtYXBwZXIpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbnJlY29nbml6ZWQgb3IgaW52YWxpZCBfYnNvbnR5cGU6ICcgKyBic29udHlwZSk7XG5cdCAgICAgIH1cblxuXHQgICAgICBfZG9jMiA9IG1hcHBlcihfZG9jMik7XG5cdCAgICB9IC8vIFR3byBCU09OIHR5cGVzIG1heSBoYXZlIG5lc3RlZCBvYmplY3RzIHRoYXQgbWF5IG5lZWQgdG8gYmUgc2VyaWFsaXplZCB0b29cblxuXG5cdCAgICBpZiAoYnNvbnR5cGUgPT09ICdDb2RlJyAmJiBfZG9jMi5zY29wZSkge1xuXHQgICAgICBfZG9jMiA9IG5ldyBjb2RlKF9kb2MyLmNvZGUsIHNlcmlhbGl6ZVZhbHVlKF9kb2MyLnNjb3BlLCBvcHRpb25zKSk7XG5cdCAgICB9IGVsc2UgaWYgKGJzb250eXBlID09PSAnREJSZWYnICYmIF9kb2MyLm9pZCkge1xuXHQgICAgICBfZG9jMiA9IG5ldyBkYl9yZWYoX2RvYzIuY29sbGVjdGlvbiwgc2VyaWFsaXplVmFsdWUoX2RvYzIub2lkLCBvcHRpb25zKSwgX2RvYzIuZGIsIF9kb2MyLmZpZWxkcyk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBfZG9jMi50b0V4dGVuZGVkSlNPTihvcHRpb25zKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGhyb3cgbmV3IEVycm9yKCdfYnNvbnR5cGUgbXVzdCBiZSBhIHN0cmluZywgYnV0IHdhczogJyArIF90eXBlb2YkMihic29udHlwZSkpO1xuXHQgIH1cblx0fVxuXG5cdHZhciBleHRlbmRlZF9qc29uID0ge1xuXHQgIHBhcnNlOiBwYXJzZSxcblx0ICBkZXNlcmlhbGl6ZTogZGVzZXJpYWxpemUsXG5cdCAgc2VyaWFsaXplOiBzZXJpYWxpemUsXG5cdCAgc3RyaW5naWZ5OiBzdHJpbmdpZnlcblx0fTtcblxuXHR2YXIgRklSU1RfQklUID0gMHg4MDtcblx0dmFyIEZJUlNUX1RXT19CSVRTID0gMHhjMDtcblx0dmFyIEZJUlNUX1RIUkVFX0JJVFMgPSAweGUwO1xuXHR2YXIgRklSU1RfRk9VUl9CSVRTID0gMHhmMDtcblx0dmFyIEZJUlNUX0ZJVkVfQklUUyA9IDB4Zjg7XG5cdHZhciBUV09fQklUX0NIQVIgPSAweGMwO1xuXHR2YXIgVEhSRUVfQklUX0NIQVIgPSAweGUwO1xuXHR2YXIgRk9VUl9CSVRfQ0hBUiA9IDB4ZjA7XG5cdHZhciBDT05USU5VSU5HX0NIQVIgPSAweDgwO1xuXHQvKipcblx0ICogRGV0ZXJtaW5lcyBpZiB0aGUgcGFzc2VkIGluIGJ5dGVzIGFyZSB2YWxpZCB1dGY4XG5cdCAqIEBwYXJhbSB7QnVmZmVyfFVpbnQ4QXJyYXl9IGJ5dGVzIEFuIGFycmF5IG9mIDgtYml0IGJ5dGVzLiBNdXN0IGJlIGluZGV4YWJsZSBhbmQgaGF2ZSBsZW5ndGggcHJvcGVydHlcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IFRoZSBpbmRleCB0byBzdGFydCB2YWxpZGF0aW5nXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgVGhlIGluZGV4IHRvIGVuZCB2YWxpZGF0aW5nXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbGlkIHV0Zjhcblx0ICovXG5cblx0ZnVuY3Rpb24gdmFsaWRhdGVVdGY4KGJ5dGVzLCBzdGFydCwgZW5kKSB7XG5cdCAgdmFyIGNvbnRpbnVhdGlvbiA9IDA7XG5cblx0ICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMSkge1xuXHQgICAgdmFyIGJ5dGUgPSBieXRlc1tpXTtcblxuXHQgICAgaWYgKGNvbnRpbnVhdGlvbikge1xuXHQgICAgICBpZiAoKGJ5dGUgJiBGSVJTVF9UV09fQklUUykgIT09IENPTlRJTlVJTkdfQ0hBUikge1xuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGNvbnRpbnVhdGlvbiAtPSAxO1xuXHQgICAgfSBlbHNlIGlmIChieXRlICYgRklSU1RfQklUKSB7XG5cdCAgICAgIGlmICgoYnl0ZSAmIEZJUlNUX1RIUkVFX0JJVFMpID09PSBUV09fQklUX0NIQVIpIHtcblx0ICAgICAgICBjb250aW51YXRpb24gPSAxO1xuXHQgICAgICB9IGVsc2UgaWYgKChieXRlICYgRklSU1RfRk9VUl9CSVRTKSA9PT0gVEhSRUVfQklUX0NIQVIpIHtcblx0ICAgICAgICBjb250aW51YXRpb24gPSAyO1xuXHQgICAgICB9IGVsc2UgaWYgKChieXRlICYgRklSU1RfRklWRV9CSVRTKSA9PT0gRk9VUl9CSVRfQ0hBUikge1xuXHQgICAgICAgIGNvbnRpbnVhdGlvbiA9IDM7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgcmV0dXJuICFjb250aW51YXRpb247XG5cdH1cblxuXHR2YXIgdmFsaWRhdGVVdGY4XzEgPSB2YWxpZGF0ZVV0Zjg7XG5cdHZhciB2YWxpZGF0ZV91dGY4ID0ge1xuXHQgIHZhbGlkYXRlVXRmODogdmFsaWRhdGVVdGY4XzFcblx0fTtcblxuXHR2YXIgQnVmZmVyJDQgPSBidWZmZXIuQnVmZmVyO1xuXHR2YXIgdmFsaWRhdGVVdGY4JDEgPSB2YWxpZGF0ZV91dGY4LnZhbGlkYXRlVXRmODsgLy8gSW50ZXJuYWwgbG9uZyB2ZXJzaW9uc1xuXG5cdHZhciBKU19JTlRfTUFYX0xPTkcgPSBsb25nXzEuZnJvbU51bWJlcihjb25zdGFudHMuSlNfSU5UX01BWCk7XG5cdHZhciBKU19JTlRfTUlOX0xPTkcgPSBsb25nXzEuZnJvbU51bWJlcihjb25zdGFudHMuSlNfSU5UX01JTik7XG5cdHZhciBmdW5jdGlvbkNhY2hlID0ge307XG5cblx0ZnVuY3Rpb24gZGVzZXJpYWxpemUkMShidWZmZXIkJDEsIG9wdGlvbnMsIGlzQXJyYXkpIHtcblx0ICBvcHRpb25zID0gb3B0aW9ucyA9PSBudWxsID8ge30gOiBvcHRpb25zO1xuXHQgIHZhciBpbmRleCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5pbmRleCA/IG9wdGlvbnMuaW5kZXggOiAwOyAvLyBSZWFkIHRoZSBkb2N1bWVudCBzaXplXG5cblx0ICB2YXIgc2l6ZSA9IGJ1ZmZlciQkMVtpbmRleF0gfCBidWZmZXIkJDFbaW5kZXggKyAxXSA8PCA4IHwgYnVmZmVyJCQxW2luZGV4ICsgMl0gPDwgMTYgfCBidWZmZXIkJDFbaW5kZXggKyAzXSA8PCAyNDtcblxuXHQgIGlmIChzaXplIDwgNSkge1xuXHQgICAgdGhyb3cgbmV3IEVycm9yKFwiYnNvbiBzaXplIG11c3QgYmUgPj0gNSwgaXMgXCIuY29uY2F0KHNpemUpKTtcblx0ICB9XG5cblx0ICBpZiAob3B0aW9ucy5hbGxvd09iamVjdFNtYWxsZXJUaGFuQnVmZmVyU2l6ZSAmJiBidWZmZXIkJDEubGVuZ3RoIDwgc2l6ZSkge1xuXHQgICAgdGhyb3cgbmV3IEVycm9yKFwiYnVmZmVyIGxlbmd0aCBcIi5jb25jYXQoYnVmZmVyJCQxLmxlbmd0aCwgXCIgbXVzdCBiZSA+PSBic29uIHNpemUgXCIpLmNvbmNhdChzaXplKSk7XG5cdCAgfVxuXG5cdCAgaWYgKCFvcHRpb25zLmFsbG93T2JqZWN0U21hbGxlclRoYW5CdWZmZXJTaXplICYmIGJ1ZmZlciQkMS5sZW5ndGggIT09IHNpemUpIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcihcImJ1ZmZlciBsZW5ndGggXCIuY29uY2F0KGJ1ZmZlciQkMS5sZW5ndGgsIFwiIG11c3QgPT09IGJzb24gc2l6ZSBcIikuY29uY2F0KHNpemUpKTtcblx0ICB9XG5cblx0ICBpZiAoc2l6ZSArIGluZGV4ID4gYnVmZmVyJCQxLmxlbmd0aCkge1xuXHQgICAgdGhyb3cgbmV3IEVycm9yKFwiKGJzb24gc2l6ZSBcIi5jb25jYXQoc2l6ZSwgXCIgKyBvcHRpb25zLmluZGV4IFwiKS5jb25jYXQoaW5kZXgsIFwiIG11c3QgYmUgPD0gYnVmZmVyIGxlbmd0aCBcIikuY29uY2F0KEJ1ZmZlciQ0LmJ5dGVMZW5ndGgoYnVmZmVyJCQxKSwgXCIpXCIpKTtcblx0ICB9IC8vIElsbGVnYWwgZW5kIHZhbHVlXG5cblxuXHQgIGlmIChidWZmZXIkJDFbaW5kZXggKyBzaXplIC0gMV0gIT09IDApIHtcblx0ICAgIHRocm93IG5ldyBFcnJvcihcIk9uZSBvYmplY3QsIHNpemVkIGNvcnJlY3RseSwgd2l0aCBhIHNwb3QgZm9yIGFuIEVPTywgYnV0IHRoZSBFT08gaXNuJ3QgMHgwMFwiKTtcblx0ICB9IC8vIFN0YXJ0IGRlc2VyaWFsaXp0aW9uXG5cblxuXHQgIHJldHVybiBkZXNlcmlhbGl6ZU9iamVjdChidWZmZXIkJDEsIGluZGV4LCBvcHRpb25zLCBpc0FycmF5KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGRlc2VyaWFsaXplT2JqZWN0KGJ1ZmZlciQkMSwgaW5kZXgsIG9wdGlvbnMsIGlzQXJyYXkpIHtcblx0ICB2YXIgZXZhbEZ1bmN0aW9ucyA9IG9wdGlvbnNbJ2V2YWxGdW5jdGlvbnMnXSA9PSBudWxsID8gZmFsc2UgOiBvcHRpb25zWydldmFsRnVuY3Rpb25zJ107XG5cdCAgdmFyIGNhY2hlRnVuY3Rpb25zID0gb3B0aW9uc1snY2FjaGVGdW5jdGlvbnMnXSA9PSBudWxsID8gZmFsc2UgOiBvcHRpb25zWydjYWNoZUZ1bmN0aW9ucyddO1xuXHQgIHZhciBjYWNoZUZ1bmN0aW9uc0NyYzMyID0gb3B0aW9uc1snY2FjaGVGdW5jdGlvbnNDcmMzMiddID09IG51bGwgPyBmYWxzZSA6IG9wdGlvbnNbJ2NhY2hlRnVuY3Rpb25zQ3JjMzInXTtcblx0ICBpZiAoIWNhY2hlRnVuY3Rpb25zQ3JjMzIpIHZhciBjcmMzMiA9IG51bGw7XG5cdCAgdmFyIGZpZWxkc0FzUmF3ID0gb3B0aW9uc1snZmllbGRzQXNSYXcnXSA9PSBudWxsID8gbnVsbCA6IG9wdGlvbnNbJ2ZpZWxkc0FzUmF3J107IC8vIFJldHVybiByYXcgYnNvbiBidWZmZXIgaW5zdGVhZCBvZiBwYXJzaW5nIGl0XG5cblx0ICB2YXIgcmF3ID0gb3B0aW9uc1sncmF3J10gPT0gbnVsbCA/IGZhbHNlIDogb3B0aW9uc1sncmF3J107IC8vIFJldHVybiBCU09OUmVnRXhwIG9iamVjdHMgaW5zdGVhZCBvZiBuYXRpdmUgcmVndWxhciBleHByZXNzaW9uc1xuXG5cdCAgdmFyIGJzb25SZWdFeHAgPSB0eXBlb2Ygb3B0aW9uc1snYnNvblJlZ0V4cCddID09PSAnYm9vbGVhbicgPyBvcHRpb25zWydic29uUmVnRXhwJ10gOiBmYWxzZTsgLy8gQ29udHJvbHMgdGhlIHByb21vdGlvbiBvZiB2YWx1ZXMgdnMgd3JhcHBlciBjbGFzc2VzXG5cblx0ICB2YXIgcHJvbW90ZUJ1ZmZlcnMgPSBvcHRpb25zWydwcm9tb3RlQnVmZmVycyddID09IG51bGwgPyBmYWxzZSA6IG9wdGlvbnNbJ3Byb21vdGVCdWZmZXJzJ107XG5cdCAgdmFyIHByb21vdGVMb25ncyA9IG9wdGlvbnNbJ3Byb21vdGVMb25ncyddID09IG51bGwgPyB0cnVlIDogb3B0aW9uc1sncHJvbW90ZUxvbmdzJ107XG5cdCAgdmFyIHByb21vdGVWYWx1ZXMgPSBvcHRpb25zWydwcm9tb3RlVmFsdWVzJ10gPT0gbnVsbCA/IHRydWUgOiBvcHRpb25zWydwcm9tb3RlVmFsdWVzJ107IC8vIFNldCB0aGUgc3RhcnQgaW5kZXhcblxuXHQgIHZhciBzdGFydEluZGV4ID0gaW5kZXg7IC8vIFZhbGlkYXRlIHRoYXQgd2UgaGF2ZSBhdCBsZWFzdCA0IGJ5dGVzIG9mIGJ1ZmZlclxuXG5cdCAgaWYgKGJ1ZmZlciQkMS5sZW5ndGggPCA1KSB0aHJvdyBuZXcgRXJyb3IoJ2NvcnJ1cHQgYnNvbiBtZXNzYWdlIDwgNSBieXRlcyBsb25nJyk7IC8vIFJlYWQgdGhlIGRvY3VtZW50IHNpemVcblxuXHQgIHZhciBzaXplID0gYnVmZmVyJCQxW2luZGV4KytdIHwgYnVmZmVyJCQxW2luZGV4KytdIDw8IDggfCBidWZmZXIkJDFbaW5kZXgrK10gPDwgMTYgfCBidWZmZXIkJDFbaW5kZXgrK10gPDwgMjQ7IC8vIEVuc3VyZSBidWZmZXIgaXMgdmFsaWQgc2l6ZVxuXG5cdCAgaWYgKHNpemUgPCA1IHx8IHNpemUgPiBidWZmZXIkJDEubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ2NvcnJ1cHQgYnNvbiBtZXNzYWdlJyk7IC8vIENyZWF0ZSBob2xkaW5nIG9iamVjdFxuXG5cdCAgdmFyIG9iamVjdCA9IGlzQXJyYXkgPyBbXSA6IHt9OyAvLyBVc2VkIGZvciBhcnJheXMgdG8gc2tpcCBoYXZpbmcgdG8gcGVyZm9ybSB1dGY4IGRlY29kaW5nXG5cblx0ICB2YXIgYXJyYXlJbmRleCA9IDA7XG5cdCAgdmFyIGRvbmUgPSBmYWxzZTsgLy8gV2hpbGUgd2UgaGF2ZSBtb3JlIGxlZnQgZGF0YSBsZWZ0IGtlZXAgcGFyc2luZ1xuXG5cdCAgd2hpbGUgKCFkb25lKSB7XG5cdCAgICAvLyBSZWFkIHRoZSB0eXBlXG5cdCAgICB2YXIgZWxlbWVudFR5cGUgPSBidWZmZXIkJDFbaW5kZXgrK107IC8vIElmIHdlIGdldCBhIHplcm8gaXQncyB0aGUgbGFzdCBieXRlLCBleGl0XG5cblx0ICAgIGlmIChlbGVtZW50VHlwZSA9PT0gMCkgYnJlYWs7IC8vIEdldCB0aGUgc3RhcnQgc2VhcmNoIGluZGV4XG5cblx0ICAgIHZhciBpID0gaW5kZXg7IC8vIExvY2F0ZSB0aGUgZW5kIG9mIHRoZSBjIHN0cmluZ1xuXG5cdCAgICB3aGlsZSAoYnVmZmVyJCQxW2ldICE9PSAweDAwICYmIGkgPCBidWZmZXIkJDEubGVuZ3RoKSB7XG5cdCAgICAgIGkrKztcblx0ICAgIH0gLy8gSWYgYXJlIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciB0aGVyZSBpcyBhIHByb2JsZW0gd2l0aCB0aGUgZG9jdW1lbnRcblxuXG5cdCAgICBpZiAoaSA+PSBCdWZmZXIkNC5ieXRlTGVuZ3RoKGJ1ZmZlciQkMSkpIHRocm93IG5ldyBFcnJvcignQmFkIEJTT04gRG9jdW1lbnQ6IGlsbGVnYWwgQ1N0cmluZycpO1xuXHQgICAgdmFyIG5hbWUgPSBpc0FycmF5ID8gYXJyYXlJbmRleCsrIDogYnVmZmVyJCQxLnRvU3RyaW5nKCd1dGY4JywgaW5kZXgsIGkpO1xuXHQgICAgaW5kZXggPSBpICsgMTtcblxuXHQgICAgaWYgKGVsZW1lbnRUeXBlID09PSBjb25zdGFudHMuQlNPTl9EQVRBX1NUUklORykge1xuXHQgICAgICB2YXIgc3RyaW5nU2l6ZSA9IGJ1ZmZlciQkMVtpbmRleCsrXSB8IGJ1ZmZlciQkMVtpbmRleCsrXSA8PCA4IHwgYnVmZmVyJCQxW2luZGV4KytdIDw8IDE2IHwgYnVmZmVyJCQxW2luZGV4KytdIDw8IDI0O1xuXHQgICAgICBpZiAoc3RyaW5nU2l6ZSA8PSAwIHx8IHN0cmluZ1NpemUgPiBidWZmZXIkJDEubGVuZ3RoIC0gaW5kZXggfHwgYnVmZmVyJCQxW2luZGV4ICsgc3RyaW5nU2l6ZSAtIDFdICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBzdHJpbmcgbGVuZ3RoIGluIGJzb24nKTtcblxuXHQgICAgICBpZiAoIXZhbGlkYXRlVXRmOCQxKGJ1ZmZlciQkMSwgaW5kZXgsIGluZGV4ICsgc3RyaW5nU2l6ZSAtIDEpKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFVURi04IHN0cmluZyBpbiBCU09OIGRvY3VtZW50Jyk7XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgcyA9IGJ1ZmZlciQkMS50b1N0cmluZygndXRmOCcsIGluZGV4LCBpbmRleCArIHN0cmluZ1NpemUgLSAxKTtcblx0ICAgICAgb2JqZWN0W25hbWVdID0gcztcblx0ICAgICAgaW5kZXggPSBpbmRleCArIHN0cmluZ1NpemU7XG5cdCAgICB9IGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBjb25zdGFudHMuQlNPTl9EQVRBX09JRCkge1xuXHQgICAgICB2YXIgb2lkID0gQnVmZmVyJDQuYWxsb2MoMTIpO1xuXHQgICAgICBidWZmZXIkJDEuY29weShvaWQsIDAsIGluZGV4LCBpbmRleCArIDEyKTtcblx0ICAgICAgb2JqZWN0W25hbWVdID0gbmV3IG9iamVjdGlkKG9pZCk7XG5cdCAgICAgIGluZGV4ID0gaW5kZXggKyAxMjtcblx0ICAgIH0gZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IGNvbnN0YW50cy5CU09OX0RBVEFfSU5UICYmIHByb21vdGVWYWx1ZXMgPT09IGZhbHNlKSB7XG5cdCAgICAgIG9iamVjdFtuYW1lXSA9IG5ldyBpbnRfMzIoYnVmZmVyJCQxW2luZGV4KytdIHwgYnVmZmVyJCQxW2luZGV4KytdIDw8IDggfCBidWZmZXIkJDFbaW5kZXgrK10gPDwgMTYgfCBidWZmZXIkJDFbaW5kZXgrK10gPDwgMjQpO1xuXHQgICAgfSBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gY29uc3RhbnRzLkJTT05fREFUQV9JTlQpIHtcblx0ICAgICAgb2JqZWN0W25hbWVdID0gYnVmZmVyJCQxW2luZGV4KytdIHwgYnVmZmVyJCQxW2luZGV4KytdIDw8IDggfCBidWZmZXIkJDFbaW5kZXgrK10gPDwgMTYgfCBidWZmZXIkJDFbaW5kZXgrK10gPDwgMjQ7XG5cdCAgICB9IGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBjb25zdGFudHMuQlNPTl9EQVRBX05VTUJFUiAmJiBwcm9tb3RlVmFsdWVzID09PSBmYWxzZSkge1xuXHQgICAgICBvYmplY3RbbmFtZV0gPSBuZXcgZG91YmxlXzEoYnVmZmVyJCQxLnJlYWREb3VibGVMRShpbmRleCkpO1xuXHQgICAgICBpbmRleCA9IGluZGV4ICsgODtcblx0ICAgIH0gZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IGNvbnN0YW50cy5CU09OX0RBVEFfTlVNQkVSKSB7XG5cdCAgICAgIG9iamVjdFtuYW1lXSA9IGJ1ZmZlciQkMS5yZWFkRG91YmxlTEUoaW5kZXgpO1xuXHQgICAgICBpbmRleCA9IGluZGV4ICsgODtcblx0ICAgIH0gZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IGNvbnN0YW50cy5CU09OX0RBVEFfREFURSkge1xuXHQgICAgICB2YXIgbG93Qml0cyA9IGJ1ZmZlciQkMVtpbmRleCsrXSB8IGJ1ZmZlciQkMVtpbmRleCsrXSA8PCA4IHwgYnVmZmVyJCQxW2luZGV4KytdIDw8IDE2IHwgYnVmZmVyJCQxW2luZGV4KytdIDw8IDI0O1xuXHQgICAgICB2YXIgaGlnaEJpdHMgPSBidWZmZXIkJDFbaW5kZXgrK10gfCBidWZmZXIkJDFbaW5kZXgrK10gPDwgOCB8IGJ1ZmZlciQkMVtpbmRleCsrXSA8PCAxNiB8IGJ1ZmZlciQkMVtpbmRleCsrXSA8PCAyNDtcblx0ICAgICAgb2JqZWN0W25hbWVdID0gbmV3IERhdGUobmV3IGxvbmdfMShsb3dCaXRzLCBoaWdoQml0cykudG9OdW1iZXIoKSk7XG5cdCAgICB9IGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBjb25zdGFudHMuQlNPTl9EQVRBX0JPT0xFQU4pIHtcblx0ICAgICAgaWYgKGJ1ZmZlciQkMVtpbmRleF0gIT09IDAgJiYgYnVmZmVyJCQxW2luZGV4XSAhPT0gMSkgdGhyb3cgbmV3IEVycm9yKCdpbGxlZ2FsIGJvb2xlYW4gdHlwZSB2YWx1ZScpO1xuXHQgICAgICBvYmplY3RbbmFtZV0gPSBidWZmZXIkJDFbaW5kZXgrK10gPT09IDE7XG5cdCAgICB9IGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBjb25zdGFudHMuQlNPTl9EQVRBX09CSkVDVCkge1xuXHQgICAgICB2YXIgX2luZGV4ID0gaW5kZXg7XG5cdCAgICAgIHZhciBvYmplY3RTaXplID0gYnVmZmVyJCQxW2luZGV4XSB8IGJ1ZmZlciQkMVtpbmRleCArIDFdIDw8IDggfCBidWZmZXIkJDFbaW5kZXggKyAyXSA8PCAxNiB8IGJ1ZmZlciQkMVtpbmRleCArIDNdIDw8IDI0O1xuXHQgICAgICBpZiAob2JqZWN0U2l6ZSA8PSAwIHx8IG9iamVjdFNpemUgPiBidWZmZXIkJDEubGVuZ3RoIC0gaW5kZXgpIHRocm93IG5ldyBFcnJvcignYmFkIGVtYmVkZGVkIGRvY3VtZW50IGxlbmd0aCBpbiBic29uJyk7IC8vIFdlIGhhdmUgYSByYXcgdmFsdWVcblxuXHQgICAgICBpZiAocmF3KSB7XG5cdCAgICAgICAgb2JqZWN0W25hbWVdID0gYnVmZmVyJCQxLnNsaWNlKGluZGV4LCBpbmRleCArIG9iamVjdFNpemUpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIG9iamVjdFtuYW1lXSA9IGRlc2VyaWFsaXplT2JqZWN0KGJ1ZmZlciQkMSwgX2luZGV4LCBvcHRpb25zLCBmYWxzZSk7XG5cdCAgICAgIH1cblxuXHQgICAgICBpbmRleCA9IGluZGV4ICsgb2JqZWN0U2l6ZTtcblx0ICAgIH0gZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IGNvbnN0YW50cy5CU09OX0RBVEFfQVJSQVkpIHtcblx0ICAgICAgdmFyIF9pbmRleDIgPSBpbmRleDtcblxuXHQgICAgICB2YXIgX29iamVjdFNpemUgPSBidWZmZXIkJDFbaW5kZXhdIHwgYnVmZmVyJCQxW2luZGV4ICsgMV0gPDwgOCB8IGJ1ZmZlciQkMVtpbmRleCArIDJdIDw8IDE2IHwgYnVmZmVyJCQxW2luZGV4ICsgM10gPDwgMjQ7XG5cblx0ICAgICAgdmFyIGFycmF5T3B0aW9ucyA9IG9wdGlvbnM7IC8vIFN0b3AgaW5kZXhcblxuXHQgICAgICB2YXIgc3RvcEluZGV4ID0gaW5kZXggKyBfb2JqZWN0U2l6ZTsgLy8gQWxsIGVsZW1lbnRzIG9mIGFycmF5IHRvIGJlIHJldHVybmVkIGFzIHJhdyBic29uXG5cblx0ICAgICAgaWYgKGZpZWxkc0FzUmF3ICYmIGZpZWxkc0FzUmF3W25hbWVdKSB7XG5cdCAgICAgICAgYXJyYXlPcHRpb25zID0ge307XG5cblx0ICAgICAgICBmb3IgKHZhciBuIGluIG9wdGlvbnMpIHtcblx0ICAgICAgICAgIGFycmF5T3B0aW9uc1tuXSA9IG9wdGlvbnNbbl07XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgYXJyYXlPcHRpb25zWydyYXcnXSA9IHRydWU7XG5cdCAgICAgIH1cblxuXHQgICAgICBvYmplY3RbbmFtZV0gPSBkZXNlcmlhbGl6ZU9iamVjdChidWZmZXIkJDEsIF9pbmRleDIsIGFycmF5T3B0aW9ucywgdHJ1ZSk7XG5cdCAgICAgIGluZGV4ID0gaW5kZXggKyBfb2JqZWN0U2l6ZTtcblx0ICAgICAgaWYgKGJ1ZmZlciQkMVtpbmRleCAtIDFdICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJyYXkgdGVybWluYXRvciBieXRlJyk7XG5cdCAgICAgIGlmIChpbmRleCAhPT0gc3RvcEluZGV4KSB0aHJvdyBuZXcgRXJyb3IoJ2NvcnJ1cHRlZCBhcnJheSBic29uJyk7XG5cdCAgICB9IGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBjb25zdGFudHMuQlNPTl9EQVRBX1VOREVGSU5FRCkge1xuXHQgICAgICBvYmplY3RbbmFtZV0gPSB1bmRlZmluZWQ7XG5cdCAgICB9IGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBjb25zdGFudHMuQlNPTl9EQVRBX05VTEwpIHtcblx0ICAgICAgb2JqZWN0W25hbWVdID0gbnVsbDtcblx0ICAgIH0gZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IGNvbnN0YW50cy5CU09OX0RBVEFfTE9ORykge1xuXHQgICAgICAvLyBVbnBhY2sgdGhlIGxvdyBhbmQgaGlnaCBiaXRzXG5cdCAgICAgIHZhciBfbG93Qml0cyA9IGJ1ZmZlciQkMVtpbmRleCsrXSB8IGJ1ZmZlciQkMVtpbmRleCsrXSA8PCA4IHwgYnVmZmVyJCQxW2luZGV4KytdIDw8IDE2IHwgYnVmZmVyJCQxW2luZGV4KytdIDw8IDI0O1xuXG5cdCAgICAgIHZhciBfaGlnaEJpdHMgPSBidWZmZXIkJDFbaW5kZXgrK10gfCBidWZmZXIkJDFbaW5kZXgrK10gPDwgOCB8IGJ1ZmZlciQkMVtpbmRleCsrXSA8PCAxNiB8IGJ1ZmZlciQkMVtpbmRleCsrXSA8PCAyNDtcblxuXHQgICAgICB2YXIgbG9uZyQkMSA9IG5ldyBsb25nXzEoX2xvd0JpdHMsIF9oaWdoQml0cyk7IC8vIFByb21vdGUgdGhlIGxvbmcgaWYgcG9zc2libGVcblxuXHQgICAgICBpZiAocHJvbW90ZUxvbmdzICYmIHByb21vdGVWYWx1ZXMgPT09IHRydWUpIHtcblx0ICAgICAgICBvYmplY3RbbmFtZV0gPSBsb25nJCQxLmxlc3NUaGFuT3JFcXVhbChKU19JTlRfTUFYX0xPTkcpICYmIGxvbmckJDEuZ3JlYXRlclRoYW5PckVxdWFsKEpTX0lOVF9NSU5fTE9ORykgPyBsb25nJCQxLnRvTnVtYmVyKCkgOiBsb25nJCQxO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIG9iamVjdFtuYW1lXSA9IGxvbmckJDE7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IGNvbnN0YW50cy5CU09OX0RBVEFfREVDSU1BTDEyOCkge1xuXHQgICAgICAvLyBCdWZmZXIgdG8gY29udGFpbiB0aGUgZGVjaW1hbCBieXRlc1xuXHQgICAgICB2YXIgYnl0ZXMgPSBCdWZmZXIkNC5hbGxvYygxNik7IC8vIENvcHkgdGhlIG5leHQgMTYgYnl0ZXMgaW50byB0aGUgYnl0ZXMgYnVmZmVyXG5cblx0ICAgICAgYnVmZmVyJCQxLmNvcHkoYnl0ZXMsIDAsIGluZGV4LCBpbmRleCArIDE2KTsgLy8gVXBkYXRlIGluZGV4XG5cblx0ICAgICAgaW5kZXggPSBpbmRleCArIDE2OyAvLyBBc3NpZ24gdGhlIG5ldyBEZWNpbWFsMTI4IHZhbHVlXG5cblx0ICAgICAgdmFyIGRlY2ltYWwxMjgkJDEgPSBuZXcgZGVjaW1hbDEyOChieXRlcyk7IC8vIElmIHdlIGhhdmUgYW4gYWx0ZXJuYXRpdmUgbWFwcGVyIHVzZSB0aGF0XG5cblx0ICAgICAgb2JqZWN0W25hbWVdID0gZGVjaW1hbDEyOCQkMS50b09iamVjdCA/IGRlY2ltYWwxMjgkJDEudG9PYmplY3QoKSA6IGRlY2ltYWwxMjgkJDE7XG5cdCAgICB9IGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBjb25zdGFudHMuQlNPTl9EQVRBX0JJTkFSWSkge1xuXHQgICAgICB2YXIgYmluYXJ5U2l6ZSA9IGJ1ZmZlciQkMVtpbmRleCsrXSB8IGJ1ZmZlciQkMVtpbmRleCsrXSA8PCA4IHwgYnVmZmVyJCQxW2luZGV4KytdIDw8IDE2IHwgYnVmZmVyJCQxW2luZGV4KytdIDw8IDI0O1xuXHQgICAgICB2YXIgdG90YWxCaW5hcnlTaXplID0gYmluYXJ5U2l6ZTtcblx0ICAgICAgdmFyIHN1YlR5cGUgPSBidWZmZXIkJDFbaW5kZXgrK107IC8vIERpZCB3ZSBoYXZlIGEgbmVnYXRpdmUgYmluYXJ5IHNpemUsIHRocm93XG5cblx0ICAgICAgaWYgKGJpbmFyeVNpemUgPCAwKSB0aHJvdyBuZXcgRXJyb3IoJ05lZ2F0aXZlIGJpbmFyeSB0eXBlIGVsZW1lbnQgc2l6ZSBmb3VuZCcpOyAvLyBJcyB0aGUgbGVuZ3RoIGxvbmdlciB0aGFuIHRoZSBkb2N1bWVudFxuXG5cdCAgICAgIGlmIChiaW5hcnlTaXplID4gQnVmZmVyJDQuYnl0ZUxlbmd0aChidWZmZXIkJDEpKSB0aHJvdyBuZXcgRXJyb3IoJ0JpbmFyeSB0eXBlIHNpemUgbGFyZ2VyIHRoYW4gZG9jdW1lbnQgc2l6ZScpOyAvLyBEZWNvZGUgYXMgcmF3IEJ1ZmZlciBvYmplY3QgaWYgb3B0aW9ucyBzcGVjaWZpZXMgaXRcblxuXHQgICAgICBpZiAoYnVmZmVyJCQxWydzbGljZSddICE9IG51bGwpIHtcblx0ICAgICAgICAvLyBJZiB3ZSBoYXZlIHN1YnR5cGUgMiBza2lwIHRoZSA0IGJ5dGVzIGZvciB0aGUgc2l6ZVxuXHQgICAgICAgIGlmIChzdWJUeXBlID09PSBiaW5hcnkuU1VCVFlQRV9CWVRFX0FSUkFZKSB7XG5cdCAgICAgICAgICBiaW5hcnlTaXplID0gYnVmZmVyJCQxW2luZGV4KytdIHwgYnVmZmVyJCQxW2luZGV4KytdIDw8IDggfCBidWZmZXIkJDFbaW5kZXgrK10gPDwgMTYgfCBidWZmZXIkJDFbaW5kZXgrK10gPDwgMjQ7XG5cdCAgICAgICAgICBpZiAoYmluYXJ5U2l6ZSA8IDApIHRocm93IG5ldyBFcnJvcignTmVnYXRpdmUgYmluYXJ5IHR5cGUgZWxlbWVudCBzaXplIGZvdW5kIGZvciBzdWJ0eXBlIDB4MDInKTtcblx0ICAgICAgICAgIGlmIChiaW5hcnlTaXplID4gdG90YWxCaW5hcnlTaXplIC0gNCkgdGhyb3cgbmV3IEVycm9yKCdCaW5hcnkgdHlwZSB3aXRoIHN1YnR5cGUgMHgwMiBjb250YWlucyB0byBsb25nIGJpbmFyeSBzaXplJyk7XG5cdCAgICAgICAgICBpZiAoYmluYXJ5U2l6ZSA8IHRvdGFsQmluYXJ5U2l6ZSAtIDQpIHRocm93IG5ldyBFcnJvcignQmluYXJ5IHR5cGUgd2l0aCBzdWJ0eXBlIDB4MDIgY29udGFpbnMgdG8gc2hvcnQgYmluYXJ5IHNpemUnKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAocHJvbW90ZUJ1ZmZlcnMgJiYgcHJvbW90ZVZhbHVlcykge1xuXHQgICAgICAgICAgb2JqZWN0W25hbWVdID0gYnVmZmVyJCQxLnNsaWNlKGluZGV4LCBpbmRleCArIGJpbmFyeVNpemUpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBvYmplY3RbbmFtZV0gPSBuZXcgYmluYXJ5KGJ1ZmZlciQkMS5zbGljZShpbmRleCwgaW5kZXggKyBiaW5hcnlTaXplKSwgc3ViVHlwZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHZhciBfYnVmZmVyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gbmV3IFVpbnQ4QXJyYXkobmV3IEFycmF5QnVmZmVyKGJpbmFyeVNpemUpKSA6IG5ldyBBcnJheShiaW5hcnlTaXplKTsgLy8gSWYgd2UgaGF2ZSBzdWJ0eXBlIDIgc2tpcCB0aGUgNCBieXRlcyBmb3IgdGhlIHNpemVcblxuXG5cdCAgICAgICAgaWYgKHN1YlR5cGUgPT09IGJpbmFyeS5TVUJUWVBFX0JZVEVfQVJSQVkpIHtcblx0ICAgICAgICAgIGJpbmFyeVNpemUgPSBidWZmZXIkJDFbaW5kZXgrK10gfCBidWZmZXIkJDFbaW5kZXgrK10gPDwgOCB8IGJ1ZmZlciQkMVtpbmRleCsrXSA8PCAxNiB8IGJ1ZmZlciQkMVtpbmRleCsrXSA8PCAyNDtcblx0ICAgICAgICAgIGlmIChiaW5hcnlTaXplIDwgMCkgdGhyb3cgbmV3IEVycm9yKCdOZWdhdGl2ZSBiaW5hcnkgdHlwZSBlbGVtZW50IHNpemUgZm91bmQgZm9yIHN1YnR5cGUgMHgwMicpO1xuXHQgICAgICAgICAgaWYgKGJpbmFyeVNpemUgPiB0b3RhbEJpbmFyeVNpemUgLSA0KSB0aHJvdyBuZXcgRXJyb3IoJ0JpbmFyeSB0eXBlIHdpdGggc3VidHlwZSAweDAyIGNvbnRhaW5zIHRvIGxvbmcgYmluYXJ5IHNpemUnKTtcblx0ICAgICAgICAgIGlmIChiaW5hcnlTaXplIDwgdG90YWxCaW5hcnlTaXplIC0gNCkgdGhyb3cgbmV3IEVycm9yKCdCaW5hcnkgdHlwZSB3aXRoIHN1YnR5cGUgMHgwMiBjb250YWlucyB0byBzaG9ydCBiaW5hcnkgc2l6ZScpO1xuXHQgICAgICAgIH0gLy8gQ29weSB0aGUgZGF0YVxuXG5cblx0ICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYmluYXJ5U2l6ZTsgaSsrKSB7XG5cdCAgICAgICAgICBfYnVmZmVyW2ldID0gYnVmZmVyJCQxW2luZGV4ICsgaV07XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKHByb21vdGVCdWZmZXJzICYmIHByb21vdGVWYWx1ZXMpIHtcblx0ICAgICAgICAgIG9iamVjdFtuYW1lXSA9IF9idWZmZXI7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIG9iamVjdFtuYW1lXSA9IG5ldyBiaW5hcnkoX2J1ZmZlciwgc3ViVHlwZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9IC8vIFVwZGF0ZSB0aGUgaW5kZXhcblxuXG5cdCAgICAgIGluZGV4ID0gaW5kZXggKyBiaW5hcnlTaXplO1xuXHQgICAgfSBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gY29uc3RhbnRzLkJTT05fREFUQV9SRUdFWFAgJiYgYnNvblJlZ0V4cCA9PT0gZmFsc2UpIHtcblx0ICAgICAgLy8gR2V0IHRoZSBzdGFydCBzZWFyY2ggaW5kZXhcblx0ICAgICAgaSA9IGluZGV4OyAvLyBMb2NhdGUgdGhlIGVuZCBvZiB0aGUgYyBzdHJpbmdcblxuXHQgICAgICB3aGlsZSAoYnVmZmVyJCQxW2ldICE9PSAweDAwICYmIGkgPCBidWZmZXIkJDEubGVuZ3RoKSB7XG5cdCAgICAgICAgaSsrO1xuXHQgICAgICB9IC8vIElmIGFyZSBhdCB0aGUgZW5kIG9mIHRoZSBidWZmZXIgdGhlcmUgaXMgYSBwcm9ibGVtIHdpdGggdGhlIGRvY3VtZW50XG5cblxuXHQgICAgICBpZiAoaSA+PSBidWZmZXIkJDEubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0JhZCBCU09OIERvY3VtZW50OiBpbGxlZ2FsIENTdHJpbmcnKTsgLy8gUmV0dXJuIHRoZSBDIHN0cmluZ1xuXG5cdCAgICAgIHZhciBzb3VyY2UgPSBidWZmZXIkJDEudG9TdHJpbmcoJ3V0ZjgnLCBpbmRleCwgaSk7IC8vIENyZWF0ZSB0aGUgcmVnZXhwXG5cblx0ICAgICAgaW5kZXggPSBpICsgMTsgLy8gR2V0IHRoZSBzdGFydCBzZWFyY2ggaW5kZXhcblxuXHQgICAgICBpID0gaW5kZXg7IC8vIExvY2F0ZSB0aGUgZW5kIG9mIHRoZSBjIHN0cmluZ1xuXG5cdCAgICAgIHdoaWxlIChidWZmZXIkJDFbaV0gIT09IDB4MDAgJiYgaSA8IGJ1ZmZlciQkMS5sZW5ndGgpIHtcblx0ICAgICAgICBpKys7XG5cdCAgICAgIH0gLy8gSWYgYXJlIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciB0aGVyZSBpcyBhIHByb2JsZW0gd2l0aCB0aGUgZG9jdW1lbnRcblxuXG5cdCAgICAgIGlmIChpID49IGJ1ZmZlciQkMS5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignQmFkIEJTT04gRG9jdW1lbnQ6IGlsbGVnYWwgQ1N0cmluZycpOyAvLyBSZXR1cm4gdGhlIEMgc3RyaW5nXG5cblx0ICAgICAgdmFyIHJlZ0V4cE9wdGlvbnMgPSBidWZmZXIkJDEudG9TdHJpbmcoJ3V0ZjgnLCBpbmRleCwgaSk7XG5cdCAgICAgIGluZGV4ID0gaSArIDE7IC8vIEZvciBlYWNoIG9wdGlvbiBhZGQgdGhlIGNvcnJlc3BvbmRpbmcgb25lIGZvciBqYXZhc2NyaXB0XG5cblx0ICAgICAgdmFyIG9wdGlvbnNBcnJheSA9IG5ldyBBcnJheShyZWdFeHBPcHRpb25zLmxlbmd0aCk7IC8vIFBhcnNlIG9wdGlvbnNcblxuXHQgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVnRXhwT3B0aW9ucy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHN3aXRjaCAocmVnRXhwT3B0aW9uc1tpXSkge1xuXHQgICAgICAgICAgY2FzZSAnbSc6XG5cdCAgICAgICAgICAgIG9wdGlvbnNBcnJheVtpXSA9ICdtJztcblx0ICAgICAgICAgICAgYnJlYWs7XG5cblx0ICAgICAgICAgIGNhc2UgJ3MnOlxuXHQgICAgICAgICAgICBvcHRpb25zQXJyYXlbaV0gPSAnZyc7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXG5cdCAgICAgICAgICBjYXNlICdpJzpcblx0ICAgICAgICAgICAgb3B0aW9uc0FycmF5W2ldID0gJ2knO1xuXHQgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICBvYmplY3RbbmFtZV0gPSBuZXcgUmVnRXhwKHNvdXJjZSwgb3B0aW9uc0FycmF5LmpvaW4oJycpKTtcblx0ICAgIH0gZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IGNvbnN0YW50cy5CU09OX0RBVEFfUkVHRVhQICYmIGJzb25SZWdFeHAgPT09IHRydWUpIHtcblx0ICAgICAgLy8gR2V0IHRoZSBzdGFydCBzZWFyY2ggaW5kZXhcblx0ICAgICAgaSA9IGluZGV4OyAvLyBMb2NhdGUgdGhlIGVuZCBvZiB0aGUgYyBzdHJpbmdcblxuXHQgICAgICB3aGlsZSAoYnVmZmVyJCQxW2ldICE9PSAweDAwICYmIGkgPCBidWZmZXIkJDEubGVuZ3RoKSB7XG5cdCAgICAgICAgaSsrO1xuXHQgICAgICB9IC8vIElmIGFyZSBhdCB0aGUgZW5kIG9mIHRoZSBidWZmZXIgdGhlcmUgaXMgYSBwcm9ibGVtIHdpdGggdGhlIGRvY3VtZW50XG5cblxuXHQgICAgICBpZiAoaSA+PSBidWZmZXIkJDEubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0JhZCBCU09OIERvY3VtZW50OiBpbGxlZ2FsIENTdHJpbmcnKTsgLy8gUmV0dXJuIHRoZSBDIHN0cmluZ1xuXG5cdCAgICAgIHZhciBfc291cmNlID0gYnVmZmVyJCQxLnRvU3RyaW5nKCd1dGY4JywgaW5kZXgsIGkpO1xuXG5cdCAgICAgIGluZGV4ID0gaSArIDE7IC8vIEdldCB0aGUgc3RhcnQgc2VhcmNoIGluZGV4XG5cblx0ICAgICAgaSA9IGluZGV4OyAvLyBMb2NhdGUgdGhlIGVuZCBvZiB0aGUgYyBzdHJpbmdcblxuXHQgICAgICB3aGlsZSAoYnVmZmVyJCQxW2ldICE9PSAweDAwICYmIGkgPCBidWZmZXIkJDEubGVuZ3RoKSB7XG5cdCAgICAgICAgaSsrO1xuXHQgICAgICB9IC8vIElmIGFyZSBhdCB0aGUgZW5kIG9mIHRoZSBidWZmZXIgdGhlcmUgaXMgYSBwcm9ibGVtIHdpdGggdGhlIGRvY3VtZW50XG5cblxuXHQgICAgICBpZiAoaSA+PSBidWZmZXIkJDEubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0JhZCBCU09OIERvY3VtZW50OiBpbGxlZ2FsIENTdHJpbmcnKTsgLy8gUmV0dXJuIHRoZSBDIHN0cmluZ1xuXG5cdCAgICAgIHZhciBfcmVnRXhwT3B0aW9ucyA9IGJ1ZmZlciQkMS50b1N0cmluZygndXRmOCcsIGluZGV4LCBpKTtcblxuXHQgICAgICBpbmRleCA9IGkgKyAxOyAvLyBTZXQgdGhlIG9iamVjdFxuXG5cdCAgICAgIG9iamVjdFtuYW1lXSA9IG5ldyByZWdleHAoX3NvdXJjZSwgX3JlZ0V4cE9wdGlvbnMpO1xuXHQgICAgfSBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gY29uc3RhbnRzLkJTT05fREFUQV9TWU1CT0wpIHtcblx0ICAgICAgdmFyIF9zdHJpbmdTaXplID0gYnVmZmVyJCQxW2luZGV4KytdIHwgYnVmZmVyJCQxW2luZGV4KytdIDw8IDggfCBidWZmZXIkJDFbaW5kZXgrK10gPDwgMTYgfCBidWZmZXIkJDFbaW5kZXgrK10gPDwgMjQ7XG5cblx0ICAgICAgaWYgKF9zdHJpbmdTaXplIDw9IDAgfHwgX3N0cmluZ1NpemUgPiBidWZmZXIkJDEubGVuZ3RoIC0gaW5kZXggfHwgYnVmZmVyJCQxW2luZGV4ICsgX3N0cmluZ1NpemUgLSAxXSAhPT0gMCkgdGhyb3cgbmV3IEVycm9yKCdiYWQgc3RyaW5nIGxlbmd0aCBpbiBic29uJyk7IC8vIHN5bWJvbCBpcyBkZXByZWNhdGVkIC0gdXBncmFkZSB0byBzdHJpbmcuXG5cblx0ICAgICAgb2JqZWN0W25hbWVdID0gYnVmZmVyJCQxLnRvU3RyaW5nKCd1dGY4JywgaW5kZXgsIGluZGV4ICsgX3N0cmluZ1NpemUgLSAxKTtcblx0ICAgICAgaW5kZXggPSBpbmRleCArIF9zdHJpbmdTaXplO1xuXHQgICAgfSBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gY29uc3RhbnRzLkJTT05fREFUQV9USU1FU1RBTVApIHtcblx0ICAgICAgdmFyIF9sb3dCaXRzMiA9IGJ1ZmZlciQkMVtpbmRleCsrXSB8IGJ1ZmZlciQkMVtpbmRleCsrXSA8PCA4IHwgYnVmZmVyJCQxW2luZGV4KytdIDw8IDE2IHwgYnVmZmVyJCQxW2luZGV4KytdIDw8IDI0O1xuXG5cdCAgICAgIHZhciBfaGlnaEJpdHMyID0gYnVmZmVyJCQxW2luZGV4KytdIHwgYnVmZmVyJCQxW2luZGV4KytdIDw8IDggfCBidWZmZXIkJDFbaW5kZXgrK10gPDwgMTYgfCBidWZmZXIkJDFbaW5kZXgrK10gPDwgMjQ7XG5cblx0ICAgICAgb2JqZWN0W25hbWVdID0gbmV3IHRpbWVzdGFtcChfbG93Qml0czIsIF9oaWdoQml0czIpO1xuXHQgICAgfSBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gY29uc3RhbnRzLkJTT05fREFUQV9NSU5fS0VZKSB7XG5cdCAgICAgIG9iamVjdFtuYW1lXSA9IG5ldyBtaW5fa2V5KCk7XG5cdCAgICB9IGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBjb25zdGFudHMuQlNPTl9EQVRBX01BWF9LRVkpIHtcblx0ICAgICAgb2JqZWN0W25hbWVdID0gbmV3IG1heF9rZXkoKTtcblx0ICAgIH0gZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IGNvbnN0YW50cy5CU09OX0RBVEFfQ09ERSkge1xuXHQgICAgICB2YXIgX3N0cmluZ1NpemUyID0gYnVmZmVyJCQxW2luZGV4KytdIHwgYnVmZmVyJCQxW2luZGV4KytdIDw8IDggfCBidWZmZXIkJDFbaW5kZXgrK10gPDwgMTYgfCBidWZmZXIkJDFbaW5kZXgrK10gPDwgMjQ7XG5cblx0ICAgICAgaWYgKF9zdHJpbmdTaXplMiA8PSAwIHx8IF9zdHJpbmdTaXplMiA+IGJ1ZmZlciQkMS5sZW5ndGggLSBpbmRleCB8fCBidWZmZXIkJDFbaW5kZXggKyBfc3RyaW5nU2l6ZTIgLSAxXSAhPT0gMCkgdGhyb3cgbmV3IEVycm9yKCdiYWQgc3RyaW5nIGxlbmd0aCBpbiBic29uJyk7XG5cdCAgICAgIHZhciBmdW5jdGlvblN0cmluZyA9IGJ1ZmZlciQkMS50b1N0cmluZygndXRmOCcsIGluZGV4LCBpbmRleCArIF9zdHJpbmdTaXplMiAtIDEpOyAvLyBJZiB3ZSBhcmUgZXZhbHVhdGluZyB0aGUgZnVuY3Rpb25zXG5cblx0ICAgICAgaWYgKGV2YWxGdW5jdGlvbnMpIHtcblx0ICAgICAgICAvLyBJZiB3ZSBoYXZlIGNhY2hlIGVuYWJsZWQgbGV0J3MgbG9vayBmb3IgdGhlIG1kNSBvZiB0aGUgZnVuY3Rpb24gaW4gdGhlIGNhY2hlXG5cdCAgICAgICAgaWYgKGNhY2hlRnVuY3Rpb25zKSB7XG5cdCAgICAgICAgICB2YXIgaGFzaCA9IGNhY2hlRnVuY3Rpb25zQ3JjMzIgPyBjcmMzMihmdW5jdGlvblN0cmluZykgOiBmdW5jdGlvblN0cmluZzsgLy8gR290IHRvIGRvIHRoaXMgdG8gYXZvaWQgVjggZGVvcHRpbWl6aW5nIHRoZSBjYWxsIGR1ZSB0byBmaW5kaW5nIGV2YWxcblxuXHQgICAgICAgICAgb2JqZWN0W25hbWVdID0gaXNvbGF0ZUV2YWxXaXRoSGFzaChmdW5jdGlvbkNhY2hlLCBoYXNoLCBmdW5jdGlvblN0cmluZywgb2JqZWN0KTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgb2JqZWN0W25hbWVdID0gaXNvbGF0ZUV2YWwoZnVuY3Rpb25TdHJpbmcpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBvYmplY3RbbmFtZV0gPSBuZXcgY29kZShmdW5jdGlvblN0cmluZyk7XG5cdCAgICAgIH0gLy8gVXBkYXRlIHBhcnNlIGluZGV4IHBvc2l0aW9uXG5cblxuXHQgICAgICBpbmRleCA9IGluZGV4ICsgX3N0cmluZ1NpemUyO1xuXHQgICAgfSBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gY29uc3RhbnRzLkJTT05fREFUQV9DT0RFX1dfU0NPUEUpIHtcblx0ICAgICAgdmFyIHRvdGFsU2l6ZSA9IGJ1ZmZlciQkMVtpbmRleCsrXSB8IGJ1ZmZlciQkMVtpbmRleCsrXSA8PCA4IHwgYnVmZmVyJCQxW2luZGV4KytdIDw8IDE2IHwgYnVmZmVyJCQxW2luZGV4KytdIDw8IDI0OyAvLyBFbGVtZW50IGNhbm5vdCBiZSBzaG9ydGVyIHRoYW4gdG90YWxTaXplICsgc3RyaW5nU2l6ZSArIGRvY3VtZW50U2l6ZSArIHRlcm1pbmF0b3JcblxuXHQgICAgICBpZiAodG90YWxTaXplIDwgNCArIDQgKyA0ICsgMSkge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignY29kZV93X3Njb3BlIHRvdGFsIHNpemUgc2hvcnRlciBtaW5pbXVtIGV4cGVjdGVkIGxlbmd0aCcpO1xuXHQgICAgICB9IC8vIEdldCB0aGUgY29kZSBzdHJpbmcgc2l6ZVxuXG5cblx0ICAgICAgdmFyIF9zdHJpbmdTaXplMyA9IGJ1ZmZlciQkMVtpbmRleCsrXSB8IGJ1ZmZlciQkMVtpbmRleCsrXSA8PCA4IHwgYnVmZmVyJCQxW2luZGV4KytdIDw8IDE2IHwgYnVmZmVyJCQxW2luZGV4KytdIDw8IDI0OyAvLyBDaGVjayBpZiB3ZSBoYXZlIGEgdmFsaWQgc3RyaW5nXG5cblxuXHQgICAgICBpZiAoX3N0cmluZ1NpemUzIDw9IDAgfHwgX3N0cmluZ1NpemUzID4gYnVmZmVyJCQxLmxlbmd0aCAtIGluZGV4IHx8IGJ1ZmZlciQkMVtpbmRleCArIF9zdHJpbmdTaXplMyAtIDFdICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBzdHJpbmcgbGVuZ3RoIGluIGJzb24nKTsgLy8gSmF2YXNjcmlwdCBmdW5jdGlvblxuXG5cdCAgICAgIHZhciBfZnVuY3Rpb25TdHJpbmcgPSBidWZmZXIkJDEudG9TdHJpbmcoJ3V0ZjgnLCBpbmRleCwgaW5kZXggKyBfc3RyaW5nU2l6ZTMgLSAxKTsgLy8gVXBkYXRlIHBhcnNlIGluZGV4IHBvc2l0aW9uXG5cblxuXHQgICAgICBpbmRleCA9IGluZGV4ICsgX3N0cmluZ1NpemUzOyAvLyBQYXJzZSB0aGUgZWxlbWVudFxuXG5cdCAgICAgIHZhciBfaW5kZXgzID0gaW5kZXg7IC8vIERlY29kZSB0aGUgc2l6ZSBvZiB0aGUgb2JqZWN0IGRvY3VtZW50XG5cblx0ICAgICAgdmFyIF9vYmplY3RTaXplMiA9IGJ1ZmZlciQkMVtpbmRleF0gfCBidWZmZXIkJDFbaW5kZXggKyAxXSA8PCA4IHwgYnVmZmVyJCQxW2luZGV4ICsgMl0gPDwgMTYgfCBidWZmZXIkJDFbaW5kZXggKyAzXSA8PCAyNDsgLy8gRGVjb2RlIHRoZSBzY29wZSBvYmplY3RcblxuXG5cdCAgICAgIHZhciBzY29wZU9iamVjdCA9IGRlc2VyaWFsaXplT2JqZWN0KGJ1ZmZlciQkMSwgX2luZGV4Mywgb3B0aW9ucywgZmFsc2UpOyAvLyBBZGp1c3QgdGhlIGluZGV4XG5cblx0ICAgICAgaW5kZXggPSBpbmRleCArIF9vYmplY3RTaXplMjsgLy8gQ2hlY2sgaWYgZmllbGQgbGVuZ3RoIGlzIHRvIHNob3J0XG5cblx0ICAgICAgaWYgKHRvdGFsU2l6ZSA8IDQgKyA0ICsgX29iamVjdFNpemUyICsgX3N0cmluZ1NpemUzKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb2RlX3dfc2NvcGUgdG90YWwgc2l6ZSBpcyB0byBzaG9ydCwgdHJ1bmNhdGluZyBzY29wZScpO1xuXHQgICAgICB9IC8vIENoZWNrIGlmIHRvdGFsU2l6ZSBmaWVsZCBpcyB0byBsb25nXG5cblxuXHQgICAgICBpZiAodG90YWxTaXplID4gNCArIDQgKyBfb2JqZWN0U2l6ZTIgKyBfc3RyaW5nU2l6ZTMpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvZGVfd19zY29wZSB0b3RhbCBzaXplIGlzIHRvIGxvbmcsIGNsaXBzIG91dGVyIGRvY3VtZW50Jyk7XG5cdCAgICAgIH0gLy8gSWYgd2UgYXJlIGV2YWx1YXRpbmcgdGhlIGZ1bmN0aW9uc1xuXG5cblx0ICAgICAgaWYgKGV2YWxGdW5jdGlvbnMpIHtcblx0ICAgICAgICAvLyBJZiB3ZSBoYXZlIGNhY2hlIGVuYWJsZWQgbGV0J3MgbG9vayBmb3IgdGhlIG1kNSBvZiB0aGUgZnVuY3Rpb24gaW4gdGhlIGNhY2hlXG5cdCAgICAgICAgaWYgKGNhY2hlRnVuY3Rpb25zKSB7XG5cdCAgICAgICAgICB2YXIgX2hhc2ggPSBjYWNoZUZ1bmN0aW9uc0NyYzMyID8gY3JjMzIoX2Z1bmN0aW9uU3RyaW5nKSA6IF9mdW5jdGlvblN0cmluZzsgLy8gR290IHRvIGRvIHRoaXMgdG8gYXZvaWQgVjggZGVvcHRpbWl6aW5nIHRoZSBjYWxsIGR1ZSB0byBmaW5kaW5nIGV2YWxcblxuXG5cdCAgICAgICAgICBvYmplY3RbbmFtZV0gPSBpc29sYXRlRXZhbFdpdGhIYXNoKGZ1bmN0aW9uQ2FjaGUsIF9oYXNoLCBfZnVuY3Rpb25TdHJpbmcsIG9iamVjdCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIG9iamVjdFtuYW1lXSA9IGlzb2xhdGVFdmFsKF9mdW5jdGlvblN0cmluZyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgb2JqZWN0W25hbWVdLnNjb3BlID0gc2NvcGVPYmplY3Q7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgb2JqZWN0W25hbWVdID0gbmV3IGNvZGUoX2Z1bmN0aW9uU3RyaW5nLCBzY29wZU9iamVjdCk7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IGNvbnN0YW50cy5CU09OX0RBVEFfREJQT0lOVEVSKSB7XG5cdCAgICAgIC8vIEdldCB0aGUgY29kZSBzdHJpbmcgc2l6ZVxuXHQgICAgICB2YXIgX3N0cmluZ1NpemU0ID0gYnVmZmVyJCQxW2luZGV4KytdIHwgYnVmZmVyJCQxW2luZGV4KytdIDw8IDggfCBidWZmZXIkJDFbaW5kZXgrK10gPDwgMTYgfCBidWZmZXIkJDFbaW5kZXgrK10gPDwgMjQ7IC8vIENoZWNrIGlmIHdlIGhhdmUgYSB2YWxpZCBzdHJpbmdcblxuXG5cdCAgICAgIGlmIChfc3RyaW5nU2l6ZTQgPD0gMCB8fCBfc3RyaW5nU2l6ZTQgPiBidWZmZXIkJDEubGVuZ3RoIC0gaW5kZXggfHwgYnVmZmVyJCQxW2luZGV4ICsgX3N0cmluZ1NpemU0IC0gMV0gIT09IDApIHRocm93IG5ldyBFcnJvcignYmFkIHN0cmluZyBsZW5ndGggaW4gYnNvbicpOyAvLyBOYW1lc3BhY2VcblxuXHQgICAgICBpZiAoIXZhbGlkYXRlVXRmOCQxKGJ1ZmZlciQkMSwgaW5kZXgsIGluZGV4ICsgX3N0cmluZ1NpemU0IC0gMSkpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgVVRGLTggc3RyaW5nIGluIEJTT04gZG9jdW1lbnQnKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHZhciBuYW1lc3BhY2UgPSBidWZmZXIkJDEudG9TdHJpbmcoJ3V0ZjgnLCBpbmRleCwgaW5kZXggKyBfc3RyaW5nU2l6ZTQgLSAxKTsgLy8gVXBkYXRlIHBhcnNlIGluZGV4IHBvc2l0aW9uXG5cblx0ICAgICAgaW5kZXggPSBpbmRleCArIF9zdHJpbmdTaXplNDsgLy8gUmVhZCB0aGUgb2lkXG5cblx0ICAgICAgdmFyIG9pZEJ1ZmZlciA9IEJ1ZmZlciQ0LmFsbG9jKDEyKTtcblx0ICAgICAgYnVmZmVyJCQxLmNvcHkob2lkQnVmZmVyLCAwLCBpbmRleCwgaW5kZXggKyAxMik7XG5cblx0ICAgICAgdmFyIF9vaWQgPSBuZXcgb2JqZWN0aWQob2lkQnVmZmVyKTsgLy8gVXBkYXRlIHRoZSBpbmRleFxuXG5cblx0ICAgICAgaW5kZXggPSBpbmRleCArIDEyOyAvLyBVcGdyYWRlIHRvIERCUmVmIHR5cGVcblxuXHQgICAgICBvYmplY3RbbmFtZV0gPSBuZXcgZGJfcmVmKG5hbWVzcGFjZSwgX29pZCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RldGVjdGVkIHVua25vd24gQlNPTiB0eXBlICcgKyBlbGVtZW50VHlwZS50b1N0cmluZygxNikgKyAnIGZvciBmaWVsZG5hbWUgXCInICsgbmFtZSArICdcIiwgYXJlIHlvdSB1c2luZyB0aGUgbGF0ZXN0IEJTT04gcGFyc2VyPycpO1xuXHQgICAgfVxuXHQgIH0gLy8gQ2hlY2sgaWYgdGhlIGRlc2VyaWFsaXphdGlvbiB3YXMgYWdhaW5zdCBhIHZhbGlkIGFycmF5L29iamVjdFxuXG5cblx0ICBpZiAoc2l6ZSAhPT0gaW5kZXggLSBzdGFydEluZGV4KSB7XG5cdCAgICBpZiAoaXNBcnJheSkgdGhyb3cgbmV3IEVycm9yKCdjb3JydXB0IGFycmF5IGJzb24nKTtcblx0ICAgIHRocm93IG5ldyBFcnJvcignY29ycnVwdCBvYmplY3QgYnNvbicpO1xuXHQgIH0gLy8gY2hlY2sgaWYgb2JqZWN0J3MgJCBrZXlzIGFyZSB0aG9zZSBvZiBhIERCUmVmXG5cblxuXHQgIHZhciBkb2xsYXJLZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KS5maWx0ZXIoZnVuY3Rpb24gKGspIHtcblx0ICAgIHJldHVybiBrLnN0YXJ0c1dpdGgoJyQnKTtcblx0ICB9KTtcblx0ICB2YXIgdmFsaWQgPSB0cnVlO1xuXHQgIGRvbGxhcktleXMuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHQgICAgaWYgKFsnJHJlZicsICckaWQnLCAnJGRiJ10uaW5kZXhPZihrKSA9PT0gLTEpIHZhbGlkID0gZmFsc2U7XG5cdCAgfSk7IC8vIGlmIGEgJGtleSBub3QgaW4gXCIkcmVmXCIsIFwiJGlkXCIsIFwiJGRiXCIsIGRvbid0IG1ha2UgYSBEQlJlZlxuXG5cdCAgaWYgKCF2YWxpZCkgcmV0dXJuIG9iamVjdDtcblxuXHQgIGlmIChvYmplY3RbJyRpZCddICE9IG51bGwgJiYgb2JqZWN0WyckcmVmJ10gIT0gbnVsbCkge1xuXHQgICAgdmFyIGNvcHkgPSBPYmplY3QuYXNzaWduKHt9LCBvYmplY3QpO1xuXHQgICAgZGVsZXRlIGNvcHkuJHJlZjtcblx0ICAgIGRlbGV0ZSBjb3B5LiRpZDtcblx0ICAgIGRlbGV0ZSBjb3B5LiRkYjtcblx0ICAgIHJldHVybiBuZXcgZGJfcmVmKG9iamVjdC4kcmVmLCBvYmplY3QuJGlkLCBvYmplY3QuJGRiIHx8IG51bGwsIGNvcHkpO1xuXHQgIH1cblxuXHQgIHJldHVybiBvYmplY3Q7XG5cdH1cblx0LyoqXG5cdCAqIEVuc3VyZSBldmFsIGlzIGlzb2xhdGVkLlxuXHQgKlxuXHQgKiBAaWdub3JlXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXG5cdGZ1bmN0aW9uIGlzb2xhdGVFdmFsV2l0aEhhc2goZnVuY3Rpb25DYWNoZSwgaGFzaCwgZnVuY3Rpb25TdHJpbmcsIG9iamVjdCkge1xuXHQgIC8vIENvbnRhaW5zIHRoZSB2YWx1ZSB3ZSBhcmUgZ29pbmcgdG8gc2V0XG5cdCAgdmFyIHZhbHVlID0gbnVsbDsgLy8gQ2hlY2sgZm9yIGNhY2hlIGhpdCwgZXZhbCBpZiBtaXNzaW5nIGFuZCByZXR1cm4gY2FjaGVkIGZ1bmN0aW9uXG5cblx0ICBpZiAoZnVuY3Rpb25DYWNoZVtoYXNoXSA9PSBudWxsKSB7XG5cdCAgICBldmFsKCd2YWx1ZSA9ICcgKyBmdW5jdGlvblN0cmluZyk7XG5cdCAgICBmdW5jdGlvbkNhY2hlW2hhc2hdID0gdmFsdWU7XG5cdCAgfSAvLyBTZXQgdGhlIG9iamVjdFxuXG5cblx0ICByZXR1cm4gZnVuY3Rpb25DYWNoZVtoYXNoXS5iaW5kKG9iamVjdCk7XG5cdH1cblx0LyoqXG5cdCAqIEVuc3VyZSBldmFsIGlzIGlzb2xhdGVkLlxuXHQgKlxuXHQgKiBAaWdub3JlXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXG5cdGZ1bmN0aW9uIGlzb2xhdGVFdmFsKGZ1bmN0aW9uU3RyaW5nKSB7XG5cdCAgLy8gQ29udGFpbnMgdGhlIHZhbHVlIHdlIGFyZSBnb2luZyB0byBzZXRcblx0ICB2YXIgdmFsdWUgPSBudWxsOyAvLyBFdmFsIHRoZSBmdW5jdGlvblxuXG5cdCAgZXZhbCgndmFsdWUgPSAnICsgZnVuY3Rpb25TdHJpbmcpO1xuXHQgIHJldHVybiB2YWx1ZTtcblx0fVxuXG5cdHZhciBkZXNlcmlhbGl6ZXIgPSBkZXNlcmlhbGl6ZSQxO1xuXG5cdC8vIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cdC8vXG5cdC8vIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuXHQvLyBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblx0Ly9cblx0Ly8gICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuXHQvLyAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuXHQvL1xuXHQvLyAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG5cdC8vICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cblx0Ly8gICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cdC8vXG5cdC8vICAqIE5laXRoZXIgdGhlIG5hbWUgb2YgRmFpciBPYWtzIExhYnMsIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzXG5cdC8vICAgIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZVxuXHQvLyAgICB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cblx0Ly9cblx0Ly8gVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcblx0Ly8gQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuXHQvLyBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuXHQvLyBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFXG5cdC8vIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1Jcblx0Ly8gQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0Zcblx0Ly8gU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXG5cdC8vIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOXG5cdC8vIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG5cdC8vIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG5cdC8vIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuXHQvL1xuXHQvL1xuXHQvLyBNb2RpZmljYXRpb25zIHRvIHdyaXRlSUVFRTc1NCB0byBzdXBwb3J0IG5lZ2F0aXZlIHplcm9lcyBtYWRlIGJ5IEJyaWFuIFdoaXRlXG5cblx0ZnVuY3Rpb24gcmVhZElFRUU3NTQoYnVmZmVyJCQxLCBvZmZzZXQsIGVuZGlhbiwgbUxlbiwgbkJ5dGVzKSB7XG5cdCAgdmFyIGUsXG5cdCAgICAgIG0sXG5cdCAgICAgIGJCRSA9IGVuZGlhbiA9PT0gJ2JpZycsXG5cdCAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG5cdCAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG5cdCAgICAgIGVCaWFzID0gZU1heCA+PiAxLFxuXHQgICAgICBuQml0cyA9IC03LFxuXHQgICAgICBpID0gYkJFID8gMCA6IG5CeXRlcyAtIDEsXG5cdCAgICAgIGQgPSBiQkUgPyAxIDogLTEsXG5cdCAgICAgIHMgPSBidWZmZXIkJDFbb2Zmc2V0ICsgaV07XG5cdCAgaSArPSBkO1xuXHQgIGUgPSBzICYgKDEgPDwgLW5CaXRzKSAtIDE7XG5cdCAgcyA+Pj0gLW5CaXRzO1xuXHQgIG5CaXRzICs9IGVMZW47XG5cblx0ICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlciQkMVtvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7XG5cdCAgfVxuXG5cdCAgbSA9IGUgJiAoMSA8PCAtbkJpdHMpIC0gMTtcblx0ICBlID4+PSAtbkJpdHM7XG5cdCAgbkJpdHMgKz0gbUxlbjtcblxuXHQgIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyJCQxW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHtcblx0ICB9XG5cblx0ICBpZiAoZSA9PT0gMCkge1xuXHQgICAgZSA9IDEgLSBlQmlhcztcblx0ICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcblx0ICAgIHJldHVybiBtID8gTmFOIDogKHMgPyAtMSA6IDEpICogSW5maW5pdHk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbik7XG5cdCAgICBlID0gZSAtIGVCaWFzO1xuXHQgIH1cblxuXHQgIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pO1xuXHR9XG5cblx0ZnVuY3Rpb24gd3JpdGVJRUVFNzU0KGJ1ZmZlciQkMSwgdmFsdWUsIG9mZnNldCwgZW5kaWFuLCBtTGVuLCBuQnl0ZXMpIHtcblx0ICB2YXIgZSxcblx0ICAgICAgbSxcblx0ICAgICAgYyxcblx0ICAgICAgYkJFID0gZW5kaWFuID09PSAnYmlnJyxcblx0ICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcblx0ICAgICAgZU1heCA9ICgxIDw8IGVMZW4pIC0gMSxcblx0ICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG5cdCAgICAgIHJ0ID0gbUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDAsXG5cdCAgICAgIGkgPSBiQkUgPyBuQnl0ZXMgLSAxIDogMCxcblx0ICAgICAgZCA9IGJCRSA/IC0xIDogMSxcblx0ICAgICAgcyA9IHZhbHVlIDwgMCB8fCB2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwID8gMSA6IDA7XG5cdCAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XG5cblx0ICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuXHQgICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwO1xuXHQgICAgZSA9IGVNYXg7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKTtcblxuXHQgICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuXHQgICAgICBlLS07XG5cdCAgICAgIGMgKj0gMjtcblx0ICAgIH1cblxuXHQgICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG5cdCAgICAgIHZhbHVlICs9IHJ0IC8gYztcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG5cdCAgICAgIGUrKztcblx0ICAgICAgYyAvPSAyO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcblx0ICAgICAgbSA9IDA7XG5cdCAgICAgIGUgPSBlTWF4O1xuXHQgICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuXHQgICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG5cdCAgICAgIGUgPSBlICsgZUJpYXM7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG5cdCAgICAgIGUgPSAwO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIGlmIChpc05hTih2YWx1ZSkpIG0gPSAwO1xuXG5cdCAgd2hpbGUgKG1MZW4gPj0gOCkge1xuXHQgICAgYnVmZmVyJCQxW29mZnNldCArIGldID0gbSAmIDB4ZmY7XG5cdCAgICBpICs9IGQ7XG5cdCAgICBtIC89IDI1Njtcblx0ICAgIG1MZW4gLT0gODtcblx0ICB9XG5cblx0ICBlID0gZSA8PCBtTGVuIHwgbTtcblx0ICBpZiAoaXNOYU4odmFsdWUpKSBlICs9IDg7XG5cdCAgZUxlbiArPSBtTGVuO1xuXG5cdCAgd2hpbGUgKGVMZW4gPiAwKSB7XG5cdCAgICBidWZmZXIkJDFbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZjtcblx0ICAgIGkgKz0gZDtcblx0ICAgIGUgLz0gMjU2O1xuXHQgICAgZUxlbiAtPSA4O1xuXHQgIH1cblxuXHQgIGJ1ZmZlciQkMVtvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODtcblx0fVxuXG5cdHZhciBmbG9hdF9wYXJzZXIgPSB7XG5cdCAgcmVhZElFRUU3NTQ6IHJlYWRJRUVFNzU0LFxuXHQgIHdyaXRlSUVFRTc1NDogd3JpdGVJRUVFNzU0XG5cdH07XG5cblx0ZnVuY3Rpb24gX3R5cGVvZiQzKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiQzID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YkMyA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mJDMob2JqKTsgfVxuXG5cdHZhciBCdWZmZXIkNSA9IGJ1ZmZlci5CdWZmZXI7XG5cdHZhciB3cml0ZUlFRUU3NTQkMSA9IGZsb2F0X3BhcnNlci53cml0ZUlFRUU3NTQ7XG5cdHZhciBub3JtYWxpemVkRnVuY3Rpb25TdHJpbmckMSA9IHV0aWxzLm5vcm1hbGl6ZWRGdW5jdGlvblN0cmluZztcblx0dmFyIHJlZ2V4cCQxID0gL1xceDAwLzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb250cm9sLXJlZ2V4XG5cblx0dmFyIGlnbm9yZUtleXMgPSBuZXcgU2V0KFsnJGRiJywgJyRyZWYnLCAnJGlkJywgJyRjbHVzdGVyVGltZSddKTsgLy8gVG8gZW5zdXJlIHRoYXQgMC40IG9mIG5vZGUgd29ya3MgY29ycmVjdGx5XG5cblx0dmFyIGlzRGF0ZSQxID0gZnVuY3Rpb24gaXNEYXRlKGQpIHtcblx0ICByZXR1cm4gX3R5cGVvZiQzKGQpID09PSAnb2JqZWN0JyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcblx0fTtcblxuXHR2YXIgaXNSZWdFeHAkMSA9IGZ1bmN0aW9uIGlzUmVnRXhwKGQpIHtcblx0ICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGQpID09PSAnW29iamVjdCBSZWdFeHBdJztcblx0fTtcblxuXHRmdW5jdGlvbiBzZXJpYWxpemVTdHJpbmcoYnVmZmVyJCQxLCBrZXksIHZhbHVlLCBpbmRleCwgaXNBcnJheSkge1xuXHQgIC8vIEVuY29kZSBTdHJpbmcgdHlwZVxuXHQgIGJ1ZmZlciQkMVtpbmRleCsrXSA9IGNvbnN0YW50cy5CU09OX0RBVEFfU1RSSU5HOyAvLyBOdW1iZXIgb2Ygd3JpdHRlbiBieXRlc1xuXG5cdCAgdmFyIG51bWJlck9mV3JpdHRlbkJ5dGVzID0gIWlzQXJyYXkgPyBidWZmZXIkJDEud3JpdGUoa2V5LCBpbmRleCwgJ3V0ZjgnKSA6IGJ1ZmZlciQkMS53cml0ZShrZXksIGluZGV4LCAnYXNjaWknKTsgLy8gRW5jb2RlIHRoZSBuYW1lXG5cblx0ICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgKyAxO1xuXHQgIGJ1ZmZlciQkMVtpbmRleCAtIDFdID0gMDsgLy8gV3JpdGUgdGhlIHN0cmluZ1xuXG5cdCAgdmFyIHNpemUgPSBidWZmZXIkJDEud3JpdGUodmFsdWUsIGluZGV4ICsgNCwgJ3V0ZjgnKTsgLy8gV3JpdGUgdGhlIHNpemUgb2YgdGhlIHN0cmluZyB0byBidWZmZXJcblxuXHQgIGJ1ZmZlciQkMVtpbmRleCArIDNdID0gc2l6ZSArIDEgPj4gMjQgJiAweGZmO1xuXHQgIGJ1ZmZlciQkMVtpbmRleCArIDJdID0gc2l6ZSArIDEgPj4gMTYgJiAweGZmO1xuXHQgIGJ1ZmZlciQkMVtpbmRleCArIDFdID0gc2l6ZSArIDEgPj4gOCAmIDB4ZmY7XG5cdCAgYnVmZmVyJCQxW2luZGV4XSA9IHNpemUgKyAxICYgMHhmZjsgLy8gVXBkYXRlIGluZGV4XG5cblx0ICBpbmRleCA9IGluZGV4ICsgNCArIHNpemU7IC8vIFdyaXRlIHplcm9cblxuXHQgIGJ1ZmZlciQkMVtpbmRleCsrXSA9IDA7XG5cdCAgcmV0dXJuIGluZGV4O1xuXHR9XG5cblx0ZnVuY3Rpb24gc2VyaWFsaXplTnVtYmVyKGJ1ZmZlciQkMSwga2V5LCB2YWx1ZSwgaW5kZXgsIGlzQXJyYXkpIHtcblx0ICAvLyBXZSBoYXZlIGFuIGludGVnZXIgdmFsdWVcblx0ICBpZiAoTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlICYmIHZhbHVlID49IGNvbnN0YW50cy5KU19JTlRfTUlOICYmIHZhbHVlIDw9IGNvbnN0YW50cy5KU19JTlRfTUFYKSB7XG5cdCAgICAvLyBJZiB0aGUgdmFsdWUgZml0cyBpbiAzMiBiaXRzIGVuY29kZSBhcyBpbnQsIGlmIGl0IGZpdHMgaW4gYSBkb3VibGVcblx0ICAgIC8vIGVuY29kZSBpdCBhcyBhIGRvdWJsZSwgb3RoZXJ3aXNlIGxvbmdcblx0ICAgIGlmICh2YWx1ZSA+PSBjb25zdGFudHMuQlNPTl9JTlQzMl9NSU4gJiYgdmFsdWUgPD0gY29uc3RhbnRzLkJTT05fSU5UMzJfTUFYKSB7XG5cdCAgICAgIC8vIFNldCBpbnQgdHlwZSAzMiBiaXRzIG9yIGxlc3Ncblx0ICAgICAgYnVmZmVyJCQxW2luZGV4KytdID0gY29uc3RhbnRzLkJTT05fREFUQV9JTlQ7IC8vIE51bWJlciBvZiB3cml0dGVuIGJ5dGVzXG5cblx0ICAgICAgdmFyIG51bWJlck9mV3JpdHRlbkJ5dGVzID0gIWlzQXJyYXkgPyBidWZmZXIkJDEud3JpdGUoa2V5LCBpbmRleCwgJ3V0ZjgnKSA6IGJ1ZmZlciQkMS53cml0ZShrZXksIGluZGV4LCAnYXNjaWknKTsgLy8gRW5jb2RlIHRoZSBuYW1lXG5cblx0ICAgICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuXHQgICAgICBidWZmZXIkJDFbaW5kZXgrK10gPSAwOyAvLyBXcml0ZSB0aGUgaW50IHZhbHVlXG5cblx0ICAgICAgYnVmZmVyJCQxW2luZGV4KytdID0gdmFsdWUgJiAweGZmO1xuXHQgICAgICBidWZmZXIkJDFbaW5kZXgrK10gPSB2YWx1ZSA+PiA4ICYgMHhmZjtcblx0ICAgICAgYnVmZmVyJCQxW2luZGV4KytdID0gdmFsdWUgPj4gMTYgJiAweGZmO1xuXHQgICAgICBidWZmZXIkJDFbaW5kZXgrK10gPSB2YWx1ZSA+PiAyNCAmIDB4ZmY7XG5cdCAgICB9IGVsc2UgaWYgKHZhbHVlID49IGNvbnN0YW50cy5KU19JTlRfTUlOICYmIHZhbHVlIDw9IGNvbnN0YW50cy5KU19JTlRfTUFYKSB7XG5cdCAgICAgIC8vIEVuY29kZSBhcyBkb3VibGVcblx0ICAgICAgYnVmZmVyJCQxW2luZGV4KytdID0gY29uc3RhbnRzLkJTT05fREFUQV9OVU1CRVI7IC8vIE51bWJlciBvZiB3cml0dGVuIGJ5dGVzXG5cblx0ICAgICAgdmFyIF9udW1iZXJPZldyaXR0ZW5CeXRlcyA9ICFpc0FycmF5ID8gYnVmZmVyJCQxLndyaXRlKGtleSwgaW5kZXgsICd1dGY4JykgOiBidWZmZXIkJDEud3JpdGUoa2V5LCBpbmRleCwgJ2FzY2lpJyk7IC8vIEVuY29kZSB0aGUgbmFtZVxuXG5cblx0ICAgICAgaW5kZXggPSBpbmRleCArIF9udW1iZXJPZldyaXR0ZW5CeXRlcztcblx0ICAgICAgYnVmZmVyJCQxW2luZGV4KytdID0gMDsgLy8gV3JpdGUgZmxvYXRcblxuXHQgICAgICB3cml0ZUlFRUU3NTQkMShidWZmZXIkJDEsIHZhbHVlLCBpbmRleCwgJ2xpdHRsZScsIDUyLCA4KTsgLy8gQWp1c3QgaW5kZXhcblxuXHQgICAgICBpbmRleCA9IGluZGV4ICsgODtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8vIFNldCBsb25nIHR5cGVcblx0ICAgICAgYnVmZmVyJCQxW2luZGV4KytdID0gY29uc3RhbnRzLkJTT05fREFUQV9MT05HOyAvLyBOdW1iZXIgb2Ygd3JpdHRlbiBieXRlc1xuXG5cdCAgICAgIHZhciBfbnVtYmVyT2ZXcml0dGVuQnl0ZXMyID0gIWlzQXJyYXkgPyBidWZmZXIkJDEud3JpdGUoa2V5LCBpbmRleCwgJ3V0ZjgnKSA6IGJ1ZmZlciQkMS53cml0ZShrZXksIGluZGV4LCAnYXNjaWknKTsgLy8gRW5jb2RlIHRoZSBuYW1lXG5cblxuXHQgICAgICBpbmRleCA9IGluZGV4ICsgX251bWJlck9mV3JpdHRlbkJ5dGVzMjtcblx0ICAgICAgYnVmZmVyJCQxW2luZGV4KytdID0gMDtcblx0ICAgICAgdmFyIGxvbmdWYWwgPSBsb25nXzEuZnJvbU51bWJlcih2YWx1ZSk7XG5cdCAgICAgIHZhciBsb3dCaXRzID0gbG9uZ1ZhbC5nZXRMb3dCaXRzKCk7XG5cdCAgICAgIHZhciBoaWdoQml0cyA9IGxvbmdWYWwuZ2V0SGlnaEJpdHMoKTsgLy8gRW5jb2RlIGxvdyBiaXRzXG5cblx0ICAgICAgYnVmZmVyJCQxW2luZGV4KytdID0gbG93Qml0cyAmIDB4ZmY7XG5cdCAgICAgIGJ1ZmZlciQkMVtpbmRleCsrXSA9IGxvd0JpdHMgPj4gOCAmIDB4ZmY7XG5cdCAgICAgIGJ1ZmZlciQkMVtpbmRleCsrXSA9IGxvd0JpdHMgPj4gMTYgJiAweGZmO1xuXHQgICAgICBidWZmZXIkJDFbaW5kZXgrK10gPSBsb3dCaXRzID4+IDI0ICYgMHhmZjsgLy8gRW5jb2RlIGhpZ2ggYml0c1xuXG5cdCAgICAgIGJ1ZmZlciQkMVtpbmRleCsrXSA9IGhpZ2hCaXRzICYgMHhmZjtcblx0ICAgICAgYnVmZmVyJCQxW2luZGV4KytdID0gaGlnaEJpdHMgPj4gOCAmIDB4ZmY7XG5cdCAgICAgIGJ1ZmZlciQkMVtpbmRleCsrXSA9IGhpZ2hCaXRzID4+IDE2ICYgMHhmZjtcblx0ICAgICAgYnVmZmVyJCQxW2luZGV4KytdID0gaGlnaEJpdHMgPj4gMjQgJiAweGZmO1xuXHQgICAgfVxuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBFbmNvZGUgYXMgZG91YmxlXG5cdCAgICBidWZmZXIkJDFbaW5kZXgrK10gPSBjb25zdGFudHMuQlNPTl9EQVRBX05VTUJFUjsgLy8gTnVtYmVyIG9mIHdyaXR0ZW4gYnl0ZXNcblxuXHQgICAgdmFyIF9udW1iZXJPZldyaXR0ZW5CeXRlczMgPSAhaXNBcnJheSA/IGJ1ZmZlciQkMS53cml0ZShrZXksIGluZGV4LCAndXRmOCcpIDogYnVmZmVyJCQxLndyaXRlKGtleSwgaW5kZXgsICdhc2NpaScpOyAvLyBFbmNvZGUgdGhlIG5hbWVcblxuXG5cdCAgICBpbmRleCA9IGluZGV4ICsgX251bWJlck9mV3JpdHRlbkJ5dGVzMztcblx0ICAgIGJ1ZmZlciQkMVtpbmRleCsrXSA9IDA7IC8vIFdyaXRlIGZsb2F0XG5cblx0ICAgIHdyaXRlSUVFRTc1NCQxKGJ1ZmZlciQkMSwgdmFsdWUsIGluZGV4LCAnbGl0dGxlJywgNTIsIDgpOyAvLyBBanVzdCBpbmRleFxuXG5cdCAgICBpbmRleCA9IGluZGV4ICsgODtcblx0ICB9XG5cblx0ICByZXR1cm4gaW5kZXg7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXJpYWxpemVOdWxsKGJ1ZmZlciQkMSwga2V5LCB2YWx1ZSwgaW5kZXgsIGlzQXJyYXkpIHtcblx0ICAvLyBTZXQgbG9uZyB0eXBlXG5cdCAgYnVmZmVyJCQxW2luZGV4KytdID0gY29uc3RhbnRzLkJTT05fREFUQV9OVUxMOyAvLyBOdW1iZXIgb2Ygd3JpdHRlbiBieXRlc1xuXG5cdCAgdmFyIG51bWJlck9mV3JpdHRlbkJ5dGVzID0gIWlzQXJyYXkgPyBidWZmZXIkJDEud3JpdGUoa2V5LCBpbmRleCwgJ3V0ZjgnKSA6IGJ1ZmZlciQkMS53cml0ZShrZXksIGluZGV4LCAnYXNjaWknKTsgLy8gRW5jb2RlIHRoZSBuYW1lXG5cblx0ICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG5cdCAgYnVmZmVyJCQxW2luZGV4KytdID0gMDtcblx0ICByZXR1cm4gaW5kZXg7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXJpYWxpemVCb29sZWFuKGJ1ZmZlciQkMSwga2V5LCB2YWx1ZSwgaW5kZXgsIGlzQXJyYXkpIHtcblx0ICAvLyBXcml0ZSB0aGUgdHlwZVxuXHQgIGJ1ZmZlciQkMVtpbmRleCsrXSA9IGNvbnN0YW50cy5CU09OX0RBVEFfQk9PTEVBTjsgLy8gTnVtYmVyIG9mIHdyaXR0ZW4gYnl0ZXNcblxuXHQgIHZhciBudW1iZXJPZldyaXR0ZW5CeXRlcyA9ICFpc0FycmF5ID8gYnVmZmVyJCQxLndyaXRlKGtleSwgaW5kZXgsICd1dGY4JykgOiBidWZmZXIkJDEud3JpdGUoa2V5LCBpbmRleCwgJ2FzY2lpJyk7IC8vIEVuY29kZSB0aGUgbmFtZVxuXG5cdCAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuXHQgIGJ1ZmZlciQkMVtpbmRleCsrXSA9IDA7IC8vIEVuY29kZSB0aGUgYm9vbGVhbiB2YWx1ZVxuXG5cdCAgYnVmZmVyJCQxW2luZGV4KytdID0gdmFsdWUgPyAxIDogMDtcblx0ICByZXR1cm4gaW5kZXg7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXJpYWxpemVEYXRlKGJ1ZmZlciQkMSwga2V5LCB2YWx1ZSwgaW5kZXgsIGlzQXJyYXkpIHtcblx0ICAvLyBXcml0ZSB0aGUgdHlwZVxuXHQgIGJ1ZmZlciQkMVtpbmRleCsrXSA9IGNvbnN0YW50cy5CU09OX0RBVEFfREFURTsgLy8gTnVtYmVyIG9mIHdyaXR0ZW4gYnl0ZXNcblxuXHQgIHZhciBudW1iZXJPZldyaXR0ZW5CeXRlcyA9ICFpc0FycmF5ID8gYnVmZmVyJCQxLndyaXRlKGtleSwgaW5kZXgsICd1dGY4JykgOiBidWZmZXIkJDEud3JpdGUoa2V5LCBpbmRleCwgJ2FzY2lpJyk7IC8vIEVuY29kZSB0aGUgbmFtZVxuXG5cdCAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuXHQgIGJ1ZmZlciQkMVtpbmRleCsrXSA9IDA7IC8vIFdyaXRlIHRoZSBkYXRlXG5cblx0ICB2YXIgZGF0ZUluTWlsaXMgPSBsb25nXzEuZnJvbU51bWJlcih2YWx1ZS5nZXRUaW1lKCkpO1xuXHQgIHZhciBsb3dCaXRzID0gZGF0ZUluTWlsaXMuZ2V0TG93Qml0cygpO1xuXHQgIHZhciBoaWdoQml0cyA9IGRhdGVJbk1pbGlzLmdldEhpZ2hCaXRzKCk7IC8vIEVuY29kZSBsb3cgYml0c1xuXG5cdCAgYnVmZmVyJCQxW2luZGV4KytdID0gbG93Qml0cyAmIDB4ZmY7XG5cdCAgYnVmZmVyJCQxW2luZGV4KytdID0gbG93Qml0cyA+PiA4ICYgMHhmZjtcblx0ICBidWZmZXIkJDFbaW5kZXgrK10gPSBsb3dCaXRzID4+IDE2ICYgMHhmZjtcblx0ICBidWZmZXIkJDFbaW5kZXgrK10gPSBsb3dCaXRzID4+IDI0ICYgMHhmZjsgLy8gRW5jb2RlIGhpZ2ggYml0c1xuXG5cdCAgYnVmZmVyJCQxW2luZGV4KytdID0gaGlnaEJpdHMgJiAweGZmO1xuXHQgIGJ1ZmZlciQkMVtpbmRleCsrXSA9IGhpZ2hCaXRzID4+IDggJiAweGZmO1xuXHQgIGJ1ZmZlciQkMVtpbmRleCsrXSA9IGhpZ2hCaXRzID4+IDE2ICYgMHhmZjtcblx0ICBidWZmZXIkJDFbaW5kZXgrK10gPSBoaWdoQml0cyA+PiAyNCAmIDB4ZmY7XG5cdCAgcmV0dXJuIGluZGV4O1xuXHR9XG5cblx0ZnVuY3Rpb24gc2VyaWFsaXplUmVnRXhwKGJ1ZmZlciQkMSwga2V5LCB2YWx1ZSwgaW5kZXgsIGlzQXJyYXkpIHtcblx0ICAvLyBXcml0ZSB0aGUgdHlwZVxuXHQgIGJ1ZmZlciQkMVtpbmRleCsrXSA9IGNvbnN0YW50cy5CU09OX0RBVEFfUkVHRVhQOyAvLyBOdW1iZXIgb2Ygd3JpdHRlbiBieXRlc1xuXG5cdCAgdmFyIG51bWJlck9mV3JpdHRlbkJ5dGVzID0gIWlzQXJyYXkgPyBidWZmZXIkJDEud3JpdGUoa2V5LCBpbmRleCwgJ3V0ZjgnKSA6IGJ1ZmZlciQkMS53cml0ZShrZXksIGluZGV4LCAnYXNjaWknKTsgLy8gRW5jb2RlIHRoZSBuYW1lXG5cblx0ICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG5cdCAgYnVmZmVyJCQxW2luZGV4KytdID0gMDtcblxuXHQgIGlmICh2YWx1ZS5zb3VyY2UgJiYgdmFsdWUuc291cmNlLm1hdGNoKHJlZ2V4cCQxKSAhPSBudWxsKSB7XG5cdCAgICB0aHJvdyBFcnJvcigndmFsdWUgJyArIHZhbHVlLnNvdXJjZSArICcgbXVzdCBub3QgY29udGFpbiBudWxsIGJ5dGVzJyk7XG5cdCAgfSAvLyBBZGp1c3QgdGhlIGluZGV4XG5cblxuXHQgIGluZGV4ID0gaW5kZXggKyBidWZmZXIkJDEud3JpdGUodmFsdWUuc291cmNlLCBpbmRleCwgJ3V0ZjgnKTsgLy8gV3JpdGUgemVyb1xuXG5cdCAgYnVmZmVyJCQxW2luZGV4KytdID0gMHgwMDsgLy8gV3JpdGUgdGhlIHBhcmFtZXRlcnNcblxuXHQgIGlmICh2YWx1ZS5pZ25vcmVDYXNlKSBidWZmZXIkJDFbaW5kZXgrK10gPSAweDY5OyAvLyBpXG5cblx0ICBpZiAodmFsdWUuZ2xvYmFsKSBidWZmZXIkJDFbaW5kZXgrK10gPSAweDczOyAvLyBzXG5cblx0ICBpZiAodmFsdWUubXVsdGlsaW5lKSBidWZmZXIkJDFbaW5kZXgrK10gPSAweDZkOyAvLyBtXG5cdCAgLy8gQWRkIGVuZGluZyB6ZXJvXG5cblx0ICBidWZmZXIkJDFbaW5kZXgrK10gPSAweDAwO1xuXHQgIHJldHVybiBpbmRleDtcblx0fVxuXG5cdGZ1bmN0aW9uIHNlcmlhbGl6ZUJTT05SZWdFeHAoYnVmZmVyJCQxLCBrZXksIHZhbHVlLCBpbmRleCwgaXNBcnJheSkge1xuXHQgIC8vIFdyaXRlIHRoZSB0eXBlXG5cdCAgYnVmZmVyJCQxW2luZGV4KytdID0gY29uc3RhbnRzLkJTT05fREFUQV9SRUdFWFA7IC8vIE51bWJlciBvZiB3cml0dGVuIGJ5dGVzXG5cblx0ICB2YXIgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSAhaXNBcnJheSA/IGJ1ZmZlciQkMS53cml0ZShrZXksIGluZGV4LCAndXRmOCcpIDogYnVmZmVyJCQxLndyaXRlKGtleSwgaW5kZXgsICdhc2NpaScpOyAvLyBFbmNvZGUgdGhlIG5hbWVcblxuXHQgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcblx0ICBidWZmZXIkJDFbaW5kZXgrK10gPSAwOyAvLyBDaGVjayB0aGUgcGF0dGVybiBmb3IgMCBieXRlc1xuXG5cdCAgaWYgKHZhbHVlLnBhdHRlcm4ubWF0Y2gocmVnZXhwJDEpICE9IG51bGwpIHtcblx0ICAgIC8vIFRoZSBCU09OIHNwZWMgZG9lc24ndCBhbGxvdyBrZXlzIHdpdGggbnVsbCBieXRlcyBiZWNhdXNlIGtleXMgYXJlXG5cdCAgICAvLyBudWxsLXRlcm1pbmF0ZWQuXG5cdCAgICB0aHJvdyBFcnJvcigncGF0dGVybiAnICsgdmFsdWUucGF0dGVybiArICcgbXVzdCBub3QgY29udGFpbiBudWxsIGJ5dGVzJyk7XG5cdCAgfSAvLyBBZGp1c3QgdGhlIGluZGV4XG5cblxuXHQgIGluZGV4ID0gaW5kZXggKyBidWZmZXIkJDEud3JpdGUodmFsdWUucGF0dGVybiwgaW5kZXgsICd1dGY4Jyk7IC8vIFdyaXRlIHplcm9cblxuXHQgIGJ1ZmZlciQkMVtpbmRleCsrXSA9IDB4MDA7IC8vIFdyaXRlIHRoZSBvcHRpb25zXG5cblx0ICBpbmRleCA9IGluZGV4ICsgYnVmZmVyJCQxLndyaXRlKHZhbHVlLm9wdGlvbnMuc3BsaXQoJycpLnNvcnQoKS5qb2luKCcnKSwgaW5kZXgsICd1dGY4Jyk7IC8vIEFkZCBlbmRpbmcgemVyb1xuXG5cdCAgYnVmZmVyJCQxW2luZGV4KytdID0gMHgwMDtcblx0ICByZXR1cm4gaW5kZXg7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXJpYWxpemVNaW5NYXgoYnVmZmVyJCQxLCBrZXksIHZhbHVlLCBpbmRleCwgaXNBcnJheSkge1xuXHQgIC8vIFdyaXRlIHRoZSB0eXBlIG9mIGVpdGhlciBtaW4gb3IgbWF4IGtleVxuXHQgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuXHQgICAgYnVmZmVyJCQxW2luZGV4KytdID0gY29uc3RhbnRzLkJTT05fREFUQV9OVUxMO1xuXHQgIH0gZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnTWluS2V5Jykge1xuXHQgICAgYnVmZmVyJCQxW2luZGV4KytdID0gY29uc3RhbnRzLkJTT05fREFUQV9NSU5fS0VZO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBidWZmZXIkJDFbaW5kZXgrK10gPSBjb25zdGFudHMuQlNPTl9EQVRBX01BWF9LRVk7XG5cdCAgfSAvLyBOdW1iZXIgb2Ygd3JpdHRlbiBieXRlc1xuXG5cblx0ICB2YXIgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSAhaXNBcnJheSA/IGJ1ZmZlciQkMS53cml0ZShrZXksIGluZGV4LCAndXRmOCcpIDogYnVmZmVyJCQxLndyaXRlKGtleSwgaW5kZXgsICdhc2NpaScpOyAvLyBFbmNvZGUgdGhlIG5hbWVcblxuXHQgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcblx0ICBidWZmZXIkJDFbaW5kZXgrK10gPSAwO1xuXHQgIHJldHVybiBpbmRleDtcblx0fVxuXG5cdGZ1bmN0aW9uIHNlcmlhbGl6ZU9iamVjdElkKGJ1ZmZlciQkMSwga2V5LCB2YWx1ZSwgaW5kZXgsIGlzQXJyYXkpIHtcblx0ICAvLyBXcml0ZSB0aGUgdHlwZVxuXHQgIGJ1ZmZlciQkMVtpbmRleCsrXSA9IGNvbnN0YW50cy5CU09OX0RBVEFfT0lEOyAvLyBOdW1iZXIgb2Ygd3JpdHRlbiBieXRlc1xuXG5cdCAgdmFyIG51bWJlck9mV3JpdHRlbkJ5dGVzID0gIWlzQXJyYXkgPyBidWZmZXIkJDEud3JpdGUoa2V5LCBpbmRleCwgJ3V0ZjgnKSA6IGJ1ZmZlciQkMS53cml0ZShrZXksIGluZGV4LCAnYXNjaWknKTsgLy8gRW5jb2RlIHRoZSBuYW1lXG5cblx0ICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG5cdCAgYnVmZmVyJCQxW2luZGV4KytdID0gMDsgLy8gV3JpdGUgdGhlIG9iamVjdElkIGludG8gdGhlIHNoYXJlZCBidWZmZXJcblxuXHQgIGlmICh0eXBlb2YgdmFsdWUuaWQgPT09ICdzdHJpbmcnKSB7XG5cdCAgICBidWZmZXIkJDEud3JpdGUodmFsdWUuaWQsIGluZGV4LCAnYmluYXJ5Jyk7XG5cdCAgfSBlbHNlIGlmICh2YWx1ZS5pZCAmJiB2YWx1ZS5pZC5jb3B5KSB7XG5cdCAgICB2YWx1ZS5pZC5jb3B5KGJ1ZmZlciQkMSwgaW5kZXgsIDAsIDEyKTtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb2JqZWN0IFsnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgJ10gaXMgbm90IGEgdmFsaWQgT2JqZWN0SWQnKTtcblx0ICB9IC8vIEFqdXN0IGluZGV4XG5cblxuXHQgIHJldHVybiBpbmRleCArIDEyO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2VyaWFsaXplQnVmZmVyKGJ1ZmZlciQkMSwga2V5LCB2YWx1ZSwgaW5kZXgsIGlzQXJyYXkpIHtcblx0ICAvLyBXcml0ZSB0aGUgdHlwZVxuXHQgIGJ1ZmZlciQkMVtpbmRleCsrXSA9IGNvbnN0YW50cy5CU09OX0RBVEFfQklOQVJZOyAvLyBOdW1iZXIgb2Ygd3JpdHRlbiBieXRlc1xuXG5cdCAgdmFyIG51bWJlck9mV3JpdHRlbkJ5dGVzID0gIWlzQXJyYXkgPyBidWZmZXIkJDEud3JpdGUoa2V5LCBpbmRleCwgJ3V0ZjgnKSA6IGJ1ZmZlciQkMS53cml0ZShrZXksIGluZGV4LCAnYXNjaWknKTsgLy8gRW5jb2RlIHRoZSBuYW1lXG5cblx0ICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG5cdCAgYnVmZmVyJCQxW2luZGV4KytdID0gMDsgLy8gR2V0IHNpemUgb2YgdGhlIGJ1ZmZlciAoY3VycmVudCB3cml0ZSBwb2ludClcblxuXHQgIHZhciBzaXplID0gdmFsdWUubGVuZ3RoOyAvLyBXcml0ZSB0aGUgc2l6ZSBvZiB0aGUgc3RyaW5nIHRvIGJ1ZmZlclxuXG5cdCAgYnVmZmVyJCQxW2luZGV4KytdID0gc2l6ZSAmIDB4ZmY7XG5cdCAgYnVmZmVyJCQxW2luZGV4KytdID0gc2l6ZSA+PiA4ICYgMHhmZjtcblx0ICBidWZmZXIkJDFbaW5kZXgrK10gPSBzaXplID4+IDE2ICYgMHhmZjtcblx0ICBidWZmZXIkJDFbaW5kZXgrK10gPSBzaXplID4+IDI0ICYgMHhmZjsgLy8gV3JpdGUgdGhlIGRlZmF1bHQgc3VidHlwZVxuXG5cdCAgYnVmZmVyJCQxW2luZGV4KytdID0gY29uc3RhbnRzLkJTT05fQklOQVJZX1NVQlRZUEVfREVGQVVMVDsgLy8gQ29weSB0aGUgY29udGVudCBmb3JtIHRoZSBiaW5hcnkgZmllbGQgdG8gdGhlIGJ1ZmZlclxuXG5cdCAgdmFsdWUuY29weShidWZmZXIkJDEsIGluZGV4LCAwLCBzaXplKTsgLy8gQWRqdXN0IHRoZSBpbmRleFxuXG5cdCAgaW5kZXggPSBpbmRleCArIHNpemU7XG5cdCAgcmV0dXJuIGluZGV4O1xuXHR9XG5cblx0ZnVuY3Rpb24gc2VyaWFsaXplT2JqZWN0KGJ1ZmZlciQkMSwga2V5LCB2YWx1ZSwgaW5kZXgsIGNoZWNrS2V5cywgZGVwdGgsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgaWdub3JlVW5kZWZpbmVkLCBpc0FycmF5LCBwYXRoKSB7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBpZiAocGF0aFtpXSA9PT0gdmFsdWUpIHRocm93IG5ldyBFcnJvcignY3ljbGljIGRlcGVuZGVuY3kgZGV0ZWN0ZWQnKTtcblx0ICB9IC8vIFB1c2ggdmFsdWUgdG8gc3RhY2tcblxuXG5cdCAgcGF0aC5wdXNoKHZhbHVlKTsgLy8gV3JpdGUgdGhlIHR5cGVcblxuXHQgIGJ1ZmZlciQkMVtpbmRleCsrXSA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gY29uc3RhbnRzLkJTT05fREFUQV9BUlJBWSA6IGNvbnN0YW50cy5CU09OX0RBVEFfT0JKRUNUOyAvLyBOdW1iZXIgb2Ygd3JpdHRlbiBieXRlc1xuXG5cdCAgdmFyIG51bWJlck9mV3JpdHRlbkJ5dGVzID0gIWlzQXJyYXkgPyBidWZmZXIkJDEud3JpdGUoa2V5LCBpbmRleCwgJ3V0ZjgnKSA6IGJ1ZmZlciQkMS53cml0ZShrZXksIGluZGV4LCAnYXNjaWknKTsgLy8gRW5jb2RlIHRoZSBuYW1lXG5cblx0ICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG5cdCAgYnVmZmVyJCQxW2luZGV4KytdID0gMDtcblx0ICB2YXIgZW5kSW5kZXggPSBzZXJpYWxpemVJbnRvKGJ1ZmZlciQkMSwgdmFsdWUsIGNoZWNrS2V5cywgaW5kZXgsIGRlcHRoICsgMSwgc2VyaWFsaXplRnVuY3Rpb25zLCBpZ25vcmVVbmRlZmluZWQsIHBhdGgpOyAvLyBQb3Agc3RhY2tcblxuXHQgIHBhdGgucG9wKCk7XG5cdCAgcmV0dXJuIGVuZEluZGV4O1xuXHR9XG5cblx0ZnVuY3Rpb24gc2VyaWFsaXplRGVjaW1hbDEyOChidWZmZXIkJDEsIGtleSwgdmFsdWUsIGluZGV4LCBpc0FycmF5KSB7XG5cdCAgYnVmZmVyJCQxW2luZGV4KytdID0gY29uc3RhbnRzLkJTT05fREFUQV9ERUNJTUFMMTI4OyAvLyBOdW1iZXIgb2Ygd3JpdHRlbiBieXRlc1xuXG5cdCAgdmFyIG51bWJlck9mV3JpdHRlbkJ5dGVzID0gIWlzQXJyYXkgPyBidWZmZXIkJDEud3JpdGUoa2V5LCBpbmRleCwgJ3V0ZjgnKSA6IGJ1ZmZlciQkMS53cml0ZShrZXksIGluZGV4LCAnYXNjaWknKTsgLy8gRW5jb2RlIHRoZSBuYW1lXG5cblx0ICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG5cdCAgYnVmZmVyJCQxW2luZGV4KytdID0gMDsgLy8gV3JpdGUgdGhlIGRhdGEgZnJvbSB0aGUgdmFsdWVcblxuXHQgIHZhbHVlLmJ5dGVzLmNvcHkoYnVmZmVyJCQxLCBpbmRleCwgMCwgMTYpO1xuXHQgIHJldHVybiBpbmRleCArIDE2O1xuXHR9XG5cblx0ZnVuY3Rpb24gc2VyaWFsaXplTG9uZyhidWZmZXIkJDEsIGtleSwgdmFsdWUsIGluZGV4LCBpc0FycmF5KSB7XG5cdCAgLy8gV3JpdGUgdGhlIHR5cGVcblx0ICBidWZmZXIkJDFbaW5kZXgrK10gPSB2YWx1ZS5fYnNvbnR5cGUgPT09ICdMb25nJyA/IGNvbnN0YW50cy5CU09OX0RBVEFfTE9ORyA6IGNvbnN0YW50cy5CU09OX0RBVEFfVElNRVNUQU1QOyAvLyBOdW1iZXIgb2Ygd3JpdHRlbiBieXRlc1xuXG5cdCAgdmFyIG51bWJlck9mV3JpdHRlbkJ5dGVzID0gIWlzQXJyYXkgPyBidWZmZXIkJDEud3JpdGUoa2V5LCBpbmRleCwgJ3V0ZjgnKSA6IGJ1ZmZlciQkMS53cml0ZShrZXksIGluZGV4LCAnYXNjaWknKTsgLy8gRW5jb2RlIHRoZSBuYW1lXG5cblx0ICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG5cdCAgYnVmZmVyJCQxW2luZGV4KytdID0gMDsgLy8gV3JpdGUgdGhlIGRhdGVcblxuXHQgIHZhciBsb3dCaXRzID0gdmFsdWUuZ2V0TG93Qml0cygpO1xuXHQgIHZhciBoaWdoQml0cyA9IHZhbHVlLmdldEhpZ2hCaXRzKCk7IC8vIEVuY29kZSBsb3cgYml0c1xuXG5cdCAgYnVmZmVyJCQxW2luZGV4KytdID0gbG93Qml0cyAmIDB4ZmY7XG5cdCAgYnVmZmVyJCQxW2luZGV4KytdID0gbG93Qml0cyA+PiA4ICYgMHhmZjtcblx0ICBidWZmZXIkJDFbaW5kZXgrK10gPSBsb3dCaXRzID4+IDE2ICYgMHhmZjtcblx0ICBidWZmZXIkJDFbaW5kZXgrK10gPSBsb3dCaXRzID4+IDI0ICYgMHhmZjsgLy8gRW5jb2RlIGhpZ2ggYml0c1xuXG5cdCAgYnVmZmVyJCQxW2luZGV4KytdID0gaGlnaEJpdHMgJiAweGZmO1xuXHQgIGJ1ZmZlciQkMVtpbmRleCsrXSA9IGhpZ2hCaXRzID4+IDggJiAweGZmO1xuXHQgIGJ1ZmZlciQkMVtpbmRleCsrXSA9IGhpZ2hCaXRzID4+IDE2ICYgMHhmZjtcblx0ICBidWZmZXIkJDFbaW5kZXgrK10gPSBoaWdoQml0cyA+PiAyNCAmIDB4ZmY7XG5cdCAgcmV0dXJuIGluZGV4O1xuXHR9XG5cblx0ZnVuY3Rpb24gc2VyaWFsaXplSW50MzIoYnVmZmVyJCQxLCBrZXksIHZhbHVlLCBpbmRleCwgaXNBcnJheSkge1xuXHQgIC8vIFNldCBpbnQgdHlwZSAzMiBiaXRzIG9yIGxlc3Ncblx0ICBidWZmZXIkJDFbaW5kZXgrK10gPSBjb25zdGFudHMuQlNPTl9EQVRBX0lOVDsgLy8gTnVtYmVyIG9mIHdyaXR0ZW4gYnl0ZXNcblxuXHQgIHZhciBudW1iZXJPZldyaXR0ZW5CeXRlcyA9ICFpc0FycmF5ID8gYnVmZmVyJCQxLndyaXRlKGtleSwgaW5kZXgsICd1dGY4JykgOiBidWZmZXIkJDEud3JpdGUoa2V5LCBpbmRleCwgJ2FzY2lpJyk7IC8vIEVuY29kZSB0aGUgbmFtZVxuXG5cdCAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuXHQgIGJ1ZmZlciQkMVtpbmRleCsrXSA9IDA7IC8vIFdyaXRlIHRoZSBpbnQgdmFsdWVcblxuXHQgIGJ1ZmZlciQkMVtpbmRleCsrXSA9IHZhbHVlICYgMHhmZjtcblx0ICBidWZmZXIkJDFbaW5kZXgrK10gPSB2YWx1ZSA+PiA4ICYgMHhmZjtcblx0ICBidWZmZXIkJDFbaW5kZXgrK10gPSB2YWx1ZSA+PiAxNiAmIDB4ZmY7XG5cdCAgYnVmZmVyJCQxW2luZGV4KytdID0gdmFsdWUgPj4gMjQgJiAweGZmO1xuXHQgIHJldHVybiBpbmRleDtcblx0fVxuXG5cdGZ1bmN0aW9uIHNlcmlhbGl6ZURvdWJsZShidWZmZXIkJDEsIGtleSwgdmFsdWUsIGluZGV4LCBpc0FycmF5KSB7XG5cdCAgLy8gRW5jb2RlIGFzIGRvdWJsZVxuXHQgIGJ1ZmZlciQkMVtpbmRleCsrXSA9IGNvbnN0YW50cy5CU09OX0RBVEFfTlVNQkVSOyAvLyBOdW1iZXIgb2Ygd3JpdHRlbiBieXRlc1xuXG5cdCAgdmFyIG51bWJlck9mV3JpdHRlbkJ5dGVzID0gIWlzQXJyYXkgPyBidWZmZXIkJDEud3JpdGUoa2V5LCBpbmRleCwgJ3V0ZjgnKSA6IGJ1ZmZlciQkMS53cml0ZShrZXksIGluZGV4LCAnYXNjaWknKTsgLy8gRW5jb2RlIHRoZSBuYW1lXG5cblx0ICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG5cdCAgYnVmZmVyJCQxW2luZGV4KytdID0gMDsgLy8gV3JpdGUgZmxvYXRcblxuXHQgIHdyaXRlSUVFRTc1NCQxKGJ1ZmZlciQkMSwgdmFsdWUudmFsdWUsIGluZGV4LCAnbGl0dGxlJywgNTIsIDgpOyAvLyBBZGp1c3QgaW5kZXhcblxuXHQgIGluZGV4ID0gaW5kZXggKyA4O1xuXHQgIHJldHVybiBpbmRleDtcblx0fVxuXG5cdGZ1bmN0aW9uIHNlcmlhbGl6ZUZ1bmN0aW9uKGJ1ZmZlciQkMSwga2V5LCB2YWx1ZSwgaW5kZXgsIGNoZWNrS2V5cywgZGVwdGgsIGlzQXJyYXkpIHtcblx0ICBidWZmZXIkJDFbaW5kZXgrK10gPSBjb25zdGFudHMuQlNPTl9EQVRBX0NPREU7IC8vIE51bWJlciBvZiB3cml0dGVuIGJ5dGVzXG5cblx0ICB2YXIgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSAhaXNBcnJheSA/IGJ1ZmZlciQkMS53cml0ZShrZXksIGluZGV4LCAndXRmOCcpIDogYnVmZmVyJCQxLndyaXRlKGtleSwgaW5kZXgsICdhc2NpaScpOyAvLyBFbmNvZGUgdGhlIG5hbWVcblxuXHQgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcblx0ICBidWZmZXIkJDFbaW5kZXgrK10gPSAwOyAvLyBGdW5jdGlvbiBzdHJpbmdcblxuXHQgIHZhciBmdW5jdGlvblN0cmluZyA9IG5vcm1hbGl6ZWRGdW5jdGlvblN0cmluZyQxKHZhbHVlKTsgLy8gV3JpdGUgdGhlIHN0cmluZ1xuXG5cdCAgdmFyIHNpemUgPSBidWZmZXIkJDEud3JpdGUoZnVuY3Rpb25TdHJpbmcsIGluZGV4ICsgNCwgJ3V0ZjgnKSArIDE7IC8vIFdyaXRlIHRoZSBzaXplIG9mIHRoZSBzdHJpbmcgdG8gYnVmZmVyXG5cblx0ICBidWZmZXIkJDFbaW5kZXhdID0gc2l6ZSAmIDB4ZmY7XG5cdCAgYnVmZmVyJCQxW2luZGV4ICsgMV0gPSBzaXplID4+IDggJiAweGZmO1xuXHQgIGJ1ZmZlciQkMVtpbmRleCArIDJdID0gc2l6ZSA+PiAxNiAmIDB4ZmY7XG5cdCAgYnVmZmVyJCQxW2luZGV4ICsgM10gPSBzaXplID4+IDI0ICYgMHhmZjsgLy8gVXBkYXRlIGluZGV4XG5cblx0ICBpbmRleCA9IGluZGV4ICsgNCArIHNpemUgLSAxOyAvLyBXcml0ZSB6ZXJvXG5cblx0ICBidWZmZXIkJDFbaW5kZXgrK10gPSAwO1xuXHQgIHJldHVybiBpbmRleDtcblx0fVxuXG5cdGZ1bmN0aW9uIHNlcmlhbGl6ZUNvZGUoYnVmZmVyJCQxLCBrZXksIHZhbHVlLCBpbmRleCwgY2hlY2tLZXlzLCBkZXB0aCwgc2VyaWFsaXplRnVuY3Rpb25zLCBpZ25vcmVVbmRlZmluZWQsIGlzQXJyYXkpIHtcblx0ICBpZiAodmFsdWUuc2NvcGUgJiYgX3R5cGVvZiQzKHZhbHVlLnNjb3BlKSA9PT0gJ29iamVjdCcpIHtcblx0ICAgIC8vIFdyaXRlIHRoZSB0eXBlXG5cdCAgICBidWZmZXIkJDFbaW5kZXgrK10gPSBjb25zdGFudHMuQlNPTl9EQVRBX0NPREVfV19TQ09QRTsgLy8gTnVtYmVyIG9mIHdyaXR0ZW4gYnl0ZXNcblxuXHQgICAgdmFyIG51bWJlck9mV3JpdHRlbkJ5dGVzID0gIWlzQXJyYXkgPyBidWZmZXIkJDEud3JpdGUoa2V5LCBpbmRleCwgJ3V0ZjgnKSA6IGJ1ZmZlciQkMS53cml0ZShrZXksIGluZGV4LCAnYXNjaWknKTsgLy8gRW5jb2RlIHRoZSBuYW1lXG5cblx0ICAgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcblx0ICAgIGJ1ZmZlciQkMVtpbmRleCsrXSA9IDA7IC8vIFN0YXJ0aW5nIGluZGV4XG5cblx0ICAgIHZhciBzdGFydEluZGV4ID0gaW5kZXg7IC8vIFNlcmlhbGl6ZSB0aGUgZnVuY3Rpb25cblx0ICAgIC8vIEdldCB0aGUgZnVuY3Rpb24gc3RyaW5nXG5cblx0ICAgIHZhciBmdW5jdGlvblN0cmluZyA9IHR5cGVvZiB2YWx1ZS5jb2RlID09PSAnc3RyaW5nJyA/IHZhbHVlLmNvZGUgOiB2YWx1ZS5jb2RlLnRvU3RyaW5nKCk7IC8vIEluZGV4IGFkanVzdG1lbnRcblxuXHQgICAgaW5kZXggPSBpbmRleCArIDQ7IC8vIFdyaXRlIHN0cmluZyBpbnRvIGJ1ZmZlclxuXG5cdCAgICB2YXIgY29kZVNpemUgPSBidWZmZXIkJDEud3JpdGUoZnVuY3Rpb25TdHJpbmcsIGluZGV4ICsgNCwgJ3V0ZjgnKSArIDE7IC8vIFdyaXRlIHRoZSBzaXplIG9mIHRoZSBzdHJpbmcgdG8gYnVmZmVyXG5cblx0ICAgIGJ1ZmZlciQkMVtpbmRleF0gPSBjb2RlU2l6ZSAmIDB4ZmY7XG5cdCAgICBidWZmZXIkJDFbaW5kZXggKyAxXSA9IGNvZGVTaXplID4+IDggJiAweGZmO1xuXHQgICAgYnVmZmVyJCQxW2luZGV4ICsgMl0gPSBjb2RlU2l6ZSA+PiAxNiAmIDB4ZmY7XG5cdCAgICBidWZmZXIkJDFbaW5kZXggKyAzXSA9IGNvZGVTaXplID4+IDI0ICYgMHhmZjsgLy8gV3JpdGUgZW5kIDBcblxuXHQgICAgYnVmZmVyJCQxW2luZGV4ICsgNCArIGNvZGVTaXplIC0gMV0gPSAwOyAvLyBXcml0ZSB0aGVcblxuXHQgICAgaW5kZXggPSBpbmRleCArIGNvZGVTaXplICsgNDsgLy9cblx0ICAgIC8vIFNlcmlhbGl6ZSB0aGUgc2NvcGUgdmFsdWVcblxuXHQgICAgdmFyIGVuZEluZGV4ID0gc2VyaWFsaXplSW50byhidWZmZXIkJDEsIHZhbHVlLnNjb3BlLCBjaGVja0tleXMsIGluZGV4LCBkZXB0aCArIDEsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgaWdub3JlVW5kZWZpbmVkKTtcblx0ICAgIGluZGV4ID0gZW5kSW5kZXggLSAxOyAvLyBXcml0IHRoZSB0b3RhbFxuXG5cdCAgICB2YXIgdG90YWxTaXplID0gZW5kSW5kZXggLSBzdGFydEluZGV4OyAvLyBXcml0ZSB0aGUgdG90YWwgc2l6ZSBvZiB0aGUgb2JqZWN0XG5cblx0ICAgIGJ1ZmZlciQkMVtzdGFydEluZGV4KytdID0gdG90YWxTaXplICYgMHhmZjtcblx0ICAgIGJ1ZmZlciQkMVtzdGFydEluZGV4KytdID0gdG90YWxTaXplID4+IDggJiAweGZmO1xuXHQgICAgYnVmZmVyJCQxW3N0YXJ0SW5kZXgrK10gPSB0b3RhbFNpemUgPj4gMTYgJiAweGZmO1xuXHQgICAgYnVmZmVyJCQxW3N0YXJ0SW5kZXgrK10gPSB0b3RhbFNpemUgPj4gMjQgJiAweGZmOyAvLyBXcml0ZSB0cmFpbGluZyB6ZXJvXG5cblx0ICAgIGJ1ZmZlciQkMVtpbmRleCsrXSA9IDA7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGJ1ZmZlciQkMVtpbmRleCsrXSA9IGNvbnN0YW50cy5CU09OX0RBVEFfQ09ERTsgLy8gTnVtYmVyIG9mIHdyaXR0ZW4gYnl0ZXNcblxuXHQgICAgdmFyIF9udW1iZXJPZldyaXR0ZW5CeXRlczQgPSAhaXNBcnJheSA/IGJ1ZmZlciQkMS53cml0ZShrZXksIGluZGV4LCAndXRmOCcpIDogYnVmZmVyJCQxLndyaXRlKGtleSwgaW5kZXgsICdhc2NpaScpOyAvLyBFbmNvZGUgdGhlIG5hbWVcblxuXG5cdCAgICBpbmRleCA9IGluZGV4ICsgX251bWJlck9mV3JpdHRlbkJ5dGVzNDtcblx0ICAgIGJ1ZmZlciQkMVtpbmRleCsrXSA9IDA7IC8vIEZ1bmN0aW9uIHN0cmluZ1xuXG5cdCAgICB2YXIgX2Z1bmN0aW9uU3RyaW5nID0gdmFsdWUuY29kZS50b1N0cmluZygpOyAvLyBXcml0ZSB0aGUgc3RyaW5nXG5cblxuXHQgICAgdmFyIHNpemUgPSBidWZmZXIkJDEud3JpdGUoX2Z1bmN0aW9uU3RyaW5nLCBpbmRleCArIDQsICd1dGY4JykgKyAxOyAvLyBXcml0ZSB0aGUgc2l6ZSBvZiB0aGUgc3RyaW5nIHRvIGJ1ZmZlclxuXG5cdCAgICBidWZmZXIkJDFbaW5kZXhdID0gc2l6ZSAmIDB4ZmY7XG5cdCAgICBidWZmZXIkJDFbaW5kZXggKyAxXSA9IHNpemUgPj4gOCAmIDB4ZmY7XG5cdCAgICBidWZmZXIkJDFbaW5kZXggKyAyXSA9IHNpemUgPj4gMTYgJiAweGZmO1xuXHQgICAgYnVmZmVyJCQxW2luZGV4ICsgM10gPSBzaXplID4+IDI0ICYgMHhmZjsgLy8gVXBkYXRlIGluZGV4XG5cblx0ICAgIGluZGV4ID0gaW5kZXggKyA0ICsgc2l6ZSAtIDE7IC8vIFdyaXRlIHplcm9cblxuXHQgICAgYnVmZmVyJCQxW2luZGV4KytdID0gMDtcblx0ICB9XG5cblx0ICByZXR1cm4gaW5kZXg7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXJpYWxpemVCaW5hcnkoYnVmZmVyJCQxLCBrZXksIHZhbHVlLCBpbmRleCwgaXNBcnJheSkge1xuXHQgIC8vIFdyaXRlIHRoZSB0eXBlXG5cdCAgYnVmZmVyJCQxW2luZGV4KytdID0gY29uc3RhbnRzLkJTT05fREFUQV9CSU5BUlk7IC8vIE51bWJlciBvZiB3cml0dGVuIGJ5dGVzXG5cblx0ICB2YXIgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSAhaXNBcnJheSA/IGJ1ZmZlciQkMS53cml0ZShrZXksIGluZGV4LCAndXRmOCcpIDogYnVmZmVyJCQxLndyaXRlKGtleSwgaW5kZXgsICdhc2NpaScpOyAvLyBFbmNvZGUgdGhlIG5hbWVcblxuXHQgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcblx0ICBidWZmZXIkJDFbaW5kZXgrK10gPSAwOyAvLyBFeHRyYWN0IHRoZSBidWZmZXJcblxuXHQgIHZhciBkYXRhID0gdmFsdWUudmFsdWUodHJ1ZSk7IC8vIENhbGN1bGF0ZSBzaXplXG5cblx0ICB2YXIgc2l6ZSA9IHZhbHVlLnBvc2l0aW9uOyAvLyBBZGQgdGhlIGRlcHJlY2F0ZWQgMDIgdHlwZSA0IGJ5dGVzIG9mIHNpemUgdG8gdG90YWxcblxuXHQgIGlmICh2YWx1ZS5zdWJfdHlwZSA9PT0gYmluYXJ5LlNVQlRZUEVfQllURV9BUlJBWSkgc2l6ZSA9IHNpemUgKyA0OyAvLyBXcml0ZSB0aGUgc2l6ZSBvZiB0aGUgc3RyaW5nIHRvIGJ1ZmZlclxuXG5cdCAgYnVmZmVyJCQxW2luZGV4KytdID0gc2l6ZSAmIDB4ZmY7XG5cdCAgYnVmZmVyJCQxW2luZGV4KytdID0gc2l6ZSA+PiA4ICYgMHhmZjtcblx0ICBidWZmZXIkJDFbaW5kZXgrK10gPSBzaXplID4+IDE2ICYgMHhmZjtcblx0ICBidWZmZXIkJDFbaW5kZXgrK10gPSBzaXplID4+IDI0ICYgMHhmZjsgLy8gV3JpdGUgdGhlIHN1YnR5cGUgdG8gdGhlIGJ1ZmZlclxuXG5cdCAgYnVmZmVyJCQxW2luZGV4KytdID0gdmFsdWUuc3ViX3R5cGU7IC8vIElmIHdlIGhhdmUgYmluYXJ5IHR5cGUgMiB0aGUgNCBmaXJzdCBieXRlcyBhcmUgdGhlIHNpemVcblxuXHQgIGlmICh2YWx1ZS5zdWJfdHlwZSA9PT0gYmluYXJ5LlNVQlRZUEVfQllURV9BUlJBWSkge1xuXHQgICAgc2l6ZSA9IHNpemUgLSA0O1xuXHQgICAgYnVmZmVyJCQxW2luZGV4KytdID0gc2l6ZSAmIDB4ZmY7XG5cdCAgICBidWZmZXIkJDFbaW5kZXgrK10gPSBzaXplID4+IDggJiAweGZmO1xuXHQgICAgYnVmZmVyJCQxW2luZGV4KytdID0gc2l6ZSA+PiAxNiAmIDB4ZmY7XG5cdCAgICBidWZmZXIkJDFbaW5kZXgrK10gPSBzaXplID4+IDI0ICYgMHhmZjtcblx0ICB9IC8vIFdyaXRlIHRoZSBkYXRhIHRvIHRoZSBvYmplY3RcblxuXG5cdCAgZGF0YS5jb3B5KGJ1ZmZlciQkMSwgaW5kZXgsIDAsIHZhbHVlLnBvc2l0aW9uKTsgLy8gQWRqdXN0IHRoZSBpbmRleFxuXG5cdCAgaW5kZXggPSBpbmRleCArIHZhbHVlLnBvc2l0aW9uO1xuXHQgIHJldHVybiBpbmRleDtcblx0fVxuXG5cdGZ1bmN0aW9uIHNlcmlhbGl6ZVN5bWJvbChidWZmZXIkJDEsIGtleSwgdmFsdWUsIGluZGV4LCBpc0FycmF5KSB7XG5cdCAgLy8gV3JpdGUgdGhlIHR5cGVcblx0ICBidWZmZXIkJDFbaW5kZXgrK10gPSBjb25zdGFudHMuQlNPTl9EQVRBX1NZTUJPTDsgLy8gTnVtYmVyIG9mIHdyaXR0ZW4gYnl0ZXNcblxuXHQgIHZhciBudW1iZXJPZldyaXR0ZW5CeXRlcyA9ICFpc0FycmF5ID8gYnVmZmVyJCQxLndyaXRlKGtleSwgaW5kZXgsICd1dGY4JykgOiBidWZmZXIkJDEud3JpdGUoa2V5LCBpbmRleCwgJ2FzY2lpJyk7IC8vIEVuY29kZSB0aGUgbmFtZVxuXG5cdCAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuXHQgIGJ1ZmZlciQkMVtpbmRleCsrXSA9IDA7IC8vIFdyaXRlIHRoZSBzdHJpbmdcblxuXHQgIHZhciBzaXplID0gYnVmZmVyJCQxLndyaXRlKHZhbHVlLnZhbHVlLCBpbmRleCArIDQsICd1dGY4JykgKyAxOyAvLyBXcml0ZSB0aGUgc2l6ZSBvZiB0aGUgc3RyaW5nIHRvIGJ1ZmZlclxuXG5cdCAgYnVmZmVyJCQxW2luZGV4XSA9IHNpemUgJiAweGZmO1xuXHQgIGJ1ZmZlciQkMVtpbmRleCArIDFdID0gc2l6ZSA+PiA4ICYgMHhmZjtcblx0ICBidWZmZXIkJDFbaW5kZXggKyAyXSA9IHNpemUgPj4gMTYgJiAweGZmO1xuXHQgIGJ1ZmZlciQkMVtpbmRleCArIDNdID0gc2l6ZSA+PiAyNCAmIDB4ZmY7IC8vIFVwZGF0ZSBpbmRleFxuXG5cdCAgaW5kZXggPSBpbmRleCArIDQgKyBzaXplIC0gMTsgLy8gV3JpdGUgemVyb1xuXG5cdCAgYnVmZmVyJCQxW2luZGV4KytdID0gMHgwMDtcblx0ICByZXR1cm4gaW5kZXg7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXJpYWxpemVEQlJlZihidWZmZXIkJDEsIGtleSwgdmFsdWUsIGluZGV4LCBkZXB0aCwgc2VyaWFsaXplRnVuY3Rpb25zLCBpc0FycmF5KSB7XG5cdCAgLy8gV3JpdGUgdGhlIHR5cGVcblx0ICBidWZmZXIkJDFbaW5kZXgrK10gPSBjb25zdGFudHMuQlNPTl9EQVRBX09CSkVDVDsgLy8gTnVtYmVyIG9mIHdyaXR0ZW4gYnl0ZXNcblxuXHQgIHZhciBudW1iZXJPZldyaXR0ZW5CeXRlcyA9ICFpc0FycmF5ID8gYnVmZmVyJCQxLndyaXRlKGtleSwgaW5kZXgsICd1dGY4JykgOiBidWZmZXIkJDEud3JpdGUoa2V5LCBpbmRleCwgJ2FzY2lpJyk7IC8vIEVuY29kZSB0aGUgbmFtZVxuXG5cdCAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuXHQgIGJ1ZmZlciQkMVtpbmRleCsrXSA9IDA7XG5cdCAgdmFyIHN0YXJ0SW5kZXggPSBpbmRleDtcblx0ICB2YXIgZW5kSW5kZXg7XG5cdCAgdmFyIG91dHB1dCA9IHtcblx0ICAgICRyZWY6IHZhbHVlLmNvbGxlY3Rpb24gfHwgdmFsdWUubmFtZXNwYWNlLFxuXHQgICAgLy8gXCJuYW1lc3BhY2VcIiB3YXMgd2hhdCBsaWJyYXJ5IDEueCBjYWxsZWQgXCJjb2xsZWN0aW9uXCJcblx0ICAgICRpZDogdmFsdWUub2lkXG5cdCAgfTtcblx0ICBpZiAodmFsdWUuZGIgIT0gbnVsbCkgb3V0cHV0LiRkYiA9IHZhbHVlLmRiO1xuXHQgIG91dHB1dCA9IE9iamVjdC5hc3NpZ24ob3V0cHV0LCB2YWx1ZS5maWVsZHMpO1xuXHQgIGVuZEluZGV4ID0gc2VyaWFsaXplSW50byhidWZmZXIkJDEsIG91dHB1dCwgZmFsc2UsIGluZGV4LCBkZXB0aCArIDEsIHNlcmlhbGl6ZUZ1bmN0aW9ucyk7IC8vIENhbGN1bGF0ZSBvYmplY3Qgc2l6ZVxuXG5cdCAgdmFyIHNpemUgPSBlbmRJbmRleCAtIHN0YXJ0SW5kZXg7IC8vIFdyaXRlIHRoZSBzaXplXG5cblx0ICBidWZmZXIkJDFbc3RhcnRJbmRleCsrXSA9IHNpemUgJiAweGZmO1xuXHQgIGJ1ZmZlciQkMVtzdGFydEluZGV4KytdID0gc2l6ZSA+PiA4ICYgMHhmZjtcblx0ICBidWZmZXIkJDFbc3RhcnRJbmRleCsrXSA9IHNpemUgPj4gMTYgJiAweGZmO1xuXHQgIGJ1ZmZlciQkMVtzdGFydEluZGV4KytdID0gc2l6ZSA+PiAyNCAmIDB4ZmY7IC8vIFNldCBpbmRleFxuXG5cdCAgcmV0dXJuIGVuZEluZGV4O1xuXHR9XG5cblx0ZnVuY3Rpb24gc2VyaWFsaXplSW50byhidWZmZXIkJDEsIG9iamVjdCwgY2hlY2tLZXlzLCBzdGFydGluZ0luZGV4LCBkZXB0aCwgc2VyaWFsaXplRnVuY3Rpb25zLCBpZ25vcmVVbmRlZmluZWQsIHBhdGgpIHtcblx0ICBzdGFydGluZ0luZGV4ID0gc3RhcnRpbmdJbmRleCB8fCAwO1xuXHQgIHBhdGggPSBwYXRoIHx8IFtdOyAvLyBQdXNoIHRoZSBvYmplY3QgdG8gdGhlIHBhdGhcblxuXHQgIHBhdGgucHVzaChvYmplY3QpOyAvLyBTdGFydCBwbGFjZSB0byBzZXJpYWxpemUgaW50b1xuXG5cdCAgdmFyIGluZGV4ID0gc3RhcnRpbmdJbmRleCArIDQ7IC8vIFNwZWNpYWwgY2FzZSBpc0FycmF5XG5cblx0ICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG5cdCAgICAvLyBHZXQgb2JqZWN0IGtleXNcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBrZXkgPSAnJyArIGk7XG5cdCAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtpXTsgLy8gSXMgdGhlcmUgYW4gb3ZlcnJpZGUgdmFsdWVcblxuXHQgICAgICBpZiAodmFsdWUgJiYgdmFsdWUudG9CU09OKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZS50b0JTT04gIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RvQlNPTiBpcyBub3QgYSBmdW5jdGlvbicpO1xuXHQgICAgICAgIHZhbHVlID0gdmFsdWUudG9CU09OKCk7XG5cdCAgICAgIH1cblxuXHQgICAgICB2YXIgdHlwZSA9IF90eXBlb2YkMyh2YWx1ZSk7XG5cblx0ICAgICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgaW5kZXggPSBzZXJpYWxpemVTdHJpbmcoYnVmZmVyJCQxLCBrZXksIHZhbHVlLCBpbmRleCwgdHJ1ZSk7XG5cdCAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcblx0ICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZU51bWJlcihidWZmZXIkJDEsIGtleSwgdmFsdWUsIGluZGV4LCB0cnVlKTtcblx0ICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnYm9vbGVhbicpIHtcblx0ICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUJvb2xlYW4oYnVmZmVyJCQxLCBrZXksIHZhbHVlLCBpbmRleCwgdHJ1ZSk7XG5cdCAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlIHx8IGlzRGF0ZSQxKHZhbHVlKSkge1xuXHQgICAgICAgIGluZGV4ID0gc2VyaWFsaXplRGF0ZShidWZmZXIkJDEsIGtleSwgdmFsdWUsIGluZGV4LCB0cnVlKTtcblx0ICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgaW5kZXggPSBzZXJpYWxpemVOdWxsKGJ1ZmZlciQkMSwga2V5LCB2YWx1ZSwgaW5kZXgsIHRydWUpO1xuXHQgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBudWxsKSB7XG5cdCAgICAgICAgaW5kZXggPSBzZXJpYWxpemVOdWxsKGJ1ZmZlciQkMSwga2V5LCB2YWx1ZSwgaW5kZXgsIHRydWUpO1xuXHQgICAgICB9IGVsc2UgaWYgKHZhbHVlWydfYnNvbnR5cGUnXSA9PT0gJ09iamVjdElkJyB8fCB2YWx1ZVsnX2Jzb250eXBlJ10gPT09ICdPYmplY3RJRCcpIHtcblx0ICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZU9iamVjdElkKGJ1ZmZlciQkMSwga2V5LCB2YWx1ZSwgaW5kZXgsIHRydWUpO1xuXHQgICAgICB9IGVsc2UgaWYgKEJ1ZmZlciQ1LmlzQnVmZmVyKHZhbHVlKSkge1xuXHQgICAgICAgIGluZGV4ID0gc2VyaWFsaXplQnVmZmVyKGJ1ZmZlciQkMSwga2V5LCB2YWx1ZSwgaW5kZXgsIHRydWUpO1xuXHQgICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwIHx8IGlzUmVnRXhwJDEodmFsdWUpKSB7XG5cdCAgICAgICAgaW5kZXggPSBzZXJpYWxpemVSZWdFeHAoYnVmZmVyJCQxLCBrZXksIHZhbHVlLCBpbmRleCwgdHJ1ZSk7XG5cdCAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcgJiYgdmFsdWVbJ19ic29udHlwZSddID09IG51bGwpIHtcblx0ICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZU9iamVjdChidWZmZXIkJDEsIGtleSwgdmFsdWUsIGluZGV4LCBjaGVja0tleXMsIGRlcHRoLCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCwgdHJ1ZSwgcGF0aCk7XG5cdCAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcgJiYgdmFsdWVbJ19ic29udHlwZSddID09PSAnRGVjaW1hbDEyOCcpIHtcblx0ICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZURlY2ltYWwxMjgoYnVmZmVyJCQxLCBrZXksIHZhbHVlLCBpbmRleCwgdHJ1ZSk7XG5cdCAgICAgIH0gZWxzZSBpZiAodmFsdWVbJ19ic29udHlwZSddID09PSAnTG9uZycgfHwgdmFsdWVbJ19ic29udHlwZSddID09PSAnVGltZXN0YW1wJykge1xuXHQgICAgICAgIGluZGV4ID0gc2VyaWFsaXplTG9uZyhidWZmZXIkJDEsIGtleSwgdmFsdWUsIGluZGV4LCB0cnVlKTtcblx0ICAgICAgfSBlbHNlIGlmICh2YWx1ZVsnX2Jzb250eXBlJ10gPT09ICdEb3VibGUnKSB7XG5cdCAgICAgICAgaW5kZXggPSBzZXJpYWxpemVEb3VibGUoYnVmZmVyJCQxLCBrZXksIHZhbHVlLCBpbmRleCwgdHJ1ZSk7XG5cdCAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmIHNlcmlhbGl6ZUZ1bmN0aW9ucykge1xuXHQgICAgICAgIGluZGV4ID0gc2VyaWFsaXplRnVuY3Rpb24oYnVmZmVyJCQxLCBrZXksIHZhbHVlLCBpbmRleCwgY2hlY2tLZXlzLCBkZXB0aCwgc2VyaWFsaXplRnVuY3Rpb25zLCB0cnVlKTtcblx0ICAgICAgfSBlbHNlIGlmICh2YWx1ZVsnX2Jzb250eXBlJ10gPT09ICdDb2RlJykge1xuXHQgICAgICAgIGluZGV4ID0gc2VyaWFsaXplQ29kZShidWZmZXIkJDEsIGtleSwgdmFsdWUsIGluZGV4LCBjaGVja0tleXMsIGRlcHRoLCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCwgdHJ1ZSk7XG5cdCAgICAgIH0gZWxzZSBpZiAodmFsdWVbJ19ic29udHlwZSddID09PSAnQmluYXJ5Jykge1xuXHQgICAgICAgIGluZGV4ID0gc2VyaWFsaXplQmluYXJ5KGJ1ZmZlciQkMSwga2V5LCB2YWx1ZSwgaW5kZXgsIHRydWUpO1xuXHQgICAgICB9IGVsc2UgaWYgKHZhbHVlWydfYnNvbnR5cGUnXSA9PT0gJ1N5bWJvbCcpIHtcblx0ICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZVN5bWJvbChidWZmZXIkJDEsIGtleSwgdmFsdWUsIGluZGV4LCB0cnVlKTtcblx0ICAgICAgfSBlbHNlIGlmICh2YWx1ZVsnX2Jzb250eXBlJ10gPT09ICdEQlJlZicpIHtcblx0ICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZURCUmVmKGJ1ZmZlciQkMSwga2V5LCB2YWx1ZSwgaW5kZXgsIGRlcHRoLCBzZXJpYWxpemVGdW5jdGlvbnMsIHRydWUpO1xuXHQgICAgICB9IGVsc2UgaWYgKHZhbHVlWydfYnNvbnR5cGUnXSA9PT0gJ0JTT05SZWdFeHAnKSB7XG5cdCAgICAgICAgaW5kZXggPSBzZXJpYWxpemVCU09OUmVnRXhwKGJ1ZmZlciQkMSwga2V5LCB2YWx1ZSwgaW5kZXgsIHRydWUpO1xuXHQgICAgICB9IGVsc2UgaWYgKHZhbHVlWydfYnNvbnR5cGUnXSA9PT0gJ0ludDMyJykge1xuXHQgICAgICAgIGluZGV4ID0gc2VyaWFsaXplSW50MzIoYnVmZmVyJCQxLCBrZXksIHZhbHVlLCBpbmRleCwgdHJ1ZSk7XG5cdCAgICAgIH0gZWxzZSBpZiAodmFsdWVbJ19ic29udHlwZSddID09PSAnTWluS2V5JyB8fCB2YWx1ZVsnX2Jzb250eXBlJ10gPT09ICdNYXhLZXknKSB7XG5cdCAgICAgICAgaW5kZXggPSBzZXJpYWxpemVNaW5NYXgoYnVmZmVyJCQxLCBrZXksIHZhbHVlLCBpbmRleCwgdHJ1ZSk7XG5cdCAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlWydfYnNvbnR5cGUnXSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbnJlY29nbml6ZWQgb3IgaW52YWxpZCBfYnNvbnR5cGU6ICcgKyB2YWx1ZVsnX2Jzb250eXBlJ10pO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSBlbHNlIGlmIChvYmplY3QgaW5zdGFuY2VvZiBtYXApIHtcblx0ICAgIHZhciBpdGVyYXRvciA9IG9iamVjdC5lbnRyaWVzKCk7XG5cdCAgICB2YXIgZG9uZSA9IGZhbHNlO1xuXG5cdCAgICB3aGlsZSAoIWRvbmUpIHtcblx0ICAgICAgLy8gVW5wYWNrIHRoZSBuZXh0IGVudHJ5XG5cdCAgICAgIHZhciBlbnRyeSA9IGl0ZXJhdG9yLm5leHQoKTtcblx0ICAgICAgZG9uZSA9IGVudHJ5LmRvbmU7IC8vIEFyZSB3ZSBkb25lLCB0aGVuIHNraXAgYW5kIHRlcm1pbmF0ZVxuXG5cdCAgICAgIGlmIChkb25lKSBjb250aW51ZTsgLy8gR2V0IHRoZSBlbnRyeSB2YWx1ZXNcblxuXHQgICAgICB2YXIgX2tleSA9IGVudHJ5LnZhbHVlWzBdO1xuXHQgICAgICB2YXIgX3ZhbHVlID0gZW50cnkudmFsdWVbMV07IC8vIENoZWNrIHRoZSB0eXBlIG9mIHRoZSB2YWx1ZVxuXG5cdCAgICAgIHZhciBfdHlwZSA9IF90eXBlb2YkMyhfdmFsdWUpOyAvLyBDaGVjayB0aGUga2V5IGFuZCB0aHJvdyBlcnJvciBpZiBpdCdzIGlsbGVnYWxcblxuXG5cdCAgICAgIGlmICh0eXBlb2YgX2tleSA9PT0gJ3N0cmluZycgJiYgIWlnbm9yZUtleXMuaGFzKF9rZXkpKSB7XG5cdCAgICAgICAgaWYgKF9rZXkubWF0Y2gocmVnZXhwJDEpICE9IG51bGwpIHtcblx0ICAgICAgICAgIC8vIFRoZSBCU09OIHNwZWMgZG9lc24ndCBhbGxvdyBrZXlzIHdpdGggbnVsbCBieXRlcyBiZWNhdXNlIGtleXMgYXJlXG5cdCAgICAgICAgICAvLyBudWxsLXRlcm1pbmF0ZWQuXG5cdCAgICAgICAgICB0aHJvdyBFcnJvcigna2V5ICcgKyBfa2V5ICsgJyBtdXN0IG5vdCBjb250YWluIG51bGwgYnl0ZXMnKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoY2hlY2tLZXlzKSB7XG5cdCAgICAgICAgICBpZiAoJyQnID09PSBfa2V5WzBdKSB7XG5cdCAgICAgICAgICAgIHRocm93IEVycm9yKCdrZXkgJyArIF9rZXkgKyBcIiBtdXN0IG5vdCBzdGFydCB3aXRoICckJ1wiKTtcblx0ICAgICAgICAgIH0gZWxzZSBpZiAofl9rZXkuaW5kZXhPZignLicpKSB7XG5cdCAgICAgICAgICAgIHRocm93IEVycm9yKCdrZXkgJyArIF9rZXkgKyBcIiBtdXN0IG5vdCBjb250YWluICcuJ1wiKTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoX3R5cGUgPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgaW5kZXggPSBzZXJpYWxpemVTdHJpbmcoYnVmZmVyJCQxLCBfa2V5LCBfdmFsdWUsIGluZGV4KTtcblx0ICAgICAgfSBlbHNlIGlmIChfdHlwZSA9PT0gJ251bWJlcicpIHtcblx0ICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZU51bWJlcihidWZmZXIkJDEsIF9rZXksIF92YWx1ZSwgaW5kZXgpO1xuXHQgICAgICB9IGVsc2UgaWYgKF90eXBlID09PSAnYm9vbGVhbicpIHtcblx0ICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUJvb2xlYW4oYnVmZmVyJCQxLCBfa2V5LCBfdmFsdWUsIGluZGV4KTtcblx0ICAgICAgfSBlbHNlIGlmIChfdmFsdWUgaW5zdGFuY2VvZiBEYXRlIHx8IGlzRGF0ZSQxKF92YWx1ZSkpIHtcblx0ICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZURhdGUoYnVmZmVyJCQxLCBfa2V5LCBfdmFsdWUsIGluZGV4KTtcblx0ICAgICAgfSBlbHNlIGlmIChfdmFsdWUgPT09IG51bGwgfHwgX3ZhbHVlID09PSB1bmRlZmluZWQgJiYgaWdub3JlVW5kZWZpbmVkID09PSBmYWxzZSkge1xuXHQgICAgICAgIGluZGV4ID0gc2VyaWFsaXplTnVsbChidWZmZXIkJDEsIF9rZXksIF92YWx1ZSwgaW5kZXgpO1xuXHQgICAgICB9IGVsc2UgaWYgKF92YWx1ZVsnX2Jzb250eXBlJ10gPT09ICdPYmplY3RJZCcgfHwgX3ZhbHVlWydfYnNvbnR5cGUnXSA9PT0gJ09iamVjdElEJykge1xuXHQgICAgICAgIGluZGV4ID0gc2VyaWFsaXplT2JqZWN0SWQoYnVmZmVyJCQxLCBfa2V5LCBfdmFsdWUsIGluZGV4KTtcblx0ICAgICAgfSBlbHNlIGlmIChCdWZmZXIkNS5pc0J1ZmZlcihfdmFsdWUpKSB7XG5cdCAgICAgICAgaW5kZXggPSBzZXJpYWxpemVCdWZmZXIoYnVmZmVyJCQxLCBfa2V5LCBfdmFsdWUsIGluZGV4KTtcblx0ICAgICAgfSBlbHNlIGlmIChfdmFsdWUgaW5zdGFuY2VvZiBSZWdFeHAgfHwgaXNSZWdFeHAkMShfdmFsdWUpKSB7XG5cdCAgICAgICAgaW5kZXggPSBzZXJpYWxpemVSZWdFeHAoYnVmZmVyJCQxLCBfa2V5LCBfdmFsdWUsIGluZGV4KTtcblx0ICAgICAgfSBlbHNlIGlmIChfdHlwZSA9PT0gJ29iamVjdCcgJiYgX3ZhbHVlWydfYnNvbnR5cGUnXSA9PSBudWxsKSB7XG5cdCAgICAgICAgaW5kZXggPSBzZXJpYWxpemVPYmplY3QoYnVmZmVyJCQxLCBfa2V5LCBfdmFsdWUsIGluZGV4LCBjaGVja0tleXMsIGRlcHRoLCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCwgZmFsc2UsIHBhdGgpO1xuXHQgICAgICB9IGVsc2UgaWYgKF90eXBlID09PSAnb2JqZWN0JyAmJiBfdmFsdWVbJ19ic29udHlwZSddID09PSAnRGVjaW1hbDEyOCcpIHtcblx0ICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZURlY2ltYWwxMjgoYnVmZmVyJCQxLCBfa2V5LCBfdmFsdWUsIGluZGV4KTtcblx0ICAgICAgfSBlbHNlIGlmIChfdmFsdWVbJ19ic29udHlwZSddID09PSAnTG9uZycgfHwgX3ZhbHVlWydfYnNvbnR5cGUnXSA9PT0gJ1RpbWVzdGFtcCcpIHtcblx0ICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUxvbmcoYnVmZmVyJCQxLCBfa2V5LCBfdmFsdWUsIGluZGV4KTtcblx0ICAgICAgfSBlbHNlIGlmIChfdmFsdWVbJ19ic29udHlwZSddID09PSAnRG91YmxlJykge1xuXHQgICAgICAgIGluZGV4ID0gc2VyaWFsaXplRG91YmxlKGJ1ZmZlciQkMSwgX2tleSwgX3ZhbHVlLCBpbmRleCk7XG5cdCAgICAgIH0gZWxzZSBpZiAoX3ZhbHVlWydfYnNvbnR5cGUnXSA9PT0gJ0NvZGUnKSB7XG5cdCAgICAgICAgaW5kZXggPSBzZXJpYWxpemVDb2RlKGJ1ZmZlciQkMSwgX2tleSwgX3ZhbHVlLCBpbmRleCwgY2hlY2tLZXlzLCBkZXB0aCwgc2VyaWFsaXplRnVuY3Rpb25zLCBpZ25vcmVVbmRlZmluZWQpO1xuXHQgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBfdmFsdWUgPT09ICdmdW5jdGlvbicgJiYgc2VyaWFsaXplRnVuY3Rpb25zKSB7XG5cdCAgICAgICAgaW5kZXggPSBzZXJpYWxpemVGdW5jdGlvbihidWZmZXIkJDEsIF9rZXksIF92YWx1ZSwgaW5kZXgsIGNoZWNrS2V5cywgZGVwdGgsIHNlcmlhbGl6ZUZ1bmN0aW9ucyk7XG5cdCAgICAgIH0gZWxzZSBpZiAoX3ZhbHVlWydfYnNvbnR5cGUnXSA9PT0gJ0JpbmFyeScpIHtcblx0ICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUJpbmFyeShidWZmZXIkJDEsIF9rZXksIF92YWx1ZSwgaW5kZXgpO1xuXHQgICAgICB9IGVsc2UgaWYgKF92YWx1ZVsnX2Jzb250eXBlJ10gPT09ICdTeW1ib2wnKSB7XG5cdCAgICAgICAgaW5kZXggPSBzZXJpYWxpemVTeW1ib2woYnVmZmVyJCQxLCBfa2V5LCBfdmFsdWUsIGluZGV4KTtcblx0ICAgICAgfSBlbHNlIGlmIChfdmFsdWVbJ19ic29udHlwZSddID09PSAnREJSZWYnKSB7XG5cdCAgICAgICAgaW5kZXggPSBzZXJpYWxpemVEQlJlZihidWZmZXIkJDEsIF9rZXksIF92YWx1ZSwgaW5kZXgsIGRlcHRoLCBzZXJpYWxpemVGdW5jdGlvbnMpO1xuXHQgICAgICB9IGVsc2UgaWYgKF92YWx1ZVsnX2Jzb250eXBlJ10gPT09ICdCU09OUmVnRXhwJykge1xuXHQgICAgICAgIGluZGV4ID0gc2VyaWFsaXplQlNPTlJlZ0V4cChidWZmZXIkJDEsIF9rZXksIF92YWx1ZSwgaW5kZXgpO1xuXHQgICAgICB9IGVsc2UgaWYgKF92YWx1ZVsnX2Jzb250eXBlJ10gPT09ICdJbnQzMicpIHtcblx0ICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUludDMyKGJ1ZmZlciQkMSwgX2tleSwgX3ZhbHVlLCBpbmRleCk7XG5cdCAgICAgIH0gZWxzZSBpZiAoX3ZhbHVlWydfYnNvbnR5cGUnXSA9PT0gJ01pbktleScgfHwgX3ZhbHVlWydfYnNvbnR5cGUnXSA9PT0gJ01heEtleScpIHtcblx0ICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZU1pbk1heChidWZmZXIkJDEsIF9rZXksIF92YWx1ZSwgaW5kZXgpO1xuXHQgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBfdmFsdWVbJ19ic29udHlwZSddICE9PSAndW5kZWZpbmVkJykge1xuXHQgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VucmVjb2duaXplZCBvciBpbnZhbGlkIF9ic29udHlwZTogJyArIF92YWx1ZVsnX2Jzb250eXBlJ10pO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSBlbHNlIHtcblx0ICAgIC8vIERpZCB3ZSBwcm92aWRlIGEgY3VzdG9tIHNlcmlhbGl6YXRpb24gbWV0aG9kXG5cdCAgICBpZiAob2JqZWN0LnRvQlNPTikge1xuXHQgICAgICBpZiAodHlwZW9mIG9iamVjdC50b0JTT04gIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RvQlNPTiBpcyBub3QgYSBmdW5jdGlvbicpO1xuXHQgICAgICBvYmplY3QgPSBvYmplY3QudG9CU09OKCk7XG5cdCAgICAgIGlmIChvYmplY3QgIT0gbnVsbCAmJiBfdHlwZW9mJDMob2JqZWN0KSAhPT0gJ29iamVjdCcpIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RvQlNPTiBmdW5jdGlvbiBkaWQgbm90IHJldHVybiBhbiBvYmplY3QnKTtcblx0ICAgIH0gLy8gSXRlcmF0ZSBvdmVyIGFsbCB0aGUga2V5c1xuXG5cblx0ICAgIGZvciAodmFyIF9rZXkyIGluIG9iamVjdCkge1xuXHQgICAgICB2YXIgX3ZhbHVlMiA9IG9iamVjdFtfa2V5Ml07IC8vIElzIHRoZXJlIGFuIG92ZXJyaWRlIHZhbHVlXG5cblx0ICAgICAgaWYgKF92YWx1ZTIgJiYgX3ZhbHVlMi50b0JTT04pIHtcblx0ICAgICAgICBpZiAodHlwZW9mIF92YWx1ZTIudG9CU09OICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKCd0b0JTT04gaXMgbm90IGEgZnVuY3Rpb24nKTtcblx0ICAgICAgICBfdmFsdWUyID0gX3ZhbHVlMi50b0JTT04oKTtcblx0ICAgICAgfSAvLyBDaGVjayB0aGUgdHlwZSBvZiB0aGUgdmFsdWVcblxuXG5cdCAgICAgIHZhciBfdHlwZTIgPSBfdHlwZW9mJDMoX3ZhbHVlMik7IC8vIENoZWNrIHRoZSBrZXkgYW5kIHRocm93IGVycm9yIGlmIGl0J3MgaWxsZWdhbFxuXG5cblx0ICAgICAgaWYgKHR5cGVvZiBfa2V5MiA9PT0gJ3N0cmluZycgJiYgIWlnbm9yZUtleXMuaGFzKF9rZXkyKSkge1xuXHQgICAgICAgIGlmIChfa2V5Mi5tYXRjaChyZWdleHAkMSkgIT0gbnVsbCkge1xuXHQgICAgICAgICAgLy8gVGhlIEJTT04gc3BlYyBkb2Vzbid0IGFsbG93IGtleXMgd2l0aCBudWxsIGJ5dGVzIGJlY2F1c2Uga2V5cyBhcmVcblx0ICAgICAgICAgIC8vIG51bGwtdGVybWluYXRlZC5cblx0ICAgICAgICAgIHRocm93IEVycm9yKCdrZXkgJyArIF9rZXkyICsgJyBtdXN0IG5vdCBjb250YWluIG51bGwgYnl0ZXMnKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoY2hlY2tLZXlzKSB7XG5cdCAgICAgICAgICBpZiAoJyQnID09PSBfa2V5MlswXSkge1xuXHQgICAgICAgICAgICB0aHJvdyBFcnJvcigna2V5ICcgKyBfa2V5MiArIFwiIG11c3Qgbm90IHN0YXJ0IHdpdGggJyQnXCIpO1xuXHQgICAgICAgICAgfSBlbHNlIGlmICh+X2tleTIuaW5kZXhPZignLicpKSB7XG5cdCAgICAgICAgICAgIHRocm93IEVycm9yKCdrZXkgJyArIF9rZXkyICsgXCIgbXVzdCBub3QgY29udGFpbiAnLidcIik7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKF90eXBlMiA9PT0gJ3N0cmluZycpIHtcblx0ICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZVN0cmluZyhidWZmZXIkJDEsIF9rZXkyLCBfdmFsdWUyLCBpbmRleCk7XG5cdCAgICAgIH0gZWxzZSBpZiAoX3R5cGUyID09PSAnbnVtYmVyJykge1xuXHQgICAgICAgIGluZGV4ID0gc2VyaWFsaXplTnVtYmVyKGJ1ZmZlciQkMSwgX2tleTIsIF92YWx1ZTIsIGluZGV4KTtcblx0ICAgICAgfSBlbHNlIGlmIChfdHlwZTIgPT09ICdib29sZWFuJykge1xuXHQgICAgICAgIGluZGV4ID0gc2VyaWFsaXplQm9vbGVhbihidWZmZXIkJDEsIF9rZXkyLCBfdmFsdWUyLCBpbmRleCk7XG5cdCAgICAgIH0gZWxzZSBpZiAoX3ZhbHVlMiBpbnN0YW5jZW9mIERhdGUgfHwgaXNEYXRlJDEoX3ZhbHVlMikpIHtcblx0ICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZURhdGUoYnVmZmVyJCQxLCBfa2V5MiwgX3ZhbHVlMiwgaW5kZXgpO1xuXHQgICAgICB9IGVsc2UgaWYgKF92YWx1ZTIgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIGlmIChpZ25vcmVVbmRlZmluZWQgPT09IGZhbHNlKSBpbmRleCA9IHNlcmlhbGl6ZU51bGwoYnVmZmVyJCQxLCBfa2V5MiwgX3ZhbHVlMiwgaW5kZXgpO1xuXHQgICAgICB9IGVsc2UgaWYgKF92YWx1ZTIgPT09IG51bGwpIHtcblx0ICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZU51bGwoYnVmZmVyJCQxLCBfa2V5MiwgX3ZhbHVlMiwgaW5kZXgpO1xuXHQgICAgICB9IGVsc2UgaWYgKF92YWx1ZTJbJ19ic29udHlwZSddID09PSAnT2JqZWN0SWQnIHx8IF92YWx1ZTJbJ19ic29udHlwZSddID09PSAnT2JqZWN0SUQnKSB7XG5cdCAgICAgICAgaW5kZXggPSBzZXJpYWxpemVPYmplY3RJZChidWZmZXIkJDEsIF9rZXkyLCBfdmFsdWUyLCBpbmRleCk7XG5cdCAgICAgIH0gZWxzZSBpZiAoQnVmZmVyJDUuaXNCdWZmZXIoX3ZhbHVlMikpIHtcblx0ICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUJ1ZmZlcihidWZmZXIkJDEsIF9rZXkyLCBfdmFsdWUyLCBpbmRleCk7XG5cdCAgICAgIH0gZWxzZSBpZiAoX3ZhbHVlMiBpbnN0YW5jZW9mIFJlZ0V4cCB8fCBpc1JlZ0V4cCQxKF92YWx1ZTIpKSB7XG5cdCAgICAgICAgaW5kZXggPSBzZXJpYWxpemVSZWdFeHAoYnVmZmVyJCQxLCBfa2V5MiwgX3ZhbHVlMiwgaW5kZXgpO1xuXHQgICAgICB9IGVsc2UgaWYgKF90eXBlMiA9PT0gJ29iamVjdCcgJiYgX3ZhbHVlMlsnX2Jzb250eXBlJ10gPT0gbnVsbCkge1xuXHQgICAgICAgIGluZGV4ID0gc2VyaWFsaXplT2JqZWN0KGJ1ZmZlciQkMSwgX2tleTIsIF92YWx1ZTIsIGluZGV4LCBjaGVja0tleXMsIGRlcHRoLCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCwgZmFsc2UsIHBhdGgpO1xuXHQgICAgICB9IGVsc2UgaWYgKF90eXBlMiA9PT0gJ29iamVjdCcgJiYgX3ZhbHVlMlsnX2Jzb250eXBlJ10gPT09ICdEZWNpbWFsMTI4Jykge1xuXHQgICAgICAgIGluZGV4ID0gc2VyaWFsaXplRGVjaW1hbDEyOChidWZmZXIkJDEsIF9rZXkyLCBfdmFsdWUyLCBpbmRleCk7XG5cdCAgICAgIH0gZWxzZSBpZiAoX3ZhbHVlMlsnX2Jzb250eXBlJ10gPT09ICdMb25nJyB8fCBfdmFsdWUyWydfYnNvbnR5cGUnXSA9PT0gJ1RpbWVzdGFtcCcpIHtcblx0ICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUxvbmcoYnVmZmVyJCQxLCBfa2V5MiwgX3ZhbHVlMiwgaW5kZXgpO1xuXHQgICAgICB9IGVsc2UgaWYgKF92YWx1ZTJbJ19ic29udHlwZSddID09PSAnRG91YmxlJykge1xuXHQgICAgICAgIGluZGV4ID0gc2VyaWFsaXplRG91YmxlKGJ1ZmZlciQkMSwgX2tleTIsIF92YWx1ZTIsIGluZGV4KTtcblx0ICAgICAgfSBlbHNlIGlmIChfdmFsdWUyWydfYnNvbnR5cGUnXSA9PT0gJ0NvZGUnKSB7XG5cdCAgICAgICAgaW5kZXggPSBzZXJpYWxpemVDb2RlKGJ1ZmZlciQkMSwgX2tleTIsIF92YWx1ZTIsIGluZGV4LCBjaGVja0tleXMsIGRlcHRoLCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCk7XG5cdCAgICAgIH0gZWxzZSBpZiAodHlwZW9mIF92YWx1ZTIgPT09ICdmdW5jdGlvbicgJiYgc2VyaWFsaXplRnVuY3Rpb25zKSB7XG5cdCAgICAgICAgaW5kZXggPSBzZXJpYWxpemVGdW5jdGlvbihidWZmZXIkJDEsIF9rZXkyLCBfdmFsdWUyLCBpbmRleCwgY2hlY2tLZXlzLCBkZXB0aCwgc2VyaWFsaXplRnVuY3Rpb25zKTtcblx0ICAgICAgfSBlbHNlIGlmIChfdmFsdWUyWydfYnNvbnR5cGUnXSA9PT0gJ0JpbmFyeScpIHtcblx0ICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUJpbmFyeShidWZmZXIkJDEsIF9rZXkyLCBfdmFsdWUyLCBpbmRleCk7XG5cdCAgICAgIH0gZWxzZSBpZiAoX3ZhbHVlMlsnX2Jzb250eXBlJ10gPT09ICdTeW1ib2wnKSB7XG5cdCAgICAgICAgaW5kZXggPSBzZXJpYWxpemVTeW1ib2woYnVmZmVyJCQxLCBfa2V5MiwgX3ZhbHVlMiwgaW5kZXgpO1xuXHQgICAgICB9IGVsc2UgaWYgKF92YWx1ZTJbJ19ic29udHlwZSddID09PSAnREJSZWYnKSB7XG5cdCAgICAgICAgaW5kZXggPSBzZXJpYWxpemVEQlJlZihidWZmZXIkJDEsIF9rZXkyLCBfdmFsdWUyLCBpbmRleCwgZGVwdGgsIHNlcmlhbGl6ZUZ1bmN0aW9ucyk7XG5cdCAgICAgIH0gZWxzZSBpZiAoX3ZhbHVlMlsnX2Jzb250eXBlJ10gPT09ICdCU09OUmVnRXhwJykge1xuXHQgICAgICAgIGluZGV4ID0gc2VyaWFsaXplQlNPTlJlZ0V4cChidWZmZXIkJDEsIF9rZXkyLCBfdmFsdWUyLCBpbmRleCk7XG5cdCAgICAgIH0gZWxzZSBpZiAoX3ZhbHVlMlsnX2Jzb250eXBlJ10gPT09ICdJbnQzMicpIHtcblx0ICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUludDMyKGJ1ZmZlciQkMSwgX2tleTIsIF92YWx1ZTIsIGluZGV4KTtcblx0ICAgICAgfSBlbHNlIGlmIChfdmFsdWUyWydfYnNvbnR5cGUnXSA9PT0gJ01pbktleScgfHwgX3ZhbHVlMlsnX2Jzb250eXBlJ10gPT09ICdNYXhLZXknKSB7XG5cdCAgICAgICAgaW5kZXggPSBzZXJpYWxpemVNaW5NYXgoYnVmZmVyJCQxLCBfa2V5MiwgX3ZhbHVlMiwgaW5kZXgpO1xuXHQgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBfdmFsdWUyWydfYnNvbnR5cGUnXSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbnJlY29nbml6ZWQgb3IgaW52YWxpZCBfYnNvbnR5cGU6ICcgKyBfdmFsdWUyWydfYnNvbnR5cGUnXSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9IC8vIFJlbW92ZSB0aGUgcGF0aFxuXG5cblx0ICBwYXRoLnBvcCgpOyAvLyBGaW5hbCBwYWRkaW5nIGJ5dGUgZm9yIG9iamVjdFxuXG5cdCAgYnVmZmVyJCQxW2luZGV4KytdID0gMHgwMDsgLy8gRmluYWwgc2l6ZVxuXG5cdCAgdmFyIHNpemUgPSBpbmRleCAtIHN0YXJ0aW5nSW5kZXg7IC8vIFdyaXRlIHRoZSBzaXplIG9mIHRoZSBvYmplY3RcblxuXHQgIGJ1ZmZlciQkMVtzdGFydGluZ0luZGV4KytdID0gc2l6ZSAmIDB4ZmY7XG5cdCAgYnVmZmVyJCQxW3N0YXJ0aW5nSW5kZXgrK10gPSBzaXplID4+IDggJiAweGZmO1xuXHQgIGJ1ZmZlciQkMVtzdGFydGluZ0luZGV4KytdID0gc2l6ZSA+PiAxNiAmIDB4ZmY7XG5cdCAgYnVmZmVyJCQxW3N0YXJ0aW5nSW5kZXgrK10gPSBzaXplID4+IDI0ICYgMHhmZjtcblx0ICByZXR1cm4gaW5kZXg7XG5cdH1cblxuXHR2YXIgc2VyaWFsaXplciA9IHNlcmlhbGl6ZUludG87XG5cblx0ZnVuY3Rpb24gX3R5cGVvZiQ0KG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiQ0ID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YkNCA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mJDQob2JqKTsgfVxuXG5cdHZhciBCdWZmZXIkNiA9IGJ1ZmZlci5CdWZmZXI7XG5cdHZhciBub3JtYWxpemVkRnVuY3Rpb25TdHJpbmckMiA9IHV0aWxzLm5vcm1hbGl6ZWRGdW5jdGlvblN0cmluZzsgLy8gVG8gZW5zdXJlIHRoYXQgMC40IG9mIG5vZGUgd29ya3MgY29ycmVjdGx5XG5cblx0ZnVuY3Rpb24gaXNEYXRlJDIoZCkge1xuXHQgIHJldHVybiBfdHlwZW9mJDQoZCkgPT09ICdvYmplY3QnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xuXHR9XG5cblx0ZnVuY3Rpb24gY2FsY3VsYXRlT2JqZWN0U2l6ZShvYmplY3QsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgaWdub3JlVW5kZWZpbmVkKSB7XG5cdCAgdmFyIHRvdGFsTGVuZ3RoID0gNCArIDE7XG5cblx0ICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5sZW5ndGg7IGkrKykge1xuXHQgICAgICB0b3RhbExlbmd0aCArPSBjYWxjdWxhdGVFbGVtZW50KGkudG9TdHJpbmcoKSwgb2JqZWN0W2ldLCBzZXJpYWxpemVGdW5jdGlvbnMsIHRydWUsIGlnbm9yZVVuZGVmaW5lZCk7XG5cdCAgICB9XG5cdCAgfSBlbHNlIHtcblx0ICAgIC8vIElmIHdlIGhhdmUgdG9CU09OIGRlZmluZWQsIG92ZXJyaWRlIHRoZSBjdXJyZW50IG9iamVjdFxuXHQgICAgaWYgKG9iamVjdC50b0JTT04pIHtcblx0ICAgICAgb2JqZWN0ID0gb2JqZWN0LnRvQlNPTigpO1xuXHQgICAgfSAvLyBDYWxjdWxhdGUgc2l6ZVxuXG5cblx0ICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcblx0ICAgICAgdG90YWxMZW5ndGggKz0gY2FsY3VsYXRlRWxlbWVudChrZXksIG9iamVjdFtrZXldLCBzZXJpYWxpemVGdW5jdGlvbnMsIGZhbHNlLCBpZ25vcmVVbmRlZmluZWQpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHJldHVybiB0b3RhbExlbmd0aDtcblx0fVxuXHQvKipcblx0ICogQGlnbm9yZVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblxuXHRmdW5jdGlvbiBjYWxjdWxhdGVFbGVtZW50KG5hbWUsIHZhbHVlLCBzZXJpYWxpemVGdW5jdGlvbnMsIGlzQXJyYXksIGlnbm9yZVVuZGVmaW5lZCkge1xuXHQgIC8vIElmIHdlIGhhdmUgdG9CU09OIGRlZmluZWQsIG92ZXJyaWRlIHRoZSBjdXJyZW50IG9iamVjdFxuXHQgIGlmICh2YWx1ZSAmJiB2YWx1ZS50b0JTT04pIHtcblx0ICAgIHZhbHVlID0gdmFsdWUudG9CU09OKCk7XG5cdCAgfVxuXG5cdCAgc3dpdGNoIChfdHlwZW9mJDQodmFsdWUpKSB7XG5cdCAgICBjYXNlICdzdHJpbmcnOlxuXHQgICAgICByZXR1cm4gMSArIEJ1ZmZlciQ2LmJ5dGVMZW5ndGgobmFtZSwgJ3V0ZjgnKSArIDEgKyA0ICsgQnVmZmVyJDYuYnl0ZUxlbmd0aCh2YWx1ZSwgJ3V0ZjgnKSArIDE7XG5cblx0ICAgIGNhc2UgJ251bWJlcic6XG5cdCAgICAgIGlmIChNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUgJiYgdmFsdWUgPj0gY29uc3RhbnRzLkpTX0lOVF9NSU4gJiYgdmFsdWUgPD0gY29uc3RhbnRzLkpTX0lOVF9NQVgpIHtcblx0ICAgICAgICBpZiAodmFsdWUgPj0gY29uc3RhbnRzLkJTT05fSU5UMzJfTUlOICYmIHZhbHVlIDw9IGNvbnN0YW50cy5CU09OX0lOVDMyX01BWCkge1xuXHQgICAgICAgICAgLy8gMzIgYml0XG5cdCAgICAgICAgICByZXR1cm4gKG5hbWUgIT0gbnVsbCA/IEJ1ZmZlciQ2LmJ5dGVMZW5ndGgobmFtZSwgJ3V0ZjgnKSArIDEgOiAwKSArICg0ICsgMSk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHJldHVybiAobmFtZSAhPSBudWxsID8gQnVmZmVyJDYuYnl0ZUxlbmd0aChuYW1lLCAndXRmOCcpICsgMSA6IDApICsgKDggKyAxKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgLy8gNjQgYml0XG5cdCAgICAgICAgcmV0dXJuIChuYW1lICE9IG51bGwgPyBCdWZmZXIkNi5ieXRlTGVuZ3RoKG5hbWUsICd1dGY4JykgKyAxIDogMCkgKyAoOCArIDEpO1xuXHQgICAgICB9XG5cblx0ICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG5cdCAgICAgIGlmIChpc0FycmF5IHx8ICFpZ25vcmVVbmRlZmluZWQpIHJldHVybiAobmFtZSAhPSBudWxsID8gQnVmZmVyJDYuYnl0ZUxlbmd0aChuYW1lLCAndXRmOCcpICsgMSA6IDApICsgMTtcblx0ICAgICAgcmV0dXJuIDA7XG5cblx0ICAgIGNhc2UgJ2Jvb2xlYW4nOlxuXHQgICAgICByZXR1cm4gKG5hbWUgIT0gbnVsbCA/IEJ1ZmZlciQ2LmJ5dGVMZW5ndGgobmFtZSwgJ3V0ZjgnKSArIDEgOiAwKSArICgxICsgMSk7XG5cblx0ICAgIGNhc2UgJ29iamVjdCc6XG5cdCAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlWydfYnNvbnR5cGUnXSA9PT0gJ01pbktleScgfHwgdmFsdWVbJ19ic29udHlwZSddID09PSAnTWF4S2V5Jykge1xuXHQgICAgICAgIHJldHVybiAobmFtZSAhPSBudWxsID8gQnVmZmVyJDYuYnl0ZUxlbmd0aChuYW1lLCAndXRmOCcpICsgMSA6IDApICsgMTtcblx0ICAgICAgfSBlbHNlIGlmICh2YWx1ZVsnX2Jzb250eXBlJ10gPT09ICdPYmplY3RJZCcgfHwgdmFsdWVbJ19ic29udHlwZSddID09PSAnT2JqZWN0SUQnKSB7XG5cdCAgICAgICAgcmV0dXJuIChuYW1lICE9IG51bGwgPyBCdWZmZXIkNi5ieXRlTGVuZ3RoKG5hbWUsICd1dGY4JykgKyAxIDogMCkgKyAoMTIgKyAxKTtcblx0ICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUgfHwgaXNEYXRlJDIodmFsdWUpKSB7XG5cdCAgICAgICAgcmV0dXJuIChuYW1lICE9IG51bGwgPyBCdWZmZXIkNi5ieXRlTGVuZ3RoKG5hbWUsICd1dGY4JykgKyAxIDogMCkgKyAoOCArIDEpO1xuXHQgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBCdWZmZXIkNiAhPT0gJ3VuZGVmaW5lZCcgJiYgQnVmZmVyJDYuaXNCdWZmZXIodmFsdWUpKSB7XG5cdCAgICAgICAgcmV0dXJuIChuYW1lICE9IG51bGwgPyBCdWZmZXIkNi5ieXRlTGVuZ3RoKG5hbWUsICd1dGY4JykgKyAxIDogMCkgKyAoMSArIDQgKyAxKSArIHZhbHVlLmxlbmd0aDtcblx0ICAgICAgfSBlbHNlIGlmICh2YWx1ZVsnX2Jzb250eXBlJ10gPT09ICdMb25nJyB8fCB2YWx1ZVsnX2Jzb250eXBlJ10gPT09ICdEb3VibGUnIHx8IHZhbHVlWydfYnNvbnR5cGUnXSA9PT0gJ1RpbWVzdGFtcCcpIHtcblx0ICAgICAgICByZXR1cm4gKG5hbWUgIT0gbnVsbCA/IEJ1ZmZlciQ2LmJ5dGVMZW5ndGgobmFtZSwgJ3V0ZjgnKSArIDEgOiAwKSArICg4ICsgMSk7XG5cdCAgICAgIH0gZWxzZSBpZiAodmFsdWVbJ19ic29udHlwZSddID09PSAnRGVjaW1hbDEyOCcpIHtcblx0ICAgICAgICByZXR1cm4gKG5hbWUgIT0gbnVsbCA/IEJ1ZmZlciQ2LmJ5dGVMZW5ndGgobmFtZSwgJ3V0ZjgnKSArIDEgOiAwKSArICgxNiArIDEpO1xuXHQgICAgICB9IGVsc2UgaWYgKHZhbHVlWydfYnNvbnR5cGUnXSA9PT0gJ0NvZGUnKSB7XG5cdCAgICAgICAgLy8gQ2FsY3VsYXRlIHNpemUgZGVwZW5kaW5nIG9uIHRoZSBhdmFpbGFiaWxpdHkgb2YgYSBzY29wZVxuXHQgICAgICAgIGlmICh2YWx1ZS5zY29wZSAhPSBudWxsICYmIE9iamVjdC5rZXlzKHZhbHVlLnNjb3BlKS5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICByZXR1cm4gKG5hbWUgIT0gbnVsbCA/IEJ1ZmZlciQ2LmJ5dGVMZW5ndGgobmFtZSwgJ3V0ZjgnKSArIDEgOiAwKSArIDEgKyA0ICsgNCArIEJ1ZmZlciQ2LmJ5dGVMZW5ndGgodmFsdWUuY29kZS50b1N0cmluZygpLCAndXRmOCcpICsgMSArIGNhbGN1bGF0ZU9iamVjdFNpemUodmFsdWUuc2NvcGUsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgaWdub3JlVW5kZWZpbmVkKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgcmV0dXJuIChuYW1lICE9IG51bGwgPyBCdWZmZXIkNi5ieXRlTGVuZ3RoKG5hbWUsICd1dGY4JykgKyAxIDogMCkgKyAxICsgNCArIEJ1ZmZlciQ2LmJ5dGVMZW5ndGgodmFsdWUuY29kZS50b1N0cmluZygpLCAndXRmOCcpICsgMTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0gZWxzZSBpZiAodmFsdWVbJ19ic29udHlwZSddID09PSAnQmluYXJ5Jykge1xuXHQgICAgICAgIC8vIENoZWNrIHdoYXQga2luZCBvZiBzdWJ0eXBlIHdlIGhhdmVcblx0ICAgICAgICBpZiAodmFsdWUuc3ViX3R5cGUgPT09IGJpbmFyeS5TVUJUWVBFX0JZVEVfQVJSQVkpIHtcblx0ICAgICAgICAgIHJldHVybiAobmFtZSAhPSBudWxsID8gQnVmZmVyJDYuYnl0ZUxlbmd0aChuYW1lLCAndXRmOCcpICsgMSA6IDApICsgKHZhbHVlLnBvc2l0aW9uICsgMSArIDQgKyAxICsgNCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHJldHVybiAobmFtZSAhPSBudWxsID8gQnVmZmVyJDYuYnl0ZUxlbmd0aChuYW1lLCAndXRmOCcpICsgMSA6IDApICsgKHZhbHVlLnBvc2l0aW9uICsgMSArIDQgKyAxKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0gZWxzZSBpZiAodmFsdWVbJ19ic29udHlwZSddID09PSAnU3ltYm9sJykge1xuXHQgICAgICAgIHJldHVybiAobmFtZSAhPSBudWxsID8gQnVmZmVyJDYuYnl0ZUxlbmd0aChuYW1lLCAndXRmOCcpICsgMSA6IDApICsgQnVmZmVyJDYuYnl0ZUxlbmd0aCh2YWx1ZS52YWx1ZSwgJ3V0ZjgnKSArIDQgKyAxICsgMTtcblx0ICAgICAgfSBlbHNlIGlmICh2YWx1ZVsnX2Jzb250eXBlJ10gPT09ICdEQlJlZicpIHtcblx0ICAgICAgICAvLyBTZXQgdXAgY29ycmVjdCBvYmplY3QgZm9yIHNlcmlhbGl6YXRpb25cblx0ICAgICAgICB2YXIgb3JkZXJlZF92YWx1ZXMgPSBPYmplY3QuYXNzaWduKHtcblx0ICAgICAgICAgICRyZWY6IHZhbHVlLmNvbGxlY3Rpb24sXG5cdCAgICAgICAgICAkaWQ6IHZhbHVlLm9pZFxuXHQgICAgICAgIH0sIHZhbHVlLmZpZWxkcyk7IC8vIEFkZCBkYiByZWZlcmVuY2UgaWYgaXQgZXhpc3RzXG5cblx0ICAgICAgICBpZiAodmFsdWUuZGIgIT0gbnVsbCkge1xuXHQgICAgICAgICAgb3JkZXJlZF92YWx1ZXNbJyRkYiddID0gdmFsdWUuZGI7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIChuYW1lICE9IG51bGwgPyBCdWZmZXIkNi5ieXRlTGVuZ3RoKG5hbWUsICd1dGY4JykgKyAxIDogMCkgKyAxICsgY2FsY3VsYXRlT2JqZWN0U2l6ZShvcmRlcmVkX3ZhbHVlcywgc2VyaWFsaXplRnVuY3Rpb25zLCBpZ25vcmVVbmRlZmluZWQpO1xuXHQgICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG5cdCAgICAgICAgcmV0dXJuIChuYW1lICE9IG51bGwgPyBCdWZmZXIkNi5ieXRlTGVuZ3RoKG5hbWUsICd1dGY4JykgKyAxIDogMCkgKyAxICsgQnVmZmVyJDYuYnl0ZUxlbmd0aCh2YWx1ZS5zb3VyY2UsICd1dGY4JykgKyAxICsgKHZhbHVlLmdsb2JhbCA/IDEgOiAwKSArICh2YWx1ZS5pZ25vcmVDYXNlID8gMSA6IDApICsgKHZhbHVlLm11bHRpbGluZSA/IDEgOiAwKSArIDE7XG5cdCAgICAgIH0gZWxzZSBpZiAodmFsdWVbJ19ic29udHlwZSddID09PSAnQlNPTlJlZ0V4cCcpIHtcblx0ICAgICAgICByZXR1cm4gKG5hbWUgIT0gbnVsbCA/IEJ1ZmZlciQ2LmJ5dGVMZW5ndGgobmFtZSwgJ3V0ZjgnKSArIDEgOiAwKSArIDEgKyBCdWZmZXIkNi5ieXRlTGVuZ3RoKHZhbHVlLnBhdHRlcm4sICd1dGY4JykgKyAxICsgQnVmZmVyJDYuYnl0ZUxlbmd0aCh2YWx1ZS5vcHRpb25zLCAndXRmOCcpICsgMTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gKG5hbWUgIT0gbnVsbCA/IEJ1ZmZlciQ2LmJ5dGVMZW5ndGgobmFtZSwgJ3V0ZjgnKSArIDEgOiAwKSArIGNhbGN1bGF0ZU9iamVjdFNpemUodmFsdWUsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgaWdub3JlVW5kZWZpbmVkKSArIDE7XG5cdCAgICAgIH1cblxuXHQgICAgY2FzZSAnZnVuY3Rpb24nOlxuXHQgICAgICAvLyBXVEYgZm9yIDAuNC5YIHdoZXJlIHR5cGVvZiAvc29tZXJlZ2V4cC8gPT09ICdmdW5jdGlvbidcblx0ICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nIHx8IFN0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXScpIHtcblx0ICAgICAgICByZXR1cm4gKG5hbWUgIT0gbnVsbCA/IEJ1ZmZlciQ2LmJ5dGVMZW5ndGgobmFtZSwgJ3V0ZjgnKSArIDEgOiAwKSArIDEgKyBCdWZmZXIkNi5ieXRlTGVuZ3RoKHZhbHVlLnNvdXJjZSwgJ3V0ZjgnKSArIDEgKyAodmFsdWUuZ2xvYmFsID8gMSA6IDApICsgKHZhbHVlLmlnbm9yZUNhc2UgPyAxIDogMCkgKyAodmFsdWUubXVsdGlsaW5lID8gMSA6IDApICsgMTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBpZiAoc2VyaWFsaXplRnVuY3Rpb25zICYmIHZhbHVlLnNjb3BlICE9IG51bGwgJiYgT2JqZWN0LmtleXModmFsdWUuc2NvcGUpLmxlbmd0aCA+IDApIHtcblx0ICAgICAgICAgIHJldHVybiAobmFtZSAhPSBudWxsID8gQnVmZmVyJDYuYnl0ZUxlbmd0aChuYW1lLCAndXRmOCcpICsgMSA6IDApICsgMSArIDQgKyA0ICsgQnVmZmVyJDYuYnl0ZUxlbmd0aChub3JtYWxpemVkRnVuY3Rpb25TdHJpbmckMih2YWx1ZSksICd1dGY4JykgKyAxICsgY2FsY3VsYXRlT2JqZWN0U2l6ZSh2YWx1ZS5zY29wZSwgc2VyaWFsaXplRnVuY3Rpb25zLCBpZ25vcmVVbmRlZmluZWQpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoc2VyaWFsaXplRnVuY3Rpb25zKSB7XG5cdCAgICAgICAgICByZXR1cm4gKG5hbWUgIT0gbnVsbCA/IEJ1ZmZlciQ2LmJ5dGVMZW5ndGgobmFtZSwgJ3V0ZjgnKSArIDEgOiAwKSArIDEgKyA0ICsgQnVmZmVyJDYuYnl0ZUxlbmd0aChub3JtYWxpemVkRnVuY3Rpb25TdHJpbmckMih2YWx1ZSksICd1dGY4JykgKyAxO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgfVxuXG5cdCAgcmV0dXJuIDA7XG5cdH1cblxuXHR2YXIgY2FsY3VsYXRlX3NpemUgPSBjYWxjdWxhdGVPYmplY3RTaXplO1xuXG5cdHZhciBCdWZmZXIkNyA9IGJ1ZmZlci5CdWZmZXI7XG5cdC8qKlxuXHQgKiBNYWtlcyBzdXJlIHRoYXQsIGlmIGEgVWludDhBcnJheSBpcyBwYXNzZWQgaW4sIGl0IGlzIHdyYXBwZWQgaW4gYSBCdWZmZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QnVmZmVyfFVpbnQ4QXJyYXl9IHBvdGVudGlhbEJ1ZmZlciBUaGUgcG90ZW50aWFsIGJ1ZmZlclxuXHQgKiBAcmV0dXJucyB7QnVmZmVyfSB0aGUgaW5wdXQgaWYgcG90ZW50aWFsQnVmZmVyIGlzIGEgYnVmZmVyLCBvciBhIGJ1ZmZlciB0aGF0XG5cdCAqIHdyYXBzIGEgcGFzc2VkIGluIFVpbnQ4QXJyYXlcblx0ICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhbnl0aGluZyBvdGhlciB0aGFuIGEgQnVmZmVyIG9yIFVpbnQ4QXJyYXkgaXMgcGFzc2VkIGluXG5cdCAqL1xuXG5cdHZhciBlbnN1cmVfYnVmZmVyID0gZnVuY3Rpb24gZW5zdXJlQnVmZmVyKHBvdGVudGlhbEJ1ZmZlcikge1xuXHQgIGlmIChwb3RlbnRpYWxCdWZmZXIgaW5zdGFuY2VvZiBCdWZmZXIkNykge1xuXHQgICAgcmV0dXJuIHBvdGVudGlhbEJ1ZmZlcjtcblx0ICB9XG5cblx0ICBpZiAocG90ZW50aWFsQnVmZmVyIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuXHQgICAgcmV0dXJuIEJ1ZmZlciQ3LmZyb20ocG90ZW50aWFsQnVmZmVyLmJ1ZmZlcik7XG5cdCAgfVxuXG5cdCAgdGhyb3cgbmV3IFR5cGVFcnJvcignTXVzdCB1c2UgZWl0aGVyIEJ1ZmZlciBvciBVaW50OEFycmF5Jyk7XG5cdH07XG5cblx0dmFyIEJ1ZmZlciQ4ID0gYnVmZmVyLkJ1ZmZlcjsgLy8gUGFydHMgb2YgdGhlIHBhcnNlclxuXG5cdC8qKlxuXHQgKiBAaWdub3JlXG5cdCAqL1xuXHQvLyBEZWZhdWx0IE1heCBTaXplXG5cblx0dmFyIE1BWFNJWkUgPSAxMDI0ICogMTAyNCAqIDE3OyAvLyBDdXJyZW50IEludGVybmFsIFRlbXBvcmFyeSBTZXJpYWxpemF0aW9uIEJ1ZmZlclxuXG5cdHZhciBidWZmZXIkMSA9IEJ1ZmZlciQ4LmFsbG9jKE1BWFNJWkUpO1xuXHQvKipcblx0ICogU2V0cyB0aGUgc2l6ZSBvZiB0aGUgaW50ZXJuYWwgc2VyaWFsaXphdGlvbiBidWZmZXIuXG5cdCAqXG5cdCAqIEBtZXRob2Rcblx0ICogQHBhcmFtIHtudW1iZXJ9IHNpemUgVGhlIGRlc2lyZWQgc2l6ZSBmb3IgdGhlIGludGVybmFsIHNlcmlhbGl6YXRpb24gYnVmZmVyXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIHNldEludGVybmFsQnVmZmVyU2l6ZShzaXplKSB7XG5cdCAgLy8gUmVzaXplIHRoZSBpbnRlcm5hbCBzZXJpYWxpemF0aW9uIGJ1ZmZlciBpZiBuZWVkZWRcblx0ICBpZiAoYnVmZmVyJDEubGVuZ3RoIDwgc2l6ZSkge1xuXHQgICAgYnVmZmVyJDEgPSBCdWZmZXIkOC5hbGxvYyhzaXplKTtcblx0ICB9XG5cdH1cblx0LyoqXG5cdCAqIFNlcmlhbGl6ZSBhIEphdmFzY3JpcHQgb2JqZWN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IHRoZSBKYXZhc2NyaXB0IG9iamVjdCB0byBzZXJpYWxpemUuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2hlY2tLZXlzXSB0aGUgc2VyaWFsaXplciB3aWxsIGNoZWNrIGlmIGtleXMgYXJlIHZhbGlkLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNlcmlhbGl6ZUZ1bmN0aW9ucz1mYWxzZV0gc2VyaWFsaXplIHRoZSBqYXZhc2NyaXB0IGZ1bmN0aW9ucyAqKihkZWZhdWx0OmZhbHNlKSoqLlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmlnbm9yZVVuZGVmaW5lZD10cnVlXSBpZ25vcmUgdW5kZWZpbmVkIGZpZWxkcyAqKihkZWZhdWx0OnRydWUpKiouXG5cdCAqIEByZXR1cm4ge0J1ZmZlcn0gcmV0dXJucyB0aGUgQnVmZmVyIG9iamVjdCBjb250YWluaW5nIHRoZSBzZXJpYWxpemVkIG9iamVjdC5cblx0ICovXG5cblxuXHRmdW5jdGlvbiBzZXJpYWxpemUkMShvYmplY3QsIG9wdGlvbnMpIHtcblx0ICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gVW5wYWNrIHRoZSBvcHRpb25zXG5cblx0ICB2YXIgY2hlY2tLZXlzID0gdHlwZW9mIG9wdGlvbnMuY2hlY2tLZXlzID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmNoZWNrS2V5cyA6IGZhbHNlO1xuXHQgIHZhciBzZXJpYWxpemVGdW5jdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucy5zZXJpYWxpemVGdW5jdGlvbnMgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuc2VyaWFsaXplRnVuY3Rpb25zIDogZmFsc2U7XG5cdCAgdmFyIGlnbm9yZVVuZGVmaW5lZCA9IHR5cGVvZiBvcHRpb25zLmlnbm9yZVVuZGVmaW5lZCA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5pZ25vcmVVbmRlZmluZWQgOiB0cnVlO1xuXHQgIHZhciBtaW5JbnRlcm5hbEJ1ZmZlclNpemUgPSB0eXBlb2Ygb3B0aW9ucy5taW5JbnRlcm5hbEJ1ZmZlclNpemUgPT09ICdudW1iZXInID8gb3B0aW9ucy5taW5JbnRlcm5hbEJ1ZmZlclNpemUgOiBNQVhTSVpFOyAvLyBSZXNpemUgdGhlIGludGVybmFsIHNlcmlhbGl6YXRpb24gYnVmZmVyIGlmIG5lZWRlZFxuXG5cdCAgaWYgKGJ1ZmZlciQxLmxlbmd0aCA8IG1pbkludGVybmFsQnVmZmVyU2l6ZSkge1xuXHQgICAgYnVmZmVyJDEgPSBCdWZmZXIkOC5hbGxvYyhtaW5JbnRlcm5hbEJ1ZmZlclNpemUpO1xuXHQgIH0gLy8gQXR0ZW1wdCB0byBzZXJpYWxpemVcblxuXG5cdCAgdmFyIHNlcmlhbGl6YXRpb25JbmRleCA9IHNlcmlhbGl6ZXIoYnVmZmVyJDEsIG9iamVjdCwgY2hlY2tLZXlzLCAwLCAwLCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCwgW10pOyAvLyBDcmVhdGUgdGhlIGZpbmFsIGJ1ZmZlclxuXG5cdCAgdmFyIGZpbmlzaGVkQnVmZmVyID0gQnVmZmVyJDguYWxsb2Moc2VyaWFsaXphdGlvbkluZGV4KTsgLy8gQ29weSBpbnRvIHRoZSBmaW5pc2hlZCBidWZmZXJcblxuXHQgIGJ1ZmZlciQxLmNvcHkoZmluaXNoZWRCdWZmZXIsIDAsIDAsIGZpbmlzaGVkQnVmZmVyLmxlbmd0aCk7IC8vIFJldHVybiB0aGUgYnVmZmVyXG5cblx0ICByZXR1cm4gZmluaXNoZWRCdWZmZXI7XG5cdH1cblx0LyoqXG5cdCAqIFNlcmlhbGl6ZSBhIEphdmFzY3JpcHQgb2JqZWN0IHVzaW5nIGEgcHJlZGVmaW5lZCBCdWZmZXIgYW5kIGluZGV4IGludG8gdGhlIGJ1ZmZlciwgdXNlZnVsIHdoZW4gcHJlLWFsbG9jYXRpbmcgdGhlIHNwYWNlIGZvciBzZXJpYWxpemF0aW9uLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IHRoZSBKYXZhc2NyaXB0IG9iamVjdCB0byBzZXJpYWxpemUuXG5cdCAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgdGhlIEJ1ZmZlciB5b3UgcHJlLWFsbG9jYXRlZCB0byBzdG9yZSB0aGUgc2VyaWFsaXplZCBCU09OIG9iamVjdC5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jaGVja0tleXNdIHRoZSBzZXJpYWxpemVyIHdpbGwgY2hlY2sgaWYga2V5cyBhcmUgdmFsaWQuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2VyaWFsaXplRnVuY3Rpb25zPWZhbHNlXSBzZXJpYWxpemUgdGhlIGphdmFzY3JpcHQgZnVuY3Rpb25zICoqKGRlZmF1bHQ6ZmFsc2UpKiouXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaWdub3JlVW5kZWZpbmVkPXRydWVdIGlnbm9yZSB1bmRlZmluZWQgZmllbGRzICoqKGRlZmF1bHQ6dHJ1ZSkqKi5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmluZGV4XSB0aGUgaW5kZXggaW4gdGhlIGJ1ZmZlciB3aGVyZSB3ZSB3aXNoIHRvIHN0YXJ0IHNlcmlhbGl6aW5nIGludG8uXG5cdCAqIEByZXR1cm4ge051bWJlcn0gcmV0dXJucyB0aGUgaW5kZXggcG9pbnRpbmcgdG8gdGhlIGxhc3Qgd3JpdHRlbiBieXRlIGluIHRoZSBidWZmZXIuXG5cdCAqL1xuXG5cblx0ZnVuY3Rpb24gc2VyaWFsaXplV2l0aEJ1ZmZlckFuZEluZGV4KG9iamVjdCwgZmluYWxCdWZmZXIsIG9wdGlvbnMpIHtcblx0ICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gVW5wYWNrIHRoZSBvcHRpb25zXG5cblx0ICB2YXIgY2hlY2tLZXlzID0gdHlwZW9mIG9wdGlvbnMuY2hlY2tLZXlzID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmNoZWNrS2V5cyA6IGZhbHNlO1xuXHQgIHZhciBzZXJpYWxpemVGdW5jdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucy5zZXJpYWxpemVGdW5jdGlvbnMgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuc2VyaWFsaXplRnVuY3Rpb25zIDogZmFsc2U7XG5cdCAgdmFyIGlnbm9yZVVuZGVmaW5lZCA9IHR5cGVvZiBvcHRpb25zLmlnbm9yZVVuZGVmaW5lZCA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5pZ25vcmVVbmRlZmluZWQgOiB0cnVlO1xuXHQgIHZhciBzdGFydEluZGV4ID0gdHlwZW9mIG9wdGlvbnMuaW5kZXggPT09ICdudW1iZXInID8gb3B0aW9ucy5pbmRleCA6IDA7IC8vIEF0dGVtcHQgdG8gc2VyaWFsaXplXG5cblx0ICB2YXIgc2VyaWFsaXphdGlvbkluZGV4ID0gc2VyaWFsaXplcihidWZmZXIkMSwgb2JqZWN0LCBjaGVja0tleXMsIDAsIDAsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgaWdub3JlVW5kZWZpbmVkKTtcblx0ICBidWZmZXIkMS5jb3B5KGZpbmFsQnVmZmVyLCBzdGFydEluZGV4LCAwLCBzZXJpYWxpemF0aW9uSW5kZXgpOyAvLyBSZXR1cm4gdGhlIGluZGV4XG5cblx0ICByZXR1cm4gc3RhcnRJbmRleCArIHNlcmlhbGl6YXRpb25JbmRleCAtIDE7XG5cdH1cblx0LyoqXG5cdCAqIERlc2VyaWFsaXplIGRhdGEgYXMgQlNPTi5cblx0ICpcblx0ICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciB0aGUgYnVmZmVyIGNvbnRhaW5pbmcgdGhlIHNlcmlhbGl6ZWQgc2V0IG9mIEJTT04gZG9jdW1lbnRzLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZXZhbEZ1bmN0aW9ucz1mYWxzZV0gZXZhbHVhdGUgZnVuY3Rpb25zIGluIHRoZSBCU09OIGRvY3VtZW50IHNjb3BlZCB0byB0aGUgb2JqZWN0IGRlc2VyaWFsaXplZC5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmNhY2hlRnVuY3Rpb25zPWZhbHNlXSBjYWNoZSBldmFsdWF0ZWQgZnVuY3Rpb25zIGZvciByZXVzZS5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmNhY2hlRnVuY3Rpb25zQ3JjMzI9ZmFsc2VdIHVzZSBhIGNyYzMyIGNvZGUgZm9yIGNhY2hpbmcsIG90aGVyd2lzZSB1c2UgdGhlIHN0cmluZyBvZiB0aGUgZnVuY3Rpb24uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5wcm9tb3RlTG9uZ3M9dHJ1ZV0gd2hlbiBkZXNlcmlhbGl6aW5nIGEgTG9uZyB3aWxsIGZpdCBpdCBpbnRvIGEgTnVtYmVyIGlmIGl0J3Mgc21hbGxlciB0aGFuIDUzIGJpdHNcblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnByb21vdGVCdWZmZXJzPWZhbHNlXSB3aGVuIGRlc2VyaWFsaXppbmcgYSBCaW5hcnkgd2lsbCByZXR1cm4gaXQgYXMgYSBub2RlLmpzIEJ1ZmZlciBpbnN0YW5jZS5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnByb21vdGVWYWx1ZXM9ZmFsc2VdIHdoZW4gZGVzZXJpYWxpemluZyB3aWxsIHByb21vdGUgQlNPTiB2YWx1ZXMgdG8gdGhlaXIgTm9kZS5qcyBjbG9zZXN0IGVxdWl2YWxlbnQgdHlwZXMuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5maWVsZHNBc1Jhdz1udWxsXSBhbGxvdyB0byBzcGVjaWZ5IGlmIHRoZXJlIHdoYXQgZmllbGRzIHdlIHdpc2ggdG8gcmV0dXJuIGFzIHVuc2VyaWFsaXplZCByYXcgYnVmZmVyLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYnNvblJlZ0V4cD1mYWxzZV0gcmV0dXJuIEJTT04gcmVndWxhciBleHByZXNzaW9ucyBhcyBCU09OUmVnRXhwIGluc3RhbmNlcy5cblx0ICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hbGxvd09iamVjdFNtYWxsZXJUaGFuQnVmZmVyU2l6ZT1mYWxzZV0gYWxsb3dzIHRoZSBidWZmZXIgdG8gYmUgbGFyZ2VyIHRoYW4gdGhlIHBhcnNlZCBCU09OIG9iamVjdFxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IHJldHVybnMgdGhlIGRlc2VyaWFsaXplZCBKYXZhc2NyaXB0IE9iamVjdC5cblx0ICovXG5cblxuXHRmdW5jdGlvbiBkZXNlcmlhbGl6ZSQyKGJ1ZmZlciQkMSwgb3B0aW9ucykge1xuXHQgIGJ1ZmZlciQkMSA9IGVuc3VyZV9idWZmZXIoYnVmZmVyJCQxKTtcblx0ICByZXR1cm4gZGVzZXJpYWxpemVyKGJ1ZmZlciQkMSwgb3B0aW9ucyk7XG5cdH1cblx0LyoqXG5cdCAqIENhbGN1bGF0ZSB0aGUgYnNvbiBzaXplIGZvciBhIHBhc3NlZCBpbiBKYXZhc2NyaXB0IG9iamVjdC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0aGUgSmF2YXNjcmlwdCBvYmplY3QgdG8gY2FsY3VsYXRlIHRoZSBCU09OIGJ5dGUgc2l6ZSBmb3IuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2VyaWFsaXplRnVuY3Rpb25zPWZhbHNlXSBzZXJpYWxpemUgdGhlIGphdmFzY3JpcHQgZnVuY3Rpb25zICoqKGRlZmF1bHQ6ZmFsc2UpKiouXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaWdub3JlVW5kZWZpbmVkPXRydWVdIGlnbm9yZSB1bmRlZmluZWQgZmllbGRzICoqKGRlZmF1bHQ6dHJ1ZSkqKi5cblx0ICogQHJldHVybiB7TnVtYmVyfSByZXR1cm5zIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIEJTT04gb2JqZWN0IHdpbGwgdGFrZSB1cC5cblx0ICovXG5cblxuXHRmdW5jdGlvbiBjYWxjdWxhdGVPYmplY3RTaXplJDEob2JqZWN0LCBvcHRpb25zKSB7XG5cdCAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdCAgdmFyIHNlcmlhbGl6ZUZ1bmN0aW9ucyA9IHR5cGVvZiBvcHRpb25zLnNlcmlhbGl6ZUZ1bmN0aW9ucyA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5zZXJpYWxpemVGdW5jdGlvbnMgOiBmYWxzZTtcblx0ICB2YXIgaWdub3JlVW5kZWZpbmVkID0gdHlwZW9mIG9wdGlvbnMuaWdub3JlVW5kZWZpbmVkID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmlnbm9yZVVuZGVmaW5lZCA6IHRydWU7XG5cdCAgcmV0dXJuIGNhbGN1bGF0ZV9zaXplKG9iamVjdCwgc2VyaWFsaXplRnVuY3Rpb25zLCBpZ25vcmVVbmRlZmluZWQpO1xuXHR9XG5cdC8qKlxuXHQgKiBEZXNlcmlhbGl6ZSBzdHJlYW0gZGF0YSBhcyBCU09OIGRvY3VtZW50cy5cblx0ICpcblx0ICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgdGhlIGJ1ZmZlciBjb250YWluaW5nIHRoZSBzZXJpYWxpemVkIHNldCBvZiBCU09OIGRvY3VtZW50cy5cblx0ICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0SW5kZXggdGhlIHN0YXJ0IGluZGV4IGluIHRoZSBkYXRhIEJ1ZmZlciB3aGVyZSB0aGUgZGVzZXJpYWxpemF0aW9uIGlzIHRvIHN0YXJ0LlxuXHQgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyT2ZEb2N1bWVudHMgbnVtYmVyIG9mIGRvY3VtZW50cyB0byBkZXNlcmlhbGl6ZS5cblx0ICogQHBhcmFtIHtBcnJheX0gZG9jdW1lbnRzIGFuIGFycmF5IHdoZXJlIHRvIHN0b3JlIHRoZSBkZXNlcmlhbGl6ZWQgZG9jdW1lbnRzLlxuXHQgKiBAcGFyYW0ge051bWJlcn0gZG9jU3RhcnRJbmRleCB0aGUgaW5kZXggaW4gdGhlIGRvY3VtZW50cyBhcnJheSBmcm9tIHdoZXJlIHRvIHN0YXJ0IGluc2VydGluZyBkb2N1bWVudHMuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gYWRkaXRpb25hbCBvcHRpb25zIHVzZWQgZm9yIHRoZSBkZXNlcmlhbGl6YXRpb24uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5ldmFsRnVuY3Rpb25zPWZhbHNlXSBldmFsdWF0ZSBmdW5jdGlvbnMgaW4gdGhlIEJTT04gZG9jdW1lbnQgc2NvcGVkIHRvIHRoZSBvYmplY3QgZGVzZXJpYWxpemVkLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuY2FjaGVGdW5jdGlvbnM9ZmFsc2VdIGNhY2hlIGV2YWx1YXRlZCBmdW5jdGlvbnMgZm9yIHJldXNlLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuY2FjaGVGdW5jdGlvbnNDcmMzMj1mYWxzZV0gdXNlIGEgY3JjMzIgY29kZSBmb3IgY2FjaGluZywgb3RoZXJ3aXNlIHVzZSB0aGUgc3RyaW5nIG9mIHRoZSBmdW5jdGlvbi5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnByb21vdGVMb25ncz10cnVlXSB3aGVuIGRlc2VyaWFsaXppbmcgYSBMb25nIHdpbGwgZml0IGl0IGludG8gYSBOdW1iZXIgaWYgaXQncyBzbWFsbGVyIHRoYW4gNTMgYml0c1xuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucHJvbW90ZUJ1ZmZlcnM9ZmFsc2VdIHdoZW4gZGVzZXJpYWxpemluZyBhIEJpbmFyeSB3aWxsIHJldHVybiBpdCBhcyBhIG5vZGUuanMgQnVmZmVyIGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucHJvbW90ZVZhbHVlcz1mYWxzZV0gd2hlbiBkZXNlcmlhbGl6aW5nIHdpbGwgcHJvbW90ZSBCU09OIHZhbHVlcyB0byB0aGVpciBOb2RlLmpzIGNsb3Nlc3QgZXF1aXZhbGVudCB0eXBlcy5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmZpZWxkc0FzUmF3PW51bGxdIGFsbG93IHRvIHNwZWNpZnkgaWYgdGhlcmUgd2hhdCBmaWVsZHMgd2Ugd2lzaCB0byByZXR1cm4gYXMgdW5zZXJpYWxpemVkIHJhdyBidWZmZXIuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5ic29uUmVnRXhwPWZhbHNlXSByZXR1cm4gQlNPTiByZWd1bGFyIGV4cHJlc3Npb25zIGFzIEJTT05SZWdFeHAgaW5zdGFuY2VzLlxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IHJldHVybnMgdGhlIG5leHQgaW5kZXggaW4gdGhlIGJ1ZmZlciBhZnRlciBkZXNlcmlhbGl6YXRpb24gKip4KiogbnVtYmVycyBvZiBkb2N1bWVudHMuXG5cdCAqL1xuXG5cblx0ZnVuY3Rpb24gZGVzZXJpYWxpemVTdHJlYW0oZGF0YSwgc3RhcnRJbmRleCwgbnVtYmVyT2ZEb2N1bWVudHMsIGRvY3VtZW50cywgZG9jU3RhcnRJbmRleCwgb3B0aW9ucykge1xuXHQgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcblx0ICAgIGFsbG93T2JqZWN0U21hbGxlclRoYW5CdWZmZXJTaXplOiB0cnVlXG5cdCAgfSwgb3B0aW9ucyk7XG5cdCAgZGF0YSA9IGVuc3VyZV9idWZmZXIoZGF0YSk7XG5cdCAgdmFyIGluZGV4ID0gc3RhcnRJbmRleDsgLy8gTG9vcCBvdmVyIGFsbCBkb2N1bWVudHNcblxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtYmVyT2ZEb2N1bWVudHM7IGkrKykge1xuXHQgICAgLy8gRmluZCBzaXplIG9mIHRoZSBkb2N1bWVudFxuXHQgICAgdmFyIHNpemUgPSBkYXRhW2luZGV4XSB8IGRhdGFbaW5kZXggKyAxXSA8PCA4IHwgZGF0YVtpbmRleCArIDJdIDw8IDE2IHwgZGF0YVtpbmRleCArIDNdIDw8IDI0OyAvLyBVcGRhdGUgb3B0aW9ucyB3aXRoIGluZGV4XG5cblx0ICAgIG9wdGlvbnMuaW5kZXggPSBpbmRleDsgLy8gUGFyc2UgdGhlIGRvY3VtZW50IGF0IHRoaXMgcG9pbnRcblxuXHQgICAgZG9jdW1lbnRzW2RvY1N0YXJ0SW5kZXggKyBpXSA9IGRlc2VyaWFsaXplcihkYXRhLCBvcHRpb25zKTsgLy8gQWRqdXN0IGluZGV4IGJ5IHRoZSBkb2N1bWVudCBzaXplXG5cblx0ICAgIGluZGV4ID0gaW5kZXggKyBzaXplO1xuXHQgIH0gLy8gUmV0dXJuIG9iamVjdCBjb250YWluaW5nIGVuZCBpbmRleCBvZiBwYXJzaW5nIGFuZCBsaXN0IG9mIGRvY3VtZW50c1xuXG5cblx0ICByZXR1cm4gaW5kZXg7XG5cdH1cblxuXHR2YXIgYnNvbiA9IHtcblx0ICAvLyBjb25zdGFudHNcblx0ICAvLyBOT1RFOiB0aGlzIGlzIGRvbmUgdGhpcyB3YXkgYmVjYXVzZSByb2xsdXAgY2FuJ3QgcmVzb2x2ZSBhbiBgT2JqZWN0LmFzc2lnbmBlZCBleHBvcnRcblx0ICBCU09OX0lOVDMyX01BWDogY29uc3RhbnRzLkJTT05fSU5UMzJfTUFYLFxuXHQgIEJTT05fSU5UMzJfTUlOOiBjb25zdGFudHMuQlNPTl9JTlQzMl9NSU4sXG5cdCAgQlNPTl9JTlQ2NF9NQVg6IGNvbnN0YW50cy5CU09OX0lOVDY0X01BWCxcblx0ICBCU09OX0lOVDY0X01JTjogY29uc3RhbnRzLkJTT05fSU5UNjRfTUlOLFxuXHQgIEpTX0lOVF9NQVg6IGNvbnN0YW50cy5KU19JTlRfTUFYLFxuXHQgIEpTX0lOVF9NSU46IGNvbnN0YW50cy5KU19JTlRfTUlOLFxuXHQgIEJTT05fREFUQV9OVU1CRVI6IGNvbnN0YW50cy5CU09OX0RBVEFfTlVNQkVSLFxuXHQgIEJTT05fREFUQV9TVFJJTkc6IGNvbnN0YW50cy5CU09OX0RBVEFfU1RSSU5HLFxuXHQgIEJTT05fREFUQV9PQkpFQ1Q6IGNvbnN0YW50cy5CU09OX0RBVEFfT0JKRUNULFxuXHQgIEJTT05fREFUQV9BUlJBWTogY29uc3RhbnRzLkJTT05fREFUQV9BUlJBWSxcblx0ICBCU09OX0RBVEFfQklOQVJZOiBjb25zdGFudHMuQlNPTl9EQVRBX0JJTkFSWSxcblx0ICBCU09OX0RBVEFfVU5ERUZJTkVEOiBjb25zdGFudHMuQlNPTl9EQVRBX1VOREVGSU5FRCxcblx0ICBCU09OX0RBVEFfT0lEOiBjb25zdGFudHMuQlNPTl9EQVRBX09JRCxcblx0ICBCU09OX0RBVEFfQk9PTEVBTjogY29uc3RhbnRzLkJTT05fREFUQV9CT09MRUFOLFxuXHQgIEJTT05fREFUQV9EQVRFOiBjb25zdGFudHMuQlNPTl9EQVRBX0RBVEUsXG5cdCAgQlNPTl9EQVRBX05VTEw6IGNvbnN0YW50cy5CU09OX0RBVEFfTlVMTCxcblx0ICBCU09OX0RBVEFfUkVHRVhQOiBjb25zdGFudHMuQlNPTl9EQVRBX1JFR0VYUCxcblx0ICBCU09OX0RBVEFfREJQT0lOVEVSOiBjb25zdGFudHMuQlNPTl9EQVRBX0RCUE9JTlRFUixcblx0ICBCU09OX0RBVEFfQ09ERTogY29uc3RhbnRzLkJTT05fREFUQV9DT0RFLFxuXHQgIEJTT05fREFUQV9TWU1CT0w6IGNvbnN0YW50cy5CU09OX0RBVEFfU1lNQk9MLFxuXHQgIEJTT05fREFUQV9DT0RFX1dfU0NPUEU6IGNvbnN0YW50cy5CU09OX0RBVEFfQ09ERV9XX1NDT1BFLFxuXHQgIEJTT05fREFUQV9JTlQ6IGNvbnN0YW50cy5CU09OX0RBVEFfSU5ULFxuXHQgIEJTT05fREFUQV9USU1FU1RBTVA6IGNvbnN0YW50cy5CU09OX0RBVEFfVElNRVNUQU1QLFxuXHQgIEJTT05fREFUQV9MT05HOiBjb25zdGFudHMuQlNPTl9EQVRBX0xPTkcsXG5cdCAgQlNPTl9EQVRBX0RFQ0lNQUwxMjg6IGNvbnN0YW50cy5CU09OX0RBVEFfREVDSU1BTDEyOCxcblx0ICBCU09OX0RBVEFfTUlOX0tFWTogY29uc3RhbnRzLkJTT05fREFUQV9NSU5fS0VZLFxuXHQgIEJTT05fREFUQV9NQVhfS0VZOiBjb25zdGFudHMuQlNPTl9EQVRBX01BWF9LRVksXG5cdCAgQlNPTl9CSU5BUllfU1VCVFlQRV9ERUZBVUxUOiBjb25zdGFudHMuQlNPTl9CSU5BUllfU1VCVFlQRV9ERUZBVUxULFxuXHQgIEJTT05fQklOQVJZX1NVQlRZUEVfRlVOQ1RJT046IGNvbnN0YW50cy5CU09OX0JJTkFSWV9TVUJUWVBFX0ZVTkNUSU9OLFxuXHQgIEJTT05fQklOQVJZX1NVQlRZUEVfQllURV9BUlJBWTogY29uc3RhbnRzLkJTT05fQklOQVJZX1NVQlRZUEVfQllURV9BUlJBWSxcblx0ICBCU09OX0JJTkFSWV9TVUJUWVBFX1VVSUQ6IGNvbnN0YW50cy5CU09OX0JJTkFSWV9TVUJUWVBFX1VVSUQsXG5cdCAgQlNPTl9CSU5BUllfU1VCVFlQRV9NRDU6IGNvbnN0YW50cy5CU09OX0JJTkFSWV9TVUJUWVBFX01ENSxcblx0ICBCU09OX0JJTkFSWV9TVUJUWVBFX1VTRVJfREVGSU5FRDogY29uc3RhbnRzLkJTT05fQklOQVJZX1NVQlRZUEVfVVNFUl9ERUZJTkVELFxuXHQgIC8vIHdyYXBwZWQgdHlwZXNcblx0ICBDb2RlOiBjb2RlLFxuXHQgIE1hcDogbWFwLFxuXHQgIEJTT05TeW1ib2w6IHN5bWJvbCxcblx0ICBEQlJlZjogZGJfcmVmLFxuXHQgIEJpbmFyeTogYmluYXJ5LFxuXHQgIE9iamVjdElkOiBvYmplY3RpZCxcblx0ICBMb25nOiBsb25nXzEsXG5cdCAgVGltZXN0YW1wOiB0aW1lc3RhbXAsXG5cdCAgRG91YmxlOiBkb3VibGVfMSxcblx0ICBJbnQzMjogaW50XzMyLFxuXHQgIE1pbktleTogbWluX2tleSxcblx0ICBNYXhLZXk6IG1heF9rZXksXG5cdCAgQlNPTlJlZ0V4cDogcmVnZXhwLFxuXHQgIERlY2ltYWwxMjg6IGRlY2ltYWwxMjgsXG5cdCAgLy8gbWV0aG9kc1xuXHQgIHNlcmlhbGl6ZTogc2VyaWFsaXplJDEsXG5cdCAgc2VyaWFsaXplV2l0aEJ1ZmZlckFuZEluZGV4OiBzZXJpYWxpemVXaXRoQnVmZmVyQW5kSW5kZXgsXG5cdCAgZGVzZXJpYWxpemU6IGRlc2VyaWFsaXplJDIsXG5cdCAgY2FsY3VsYXRlT2JqZWN0U2l6ZTogY2FsY3VsYXRlT2JqZWN0U2l6ZSQxLFxuXHQgIGRlc2VyaWFsaXplU3RyZWFtOiBkZXNlcmlhbGl6ZVN0cmVhbSxcblx0ICBzZXRJbnRlcm5hbEJ1ZmZlclNpemU6IHNldEludGVybmFsQnVmZmVyU2l6ZSxcblx0ICAvLyBsZWdhY3kgc3VwcG9ydFxuXHQgIE9iamVjdElEOiBvYmplY3RpZCxcblx0ICAvLyBFeHRlbmRlZCBKU09OXG5cdCAgRUpTT046IGV4dGVuZGVkX2pzb25cblx0fTtcblx0dmFyIGJzb25fMSA9IGJzb24uQlNPTl9JTlQzMl9NQVg7XG5cdHZhciBic29uXzIgPSBic29uLkJTT05fSU5UMzJfTUlOO1xuXHR2YXIgYnNvbl8zID0gYnNvbi5CU09OX0lOVDY0X01BWDtcblx0dmFyIGJzb25fNCA9IGJzb24uQlNPTl9JTlQ2NF9NSU47XG5cdHZhciBic29uXzUgPSBic29uLkpTX0lOVF9NQVg7XG5cdHZhciBic29uXzYgPSBic29uLkpTX0lOVF9NSU47XG5cdHZhciBic29uXzcgPSBic29uLkJTT05fREFUQV9OVU1CRVI7XG5cdHZhciBic29uXzggPSBic29uLkJTT05fREFUQV9TVFJJTkc7XG5cdHZhciBic29uXzkgPSBic29uLkJTT05fREFUQV9PQkpFQ1Q7XG5cdHZhciBic29uXzEwID0gYnNvbi5CU09OX0RBVEFfQVJSQVk7XG5cdHZhciBic29uXzExID0gYnNvbi5CU09OX0RBVEFfQklOQVJZO1xuXHR2YXIgYnNvbl8xMiA9IGJzb24uQlNPTl9EQVRBX1VOREVGSU5FRDtcblx0dmFyIGJzb25fMTMgPSBic29uLkJTT05fREFUQV9PSUQ7XG5cdHZhciBic29uXzE0ID0gYnNvbi5CU09OX0RBVEFfQk9PTEVBTjtcblx0dmFyIGJzb25fMTUgPSBic29uLkJTT05fREFUQV9EQVRFO1xuXHR2YXIgYnNvbl8xNiA9IGJzb24uQlNPTl9EQVRBX05VTEw7XG5cdHZhciBic29uXzE3ID0gYnNvbi5CU09OX0RBVEFfUkVHRVhQO1xuXHR2YXIgYnNvbl8xOCA9IGJzb24uQlNPTl9EQVRBX0RCUE9JTlRFUjtcblx0dmFyIGJzb25fMTkgPSBic29uLkJTT05fREFUQV9DT0RFO1xuXHR2YXIgYnNvbl8yMCA9IGJzb24uQlNPTl9EQVRBX1NZTUJPTDtcblx0dmFyIGJzb25fMjEgPSBic29uLkJTT05fREFUQV9DT0RFX1dfU0NPUEU7XG5cdHZhciBic29uXzIyID0gYnNvbi5CU09OX0RBVEFfSU5UO1xuXHR2YXIgYnNvbl8yMyA9IGJzb24uQlNPTl9EQVRBX1RJTUVTVEFNUDtcblx0dmFyIGJzb25fMjQgPSBic29uLkJTT05fREFUQV9MT05HO1xuXHR2YXIgYnNvbl8yNSA9IGJzb24uQlNPTl9EQVRBX0RFQ0lNQUwxMjg7XG5cdHZhciBic29uXzI2ID0gYnNvbi5CU09OX0RBVEFfTUlOX0tFWTtcblx0dmFyIGJzb25fMjcgPSBic29uLkJTT05fREFUQV9NQVhfS0VZO1xuXHR2YXIgYnNvbl8yOCA9IGJzb24uQlNPTl9CSU5BUllfU1VCVFlQRV9ERUZBVUxUO1xuXHR2YXIgYnNvbl8yOSA9IGJzb24uQlNPTl9CSU5BUllfU1VCVFlQRV9GVU5DVElPTjtcblx0dmFyIGJzb25fMzAgPSBic29uLkJTT05fQklOQVJZX1NVQlRZUEVfQllURV9BUlJBWTtcblx0dmFyIGJzb25fMzEgPSBic29uLkJTT05fQklOQVJZX1NVQlRZUEVfVVVJRDtcblx0dmFyIGJzb25fMzIgPSBic29uLkJTT05fQklOQVJZX1NVQlRZUEVfTUQ1O1xuXHR2YXIgYnNvbl8zMyA9IGJzb24uQlNPTl9CSU5BUllfU1VCVFlQRV9VU0VSX0RFRklORUQ7XG5cdHZhciBic29uXzM0ID0gYnNvbi5Db2RlO1xuXHR2YXIgYnNvbl8zNSA9IGJzb24uQlNPTlN5bWJvbDtcblx0dmFyIGJzb25fMzYgPSBic29uLkRCUmVmO1xuXHR2YXIgYnNvbl8zNyA9IGJzb24uQmluYXJ5O1xuXHR2YXIgYnNvbl8zOCA9IGJzb24uT2JqZWN0SWQ7XG5cdHZhciBic29uXzM5ID0gYnNvbi5Mb25nO1xuXHR2YXIgYnNvbl80MCA9IGJzb24uVGltZXN0YW1wO1xuXHR2YXIgYnNvbl80MSA9IGJzb24uRG91YmxlO1xuXHR2YXIgYnNvbl80MiA9IGJzb24uSW50MzI7XG5cdHZhciBic29uXzQzID0gYnNvbi5NaW5LZXk7XG5cdHZhciBic29uXzQ0ID0gYnNvbi5NYXhLZXk7XG5cdHZhciBic29uXzQ1ID0gYnNvbi5CU09OUmVnRXhwO1xuXHR2YXIgYnNvbl80NiA9IGJzb24uRGVjaW1hbDEyODtcblx0dmFyIGJzb25fNDcgPSBic29uLnNlcmlhbGl6ZTtcblx0dmFyIGJzb25fNDggPSBic29uLnNlcmlhbGl6ZVdpdGhCdWZmZXJBbmRJbmRleDtcblx0dmFyIGJzb25fNDkgPSBic29uLmRlc2VyaWFsaXplO1xuXHR2YXIgYnNvbl81MCA9IGJzb24uY2FsY3VsYXRlT2JqZWN0U2l6ZTtcblx0dmFyIGJzb25fNTEgPSBic29uLmRlc2VyaWFsaXplU3RyZWFtO1xuXHR2YXIgYnNvbl81MiA9IGJzb24uc2V0SW50ZXJuYWxCdWZmZXJTaXplO1xuXHR2YXIgYnNvbl81MyA9IGJzb24uT2JqZWN0SUQ7XG5cdHZhciBic29uXzU0ID0gYnNvbi5FSlNPTjtcblxuXHRleHBvcnRzLmRlZmF1bHQgPSBic29uO1xuXHRleHBvcnRzLkJTT05fSU5UMzJfTUFYID0gYnNvbl8xO1xuXHRleHBvcnRzLkJTT05fSU5UMzJfTUlOID0gYnNvbl8yO1xuXHRleHBvcnRzLkJTT05fSU5UNjRfTUFYID0gYnNvbl8zO1xuXHRleHBvcnRzLkJTT05fSU5UNjRfTUlOID0gYnNvbl80O1xuXHRleHBvcnRzLkpTX0lOVF9NQVggPSBic29uXzU7XG5cdGV4cG9ydHMuSlNfSU5UX01JTiA9IGJzb25fNjtcblx0ZXhwb3J0cy5CU09OX0RBVEFfTlVNQkVSID0gYnNvbl83O1xuXHRleHBvcnRzLkJTT05fREFUQV9TVFJJTkcgPSBic29uXzg7XG5cdGV4cG9ydHMuQlNPTl9EQVRBX09CSkVDVCA9IGJzb25fOTtcblx0ZXhwb3J0cy5CU09OX0RBVEFfQVJSQVkgPSBic29uXzEwO1xuXHRleHBvcnRzLkJTT05fREFUQV9CSU5BUlkgPSBic29uXzExO1xuXHRleHBvcnRzLkJTT05fREFUQV9VTkRFRklORUQgPSBic29uXzEyO1xuXHRleHBvcnRzLkJTT05fREFUQV9PSUQgPSBic29uXzEzO1xuXHRleHBvcnRzLkJTT05fREFUQV9CT09MRUFOID0gYnNvbl8xNDtcblx0ZXhwb3J0cy5CU09OX0RBVEFfREFURSA9IGJzb25fMTU7XG5cdGV4cG9ydHMuQlNPTl9EQVRBX05VTEwgPSBic29uXzE2O1xuXHRleHBvcnRzLkJTT05fREFUQV9SRUdFWFAgPSBic29uXzE3O1xuXHRleHBvcnRzLkJTT05fREFUQV9EQlBPSU5URVIgPSBic29uXzE4O1xuXHRleHBvcnRzLkJTT05fREFUQV9DT0RFID0gYnNvbl8xOTtcblx0ZXhwb3J0cy5CU09OX0RBVEFfU1lNQk9MID0gYnNvbl8yMDtcblx0ZXhwb3J0cy5CU09OX0RBVEFfQ09ERV9XX1NDT1BFID0gYnNvbl8yMTtcblx0ZXhwb3J0cy5CU09OX0RBVEFfSU5UID0gYnNvbl8yMjtcblx0ZXhwb3J0cy5CU09OX0RBVEFfVElNRVNUQU1QID0gYnNvbl8yMztcblx0ZXhwb3J0cy5CU09OX0RBVEFfTE9ORyA9IGJzb25fMjQ7XG5cdGV4cG9ydHMuQlNPTl9EQVRBX0RFQ0lNQUwxMjggPSBic29uXzI1O1xuXHRleHBvcnRzLkJTT05fREFUQV9NSU5fS0VZID0gYnNvbl8yNjtcblx0ZXhwb3J0cy5CU09OX0RBVEFfTUFYX0tFWSA9IGJzb25fMjc7XG5cdGV4cG9ydHMuQlNPTl9CSU5BUllfU1VCVFlQRV9ERUZBVUxUID0gYnNvbl8yODtcblx0ZXhwb3J0cy5CU09OX0JJTkFSWV9TVUJUWVBFX0ZVTkNUSU9OID0gYnNvbl8yOTtcblx0ZXhwb3J0cy5CU09OX0JJTkFSWV9TVUJUWVBFX0JZVEVfQVJSQVkgPSBic29uXzMwO1xuXHRleHBvcnRzLkJTT05fQklOQVJZX1NVQlRZUEVfVVVJRCA9IGJzb25fMzE7XG5cdGV4cG9ydHMuQlNPTl9CSU5BUllfU1VCVFlQRV9NRDUgPSBic29uXzMyO1xuXHRleHBvcnRzLkJTT05fQklOQVJZX1NVQlRZUEVfVVNFUl9ERUZJTkVEID0gYnNvbl8zMztcblx0ZXhwb3J0cy5Db2RlID0gYnNvbl8zNDtcblx0ZXhwb3J0cy5CU09OU3ltYm9sID0gYnNvbl8zNTtcblx0ZXhwb3J0cy5EQlJlZiA9IGJzb25fMzY7XG5cdGV4cG9ydHMuQmluYXJ5ID0gYnNvbl8zNztcblx0ZXhwb3J0cy5PYmplY3RJZCA9IGJzb25fMzg7XG5cdGV4cG9ydHMuTG9uZyA9IGJzb25fMzk7XG5cdGV4cG9ydHMuVGltZXN0YW1wID0gYnNvbl80MDtcblx0ZXhwb3J0cy5Eb3VibGUgPSBic29uXzQxO1xuXHRleHBvcnRzLkludDMyID0gYnNvbl80Mjtcblx0ZXhwb3J0cy5NaW5LZXkgPSBic29uXzQzO1xuXHRleHBvcnRzLk1heEtleSA9IGJzb25fNDQ7XG5cdGV4cG9ydHMuQlNPTlJlZ0V4cCA9IGJzb25fNDU7XG5cdGV4cG9ydHMuRGVjaW1hbDEyOCA9IGJzb25fNDY7XG5cdGV4cG9ydHMuc2VyaWFsaXplID0gYnNvbl80Nztcblx0ZXhwb3J0cy5zZXJpYWxpemVXaXRoQnVmZmVyQW5kSW5kZXggPSBic29uXzQ4O1xuXHRleHBvcnRzLmRlc2VyaWFsaXplID0gYnNvbl80OTtcblx0ZXhwb3J0cy5jYWxjdWxhdGVPYmplY3RTaXplID0gYnNvbl81MDtcblx0ZXhwb3J0cy5kZXNlcmlhbGl6ZVN0cmVhbSA9IGJzb25fNTE7XG5cdGV4cG9ydHMuc2V0SW50ZXJuYWxCdWZmZXJTaXplID0gYnNvbl81Mjtcblx0ZXhwb3J0cy5PYmplY3RJRCA9IGJzb25fNTM7XG5cdGV4cG9ydHMuRUpTT04gPSBic29uXzU0O1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpLkJ1ZmZlcikpXG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayhcbiAgICAgIHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aClcbiAgICApKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG5cblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cblxuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gTG9uZztcclxuXHJcbi8qKlxyXG4gKiB3YXNtIG9wdGltaXphdGlvbnMsIHRvIGRvIG5hdGl2ZSBpNjQgbXVsdGlwbGljYXRpb24gYW5kIGRpdmlkZVxyXG4gKi9cclxudmFyIHdhc20gPSBudWxsO1xyXG5cclxudHJ5IHtcclxuICB3YXNtID0gbmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKG5ldyBXZWJBc3NlbWJseS5Nb2R1bGUobmV3IFVpbnQ4QXJyYXkoW1xyXG4gICAgMCwgOTcsIDExNSwgMTA5LCAxLCAwLCAwLCAwLCAxLCAxMywgMiwgOTYsIDAsIDEsIDEyNywgOTYsIDQsIDEyNywgMTI3LCAxMjcsIDEyNywgMSwgMTI3LCAzLCA3LCA2LCAwLCAxLCAxLCAxLCAxLCAxLCA2LCA2LCAxLCAxMjcsIDEsIDY1LCAwLCAxMSwgNywgNTAsIDYsIDMsIDEwOSwgMTE3LCAxMDgsIDAsIDEsIDUsIDEwMCwgMTA1LCAxMTgsIDk1LCAxMTUsIDAsIDIsIDUsIDEwMCwgMTA1LCAxMTgsIDk1LCAxMTcsIDAsIDMsIDUsIDExNCwgMTAxLCAxMDksIDk1LCAxMTUsIDAsIDQsIDUsIDExNCwgMTAxLCAxMDksIDk1LCAxMTcsIDAsIDUsIDgsIDEwMywgMTAxLCAxMTYsIDk1LCAxMDQsIDEwNSwgMTAzLCAxMDQsIDAsIDAsIDEwLCAxOTEsIDEsIDYsIDQsIDAsIDM1LCAwLCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI2LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjcsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyOCwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI5LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMzAsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTFcclxuICBdKSksIHt9KS5leHBvcnRzO1xyXG59IGNhdGNoIChlKSB7XHJcbiAgLy8gbm8gd2FzbSBzdXBwb3J0IDooXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgNjQgYml0IHR3bydzLWNvbXBsZW1lbnQgaW50ZWdlciwgZ2l2ZW4gaXRzIGxvdyBhbmQgaGlnaCAzMiBiaXQgdmFsdWVzIGFzICpzaWduZWQqIGludGVnZXJzLlxyXG4gKiAgU2VlIHRoZSBmcm9tKiBmdW5jdGlvbnMgYmVsb3cgZm9yIG1vcmUgY29udmVuaWVudCB3YXlzIG9mIGNvbnN0cnVjdGluZyBMb25ncy5cclxuICogQGV4cG9ydHMgTG9uZ1xyXG4gKiBAY2xhc3MgQSBMb25nIGNsYXNzIGZvciByZXByZXNlbnRpbmcgYSA2NCBiaXQgdHdvJ3MtY29tcGxlbWVudCBpbnRlZ2VyIHZhbHVlLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gbG93IFRoZSBsb3cgKHNpZ25lZCkgMzIgYml0cyBvZiB0aGUgbG9uZ1xyXG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaCBUaGUgaGlnaCAoc2lnbmVkKSAzMiBiaXRzIG9mIHRoZSBsb25nXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBMb25nKGxvdywgaGlnaCwgdW5zaWduZWQpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBsb3cgMzIgYml0cyBhcyBhIHNpZ25lZCB2YWx1ZS5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubG93ID0gbG93IHwgMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBoaWdoIDMyIGJpdHMgYXMgYSBzaWduZWQgdmFsdWUuXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmhpZ2ggPSBoaWdoIHwgMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMudW5zaWduZWQgPSAhIXVuc2lnbmVkO1xyXG59XHJcblxyXG4vLyBUaGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYSBsb25nIGlzIHRoZSB0d28gZ2l2ZW4gc2lnbmVkLCAzMi1iaXQgdmFsdWVzLlxyXG4vLyBXZSB1c2UgMzItYml0IHBpZWNlcyBiZWNhdXNlIHRoZXNlIGFyZSB0aGUgc2l6ZSBvZiBpbnRlZ2VycyBvbiB3aGljaFxyXG4vLyBKYXZhc2NyaXB0IHBlcmZvcm1zIGJpdC1vcGVyYXRpb25zLiAgRm9yIG9wZXJhdGlvbnMgbGlrZSBhZGRpdGlvbiBhbmRcclxuLy8gbXVsdGlwbGljYXRpb24sIHdlIHNwbGl0IGVhY2ggbnVtYmVyIGludG8gMTYgYml0IHBpZWNlcywgd2hpY2ggY2FuIGVhc2lseSBiZVxyXG4vLyBtdWx0aXBsaWVkIHdpdGhpbiBKYXZhc2NyaXB0J3MgZmxvYXRpbmctcG9pbnQgcmVwcmVzZW50YXRpb24gd2l0aG91dCBvdmVyZmxvd1xyXG4vLyBvciBjaGFuZ2UgaW4gc2lnbi5cclxuLy9cclxuLy8gSW4gdGhlIGFsZ29yaXRobXMgYmVsb3csIHdlIGZyZXF1ZW50bHkgcmVkdWNlIHRoZSBuZWdhdGl2ZSBjYXNlIHRvIHRoZVxyXG4vLyBwb3NpdGl2ZSBjYXNlIGJ5IG5lZ2F0aW5nIHRoZSBpbnB1dChzKSBhbmQgdGhlbiBwb3N0LXByb2Nlc3NpbmcgdGhlIHJlc3VsdC5cclxuLy8gTm90ZSB0aGF0IHdlIG11c3QgQUxXQVlTIGNoZWNrIHNwZWNpYWxseSB3aGV0aGVyIHRob3NlIHZhbHVlcyBhcmUgTUlOX1ZBTFVFXHJcbi8vICgtMl42MykgYmVjYXVzZSAtTUlOX1ZBTFVFID09IE1JTl9WQUxVRSAoc2luY2UgMl42MyBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgYXNcclxuLy8gYSBwb3NpdGl2ZSBudW1iZXIsIGl0IG92ZXJmbG93cyBiYWNrIGludG8gYSBuZWdhdGl2ZSkuICBOb3QgaGFuZGxpbmcgdGhpc1xyXG4vLyBjYXNlIHdvdWxkIG9mdGVuIHJlc3VsdCBpbiBpbmZpbml0ZSByZWN1cnNpb24uXHJcbi8vXHJcbi8vIENvbW1vbiBjb25zdGFudCB2YWx1ZXMgWkVSTywgT05FLCBORUdfT05FLCBldGMuIGFyZSBkZWZpbmVkIGJlbG93IHRoZSBmcm9tKlxyXG4vLyBtZXRob2RzIG9uIHdoaWNoIHRoZXkgZGVwZW5kLlxyXG5cclxuLyoqXHJcbiAqIEFuIGluZGljYXRvciB1c2VkIHRvIHJlbGlhYmx5IGRldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBMb25nIG9yIG5vdC5cclxuICogQHR5cGUge2Jvb2xlYW59XHJcbiAqIEBjb25zdFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuTG9uZy5wcm90b3R5cGUuX19pc0xvbmdfXztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb25nLnByb3RvdHlwZSwgXCJfX2lzTG9uZ19fXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Kn0gb2JqIE9iamVjdFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICogQGlubmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0xvbmcob2JqKSB7XHJcbiAgICByZXR1cm4gKG9iaiAmJiBvYmpbXCJfX2lzTG9uZ19fXCJdKSA9PT0gdHJ1ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgb2JqZWN0IGlzIGEgTG9uZy5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Kn0gb2JqIE9iamVjdFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmcuaXNMb25nID0gaXNMb25nO1xyXG5cclxuLyoqXHJcbiAqIEEgY2FjaGUgb2YgdGhlIExvbmcgcmVwcmVzZW50YXRpb25zIG9mIHNtYWxsIGludGVnZXIgdmFsdWVzLlxyXG4gKiBAdHlwZSB7IU9iamVjdH1cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgSU5UX0NBQ0hFID0ge307XHJcblxyXG4vKipcclxuICogQSBjYWNoZSBvZiB0aGUgTG9uZyByZXByZXNlbnRhdGlvbnMgb2Ygc21hbGwgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuXHJcbiAqIEB0eXBlIHshT2JqZWN0fVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBVSU5UX0NBQ0hFID0ge307XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBmcm9tSW50KHZhbHVlLCB1bnNpZ25lZCkge1xyXG4gICAgdmFyIG9iaiwgY2FjaGVkT2JqLCBjYWNoZTtcclxuICAgIGlmICh1bnNpZ25lZCkge1xyXG4gICAgICAgIHZhbHVlID4+Pj0gMDtcclxuICAgICAgICBpZiAoY2FjaGUgPSAoMCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDI1NikpIHtcclxuICAgICAgICAgICAgY2FjaGVkT2JqID0gVUlOVF9DQUNIRVt2YWx1ZV07XHJcbiAgICAgICAgICAgIGlmIChjYWNoZWRPYmopXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkT2JqO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvYmogPSBmcm9tQml0cyh2YWx1ZSwgKHZhbHVlIHwgMCkgPCAwID8gLTEgOiAwLCB0cnVlKTtcclxuICAgICAgICBpZiAoY2FjaGUpXHJcbiAgICAgICAgICAgIFVJTlRfQ0FDSEVbdmFsdWVdID0gb2JqO1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhbHVlIHw9IDA7XHJcbiAgICAgICAgaWYgKGNhY2hlID0gKC0xMjggPD0gdmFsdWUgJiYgdmFsdWUgPCAxMjgpKSB7XHJcbiAgICAgICAgICAgIGNhY2hlZE9iaiA9IElOVF9DQUNIRVt2YWx1ZV07XHJcbiAgICAgICAgICAgIGlmIChjYWNoZWRPYmopXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkT2JqO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvYmogPSBmcm9tQml0cyh2YWx1ZSwgdmFsdWUgPCAwID8gLTEgOiAwLCBmYWxzZSk7XHJcbiAgICAgICAgaWYgKGNhY2hlKVxyXG4gICAgICAgICAgICBJTlRfQ0FDSEVbdmFsdWVdID0gb2JqO1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRpbmcgdGhlIGdpdmVuIDMyIGJpdCBpbnRlZ2VyIHZhbHVlLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSAzMiBiaXQgaW50ZWdlciBpbiBxdWVzdGlvblxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tSW50ID0gZnJvbUludDtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbmZ1bmN0aW9uIGZyb21OdW1iZXIodmFsdWUsIHVuc2lnbmVkKSB7XHJcbiAgICBpZiAoaXNOYU4odmFsdWUpKVxyXG4gICAgICAgIHJldHVybiB1bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcclxuICAgIGlmICh1bnNpZ25lZCkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA8IDApXHJcbiAgICAgICAgICAgIHJldHVybiBVWkVSTztcclxuICAgICAgICBpZiAodmFsdWUgPj0gVFdPX1BXUl82NF9EQkwpXHJcbiAgICAgICAgICAgIHJldHVybiBNQVhfVU5TSUdORURfVkFMVUU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmICh2YWx1ZSA8PSAtVFdPX1BXUl82M19EQkwpXHJcbiAgICAgICAgICAgIHJldHVybiBNSU5fVkFMVUU7XHJcbiAgICAgICAgaWYgKHZhbHVlICsgMSA+PSBUV09fUFdSXzYzX0RCTClcclxuICAgICAgICAgICAgcmV0dXJuIE1BWF9WQUxVRTtcclxuICAgIH1cclxuICAgIGlmICh2YWx1ZSA8IDApXHJcbiAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIoLXZhbHVlLCB1bnNpZ25lZCkubmVnKCk7XHJcbiAgICByZXR1cm4gZnJvbUJpdHMoKHZhbHVlICUgVFdPX1BXUl8zMl9EQkwpIHwgMCwgKHZhbHVlIC8gVFdPX1BXUl8zMl9EQkwpIHwgMCwgdW5zaWduZWQpO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiB2YWx1ZSwgcHJvdmlkZWQgdGhhdCBpdCBpcyBhIGZpbml0ZSBudW1iZXIuIE90aGVyd2lzZSwgemVybyBpcyByZXR1cm5lZC5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgbnVtYmVyIGluIHF1ZXN0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21OdW1iZXIgPSBmcm9tTnVtYmVyO1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dCaXRzXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoQml0c1xyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxuZnVuY3Rpb24gZnJvbUJpdHMobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKSB7XHJcbiAgICByZXR1cm4gbmV3IExvbmcobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgNjQgYml0IGludGVnZXIgdGhhdCBjb21lcyBieSBjb25jYXRlbmF0aW5nIHRoZSBnaXZlbiBsb3cgYW5kIGhpZ2ggYml0cy4gRWFjaCBpc1xyXG4gKiAgYXNzdW1lZCB0byB1c2UgMzIgYml0cy5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dCaXRzIFRoZSBsb3cgMzIgYml0c1xyXG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaEJpdHMgVGhlIGhpZ2ggMzIgYml0c1xyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tQml0cyA9IGZyb21CaXRzO1xyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gYmFzZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gZXhwb25lbnRcclxuICogQHJldHVybnMge251bWJlcn1cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgcG93X2RibCA9IE1hdGgucG93OyAvLyBVc2VkIDQgdGltZXMgKDQqOCB0byAxNSs0KVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcclxuICogQHBhcmFtIHsoYm9vbGVhbnxudW1iZXIpPX0gdW5zaWduZWRcclxuICogQHBhcmFtIHtudW1iZXI9fSByYWRpeFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxuZnVuY3Rpb24gZnJvbVN0cmluZyhzdHIsIHVuc2lnbmVkLCByYWRpeCkge1xyXG4gICAgaWYgKHN0ci5sZW5ndGggPT09IDApXHJcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2VtcHR5IHN0cmluZycpO1xyXG4gICAgaWYgKHN0ciA9PT0gXCJOYU5cIiB8fCBzdHIgPT09IFwiSW5maW5pdHlcIiB8fCBzdHIgPT09IFwiK0luZmluaXR5XCIgfHwgc3RyID09PSBcIi1JbmZpbml0eVwiKVxyXG4gICAgICAgIHJldHVybiBaRVJPO1xyXG4gICAgaWYgKHR5cGVvZiB1bnNpZ25lZCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAvLyBGb3IgZ29vZy5tYXRoLmxvbmcgY29tcGF0aWJpbGl0eVxyXG4gICAgICAgIHJhZGl4ID0gdW5zaWduZWQsXHJcbiAgICAgICAgdW5zaWduZWQgPSBmYWxzZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdW5zaWduZWQgPSAhISB1bnNpZ25lZDtcclxuICAgIH1cclxuICAgIHJhZGl4ID0gcmFkaXggfHwgMTA7XHJcbiAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpXHJcbiAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcigncmFkaXgnKTtcclxuXHJcbiAgICB2YXIgcDtcclxuICAgIGlmICgocCA9IHN0ci5pbmRleE9mKCctJykpID4gMClcclxuICAgICAgICB0aHJvdyBFcnJvcignaW50ZXJpb3IgaHlwaGVuJyk7XHJcbiAgICBlbHNlIGlmIChwID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcoc3RyLnN1YnN0cmluZygxKSwgdW5zaWduZWQsIHJhZGl4KS5uZWcoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEbyBzZXZlcmFsICg4KSBkaWdpdHMgZWFjaCB0aW1lIHRocm91Z2ggdGhlIGxvb3AsIHNvIGFzIHRvXHJcbiAgICAvLyBtaW5pbWl6ZSB0aGUgY2FsbHMgdG8gdGhlIHZlcnkgZXhwZW5zaXZlIGVtdWxhdGVkIGRpdi5cclxuICAgIHZhciByYWRpeFRvUG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIDgpKTtcclxuXHJcbiAgICB2YXIgcmVzdWx0ID0gWkVSTztcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSA4KSB7XHJcbiAgICAgICAgdmFyIHNpemUgPSBNYXRoLm1pbig4LCBzdHIubGVuZ3RoIC0gaSksXHJcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZyhpLCBpICsgc2l6ZSksIHJhZGl4KTtcclxuICAgICAgICBpZiAoc2l6ZSA8IDgpIHtcclxuICAgICAgICAgICAgdmFyIHBvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCBzaXplKSk7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwocG93ZXIpLmFkZChmcm9tTnVtYmVyKHZhbHVlKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bChyYWRpeFRvUG93ZXIpO1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuYWRkKGZyb21OdW1iZXIodmFsdWUpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXN1bHQudW5zaWduZWQgPSB1bnNpZ25lZDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gc3RyaW5nLCB3cml0dGVuIHVzaW5nIHRoZSBzcGVjaWZpZWQgcmFkaXguXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBMb25nXHJcbiAqIEBwYXJhbSB7KGJvb2xlYW58bnVtYmVyKT19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHBhcmFtIHtudW1iZXI9fSByYWRpeCBUaGUgcmFkaXggaW4gd2hpY2ggdGhlIHRleHQgaXMgd3JpdHRlbiAoMi0zNiksIGRlZmF1bHRzIHRvIDEwXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tU3RyaW5nID0gZnJvbVN0cmluZztcclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfCF7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlciwgdW5zaWduZWQ6IGJvb2xlYW59fSB2YWxcclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbmZ1bmN0aW9uIGZyb21WYWx1ZSh2YWwsIHVuc2lnbmVkKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpXHJcbiAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIodmFsLCB1bnNpZ25lZCk7XHJcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcodmFsLCB1bnNpZ25lZCk7XHJcbiAgICAvLyBUaHJvd3MgZm9yIG5vbi1vYmplY3RzLCBjb252ZXJ0cyBub24taW5zdGFuY2VvZiBMb25nOlxyXG4gICAgcmV0dXJuIGZyb21CaXRzKHZhbC5sb3csIHZhbC5oaWdoLCB0eXBlb2YgdW5zaWduZWQgPT09ICdib29sZWFuJyA/IHVuc2lnbmVkIDogdmFsLnVuc2lnbmVkKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBzcGVjaWZpZWQgdmFsdWUgdG8gYSBMb25nIHVzaW5nIHRoZSBhcHByb3ByaWF0ZSBmcm9tKiBmdW5jdGlvbiBmb3IgaXRzIHR5cGUuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd8IXtsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyLCB1bnNpZ25lZDogYm9vbGVhbn19IHZhbCBWYWx1ZVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICovXHJcbkxvbmcuZnJvbVZhbHVlID0gZnJvbVZhbHVlO1xyXG5cclxuLy8gTk9URTogdGhlIGNvbXBpbGVyIHNob3VsZCBpbmxpbmUgdGhlc2UgY29uc3RhbnQgdmFsdWVzIGJlbG93IGFuZCB0aGVuIHJlbW92ZSB0aGVzZSB2YXJpYWJsZXMsIHNvIHRoZXJlIHNob3VsZCBiZVxyXG4vLyBubyBydW50aW1lIHBlbmFsdHkgZm9yIHRoZXNlLlxyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqIEBjb25zdFxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBUV09fUFdSXzE2X0RCTCA9IDEgPDwgMTY7XHJcblxyXG4vKipcclxuICogQHR5cGUge251bWJlcn1cclxuICogQGNvbnN0XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFRXT19QV1JfMjRfREJMID0gMSA8PCAyNDtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKiBAY29uc3RcclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVFdPX1BXUl8zMl9EQkwgPSBUV09fUFdSXzE2X0RCTCAqIFRXT19QV1JfMTZfREJMO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqIEBjb25zdFxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBUV09fUFdSXzY0X0RCTCA9IFRXT19QV1JfMzJfREJMICogVFdPX1BXUl8zMl9EQkw7XHJcblxyXG4vKipcclxuICogQHR5cGUge251bWJlcn1cclxuICogQGNvbnN0XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFRXT19QV1JfNjNfREJMID0gVFdPX1BXUl82NF9EQkwgLyAyO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGNvbnN0XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFRXT19QV1JfMjQgPSBmcm9tSW50KFRXT19QV1JfMjRfREJMKTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFpFUk8gPSBmcm9tSW50KDApO1xyXG5cclxuLyoqXHJcbiAqIFNpZ25lZCB6ZXJvLlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nLlpFUk8gPSBaRVJPO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVVpFUk8gPSBmcm9tSW50KDAsIHRydWUpO1xyXG5cclxuLyoqXHJcbiAqIFVuc2lnbmVkIHplcm8uXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuVVpFUk8gPSBVWkVSTztcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIE9ORSA9IGZyb21JbnQoMSk7XHJcblxyXG4vKipcclxuICogU2lnbmVkIG9uZS5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5PTkUgPSBPTkU7XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBVT05FID0gZnJvbUludCgxLCB0cnVlKTtcclxuXHJcbi8qKlxyXG4gKiBVbnNpZ25lZCBvbmUuXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuVU9ORSA9IFVPTkU7XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBORUdfT05FID0gZnJvbUludCgtMSk7XHJcblxyXG4vKipcclxuICogU2lnbmVkIG5lZ2F0aXZlIG9uZS5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5ORUdfT05FID0gTkVHX09ORTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIE1BWF9WQUxVRSA9IGZyb21CaXRzKDB4RkZGRkZGRkZ8MCwgMHg3RkZGRkZGRnwwLCBmYWxzZSk7XHJcblxyXG4vKipcclxuICogTWF4aW11bSBzaWduZWQgdmFsdWUuXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuTUFYX1ZBTFVFID0gTUFYX1ZBTFVFO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgTUFYX1VOU0lHTkVEX1ZBTFVFID0gZnJvbUJpdHMoMHhGRkZGRkZGRnwwLCAweEZGRkZGRkZGfDAsIHRydWUpO1xyXG5cclxuLyoqXHJcbiAqIE1heGltdW0gdW5zaWduZWQgdmFsdWUuXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuTUFYX1VOU0lHTkVEX1ZBTFVFID0gTUFYX1VOU0lHTkVEX1ZBTFVFO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgTUlOX1ZBTFVFID0gZnJvbUJpdHMoMCwgMHg4MDAwMDAwMHwwLCBmYWxzZSk7XHJcblxyXG4vKipcclxuICogTWluaW11bSBzaWduZWQgdmFsdWUuXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuTUlOX1ZBTFVFID0gTUlOX1ZBTFVFO1xyXG5cclxuLyoqXHJcbiAqIEBhbGlhcyBMb25nLnByb3RvdHlwZVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBMb25nUHJvdG90eXBlID0gTG9uZy5wcm90b3R5cGU7XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIExvbmcgdG8gYSAzMiBiaXQgaW50ZWdlciwgYXNzdW1pbmcgaXQgaXMgYSAzMiBiaXQgaW50ZWdlci5cclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9JbnQgPSBmdW5jdGlvbiB0b0ludCgpIHtcclxuICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gdGhpcy5sb3cgPj4+IDAgOiB0aGlzLmxvdztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIHRoZSBuZWFyZXN0IGZsb2F0aW5nLXBvaW50IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdmFsdWUgKGRvdWJsZSwgNTMgYml0IG1hbnRpc3NhKS5cclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlcigpIHtcclxuICAgIGlmICh0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgIHJldHVybiAoKHRoaXMuaGlnaCA+Pj4gMCkgKiBUV09fUFdSXzMyX0RCTCkgKyAodGhpcy5sb3cgPj4+IDApO1xyXG4gICAgcmV0dXJuIHRoaXMuaGlnaCAqIFRXT19QV1JfMzJfREJMICsgKHRoaXMubG93ID4+PiAwKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIHN0cmluZyB3cml0dGVuIGluIHRoZSBzcGVjaWZpZWQgcmFkaXguXHJcbiAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXggUmFkaXggKDItMzYpLCBkZWZhdWx0cyB0byAxMFxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKiBAb3ZlcnJpZGVcclxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYHJhZGl4YCBpcyBvdXQgb2YgcmFuZ2VcclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhyYWRpeCkge1xyXG4gICAgcmFkaXggPSByYWRpeCB8fCAxMDtcclxuICAgIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeClcclxuICAgICAgICB0aHJvdyBSYW5nZUVycm9yKCdyYWRpeCcpO1xyXG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpXHJcbiAgICAgICAgcmV0dXJuICcwJztcclxuICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkgeyAvLyBVbnNpZ25lZCBMb25ncyBhcmUgbmV2ZXIgbmVnYXRpdmVcclxuICAgICAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gY2hhbmdlIHRoZSBMb25nIHZhbHVlIGJlZm9yZSBpdCBjYW4gYmUgbmVnYXRlZCwgc28gd2UgcmVtb3ZlXHJcbiAgICAgICAgICAgIC8vIHRoZSBib3R0b20tbW9zdCBkaWdpdCBpbiB0aGlzIGJhc2UgYW5kIHRoZW4gcmVjdXJzZSB0byBkbyB0aGUgcmVzdC5cclxuICAgICAgICAgICAgdmFyIHJhZGl4TG9uZyA9IGZyb21OdW1iZXIocmFkaXgpLFxyXG4gICAgICAgICAgICAgICAgZGl2ID0gdGhpcy5kaXYocmFkaXhMb25nKSxcclxuICAgICAgICAgICAgICAgIHJlbTEgPSBkaXYubXVsKHJhZGl4TG9uZykuc3ViKHRoaXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gZGl2LnRvU3RyaW5nKHJhZGl4KSArIHJlbTEudG9JbnQoKS50b1N0cmluZyhyYWRpeCk7XHJcbiAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiAnLScgKyB0aGlzLm5lZygpLnRvU3RyaW5nKHJhZGl4KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEbyBzZXZlcmFsICg2KSBkaWdpdHMgZWFjaCB0aW1lIHRocm91Z2ggdGhlIGxvb3AsIHNvIGFzIHRvXHJcbiAgICAvLyBtaW5pbWl6ZSB0aGUgY2FsbHMgdG8gdGhlIHZlcnkgZXhwZW5zaXZlIGVtdWxhdGVkIGRpdi5cclxuICAgIHZhciByYWRpeFRvUG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIDYpLCB0aGlzLnVuc2lnbmVkKSxcclxuICAgICAgICByZW0gPSB0aGlzO1xyXG4gICAgdmFyIHJlc3VsdCA9ICcnO1xyXG4gICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICB2YXIgcmVtRGl2ID0gcmVtLmRpdihyYWRpeFRvUG93ZXIpLFxyXG4gICAgICAgICAgICBpbnR2YWwgPSByZW0uc3ViKHJlbURpdi5tdWwocmFkaXhUb1Bvd2VyKSkudG9JbnQoKSA+Pj4gMCxcclxuICAgICAgICAgICAgZGlnaXRzID0gaW50dmFsLnRvU3RyaW5nKHJhZGl4KTtcclxuICAgICAgICByZW0gPSByZW1EaXY7XHJcbiAgICAgICAgaWYgKHJlbS5pc1plcm8oKSlcclxuICAgICAgICAgICAgcmV0dXJuIGRpZ2l0cyArIHJlc3VsdDtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgd2hpbGUgKGRpZ2l0cy5sZW5ndGggPCA2KVxyXG4gICAgICAgICAgICAgICAgZGlnaXRzID0gJzAnICsgZGlnaXRzO1xyXG4gICAgICAgICAgICByZXN1bHQgPSAnJyArIGRpZ2l0cyArIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgaGlnaCAzMiBiaXRzIGFzIGEgc2lnbmVkIGludGVnZXIuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFNpZ25lZCBoaWdoIGJpdHNcclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ2V0SGlnaEJpdHMgPSBmdW5jdGlvbiBnZXRIaWdoQml0cygpIHtcclxuICAgIHJldHVybiB0aGlzLmhpZ2g7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgaGlnaCAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFVuc2lnbmVkIGhpZ2ggYml0c1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5nZXRIaWdoQml0c1Vuc2lnbmVkID0gZnVuY3Rpb24gZ2V0SGlnaEJpdHNVbnNpZ25lZCgpIHtcclxuICAgIHJldHVybiB0aGlzLmhpZ2ggPj4+IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgbG93IDMyIGJpdHMgYXMgYSBzaWduZWQgaW50ZWdlci5cclxuICogQHJldHVybnMge251bWJlcn0gU2lnbmVkIGxvdyBiaXRzXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdldExvd0JpdHMgPSBmdW5jdGlvbiBnZXRMb3dCaXRzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubG93O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIGxvdyAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFVuc2lnbmVkIGxvdyBiaXRzXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdldExvd0JpdHNVbnNpZ25lZCA9IGZ1bmN0aW9uIGdldExvd0JpdHNVbnNpZ25lZCgpIHtcclxuICAgIHJldHVybiB0aGlzLmxvdyA+Pj4gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBudW1iZXIgb2YgYml0cyBuZWVkZWQgdG8gcmVwcmVzZW50IHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIExvbmcuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdldE51bUJpdHNBYnMgPSBmdW5jdGlvbiBnZXROdW1CaXRzQWJzKCkge1xyXG4gICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSAvLyBVbnNpZ25lZCBMb25ncyBhcmUgbmV2ZXIgbmVnYXRpdmVcclxuICAgICAgICByZXR1cm4gdGhpcy5lcShNSU5fVkFMVUUpID8gNjQgOiB0aGlzLm5lZygpLmdldE51bUJpdHNBYnMoKTtcclxuICAgIHZhciB2YWwgPSB0aGlzLmhpZ2ggIT0gMCA/IHRoaXMuaGlnaCA6IHRoaXMubG93O1xyXG4gICAgZm9yICh2YXIgYml0ID0gMzE7IGJpdCA+IDA7IGJpdC0tKVxyXG4gICAgICAgIGlmICgodmFsICYgKDEgPDwgYml0KSkgIT0gMClcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICByZXR1cm4gdGhpcy5oaWdoICE9IDAgPyBiaXQgKyAzMyA6IGJpdCArIDE7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHplcm8uXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiBpc1plcm8oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5oaWdoID09PSAwICYmIHRoaXMubG93ID09PSAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB6ZXJvLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2lzWmVyb30uXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5lcXogPSBMb25nUHJvdG90eXBlLmlzWmVybztcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBuZWdhdGl2ZS5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiBpc05lZ2F0aXZlKCkge1xyXG4gICAgcmV0dXJuICF0aGlzLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA8IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgcG9zaXRpdmUuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gaXNQb3NpdGl2ZSgpIHtcclxuICAgIHJldHVybiB0aGlzLnVuc2lnbmVkIHx8IHRoaXMuaGlnaCA+PSAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIG9kZC5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gaXNPZGQoKSB7XHJcbiAgICByZXR1cm4gKHRoaXMubG93ICYgMSkgPT09IDE7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZXZlbi5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uIGlzRXZlbigpIHtcclxuICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgdGhlIHNwZWNpZmllZCdzLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcclxuICAgIGlmICghaXNMb25nKG90aGVyKSlcclxuICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICBpZiAodGhpcy51bnNpZ25lZCAhPT0gb3RoZXIudW5zaWduZWQgJiYgKHRoaXMuaGlnaCA+Pj4gMzEpID09PSAxICYmIChvdGhlci5oaWdoID4+PiAzMSkgPT09IDEpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgcmV0dXJuIHRoaXMuaGlnaCA9PT0gb3RoZXIuaGlnaCAmJiB0aGlzLmxvdyA9PT0gb3RoZXIubG93O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZXF1YWxzfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmVxID0gTG9uZ1Byb3RvdHlwZS5lcXVhbHM7XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUubm90RXF1YWxzID0gZnVuY3Rpb24gbm90RXF1YWxzKG90aGVyKSB7XHJcbiAgICByZXR1cm4gIXRoaXMuZXEoLyogdmFsaWRhdGVzICovIG90aGVyKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25vdEVxdWFsc30uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5uZXEgPSBMb25nUHJvdG90eXBlLm5vdEVxdWFscztcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25vdEVxdWFsc30uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5uZSA9IExvbmdQcm90b3R5cGUubm90RXF1YWxzO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmxlc3NUaGFuID0gZnVuY3Rpb24gbGVzc1RoYW4ob3RoZXIpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA8IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNsZXNzVGhhbn0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5sdCA9IExvbmdQcm90b3R5cGUubGVzc1RoYW47XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsID0gZnVuY3Rpb24gbGVzc1RoYW5PckVxdWFsKG90aGVyKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPD0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2xlc3NUaGFuT3JFcXVhbH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5sdGUgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbDtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2xlc3NUaGFuT3JFcXVhbH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5sZSA9IExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuID0gZnVuY3Rpb24gZ3JlYXRlclRoYW4ob3RoZXIpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA+IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNncmVhdGVyVGhhbn0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5ndCA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW47XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsID0gZnVuY3Rpb24gZ3JlYXRlclRoYW5PckVxdWFsKG90aGVyKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPj0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFuT3JFcXVhbH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5ndGUgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbDtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFuT3JFcXVhbH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5nZSA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsO1xyXG5cclxuLyoqXHJcbiAqIENvbXBhcmVzIHRoaXMgTG9uZydzIHZhbHVlIHdpdGggdGhlIHNwZWNpZmllZCdzLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIDEgaWYgdGhlIHRoaXMgaXMgZ3JlYXRlciBhbmQgLTFcclxuICogIGlmIHRoZSBnaXZlbiBvbmUgaXMgZ3JlYXRlclxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZShvdGhlcikge1xyXG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgIGlmICh0aGlzLmVxKG90aGVyKSlcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIHZhciB0aGlzTmVnID0gdGhpcy5pc05lZ2F0aXZlKCksXHJcbiAgICAgICAgb3RoZXJOZWcgPSBvdGhlci5pc05lZ2F0aXZlKCk7XHJcbiAgICBpZiAodGhpc05lZyAmJiAhb3RoZXJOZWcpXHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgaWYgKCF0aGlzTmVnICYmIG90aGVyTmVnKVxyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgLy8gQXQgdGhpcyBwb2ludCB0aGUgc2lnbiBiaXRzIGFyZSB0aGUgc2FtZVxyXG4gICAgaWYgKCF0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgIHJldHVybiB0aGlzLnN1YihvdGhlcikuaXNOZWdhdGl2ZSgpID8gLTEgOiAxO1xyXG4gICAgLy8gQm90aCBhcmUgcG9zaXRpdmUgaWYgYXQgbGVhc3Qgb25lIGlzIHVuc2lnbmVkXHJcbiAgICByZXR1cm4gKG90aGVyLmhpZ2ggPj4+IDApID4gKHRoaXMuaGlnaCA+Pj4gMCkgfHwgKG90aGVyLmhpZ2ggPT09IHRoaXMuaGlnaCAmJiAob3RoZXIubG93ID4+PiAwKSA+ICh0aGlzLmxvdyA+Pj4gMCkpID8gLTEgOiAxO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbXBhcmVzIHRoaXMgTG9uZydzIHZhbHVlIHdpdGggdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2NvbXBhcmV9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSAwIGlmIHRoZXkgYXJlIHRoZSBzYW1lLCAxIGlmIHRoZSB0aGlzIGlzIGdyZWF0ZXIgYW5kIC0xXHJcbiAqICBpZiB0aGUgZ2l2ZW4gb25lIGlzIGdyZWF0ZXJcclxuICovXHJcbkxvbmdQcm90b3R5cGUuY29tcCA9IExvbmdQcm90b3R5cGUuY29tcGFyZTtcclxuXHJcbi8qKlxyXG4gKiBOZWdhdGVzIHRoaXMgTG9uZydzIHZhbHVlLlxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IE5lZ2F0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbiBuZWdhdGUoKSB7XHJcbiAgICBpZiAoIXRoaXMudW5zaWduZWQgJiYgdGhpcy5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgIHJldHVybiBNSU5fVkFMVUU7XHJcbiAgICByZXR1cm4gdGhpcy5ub3QoKS5hZGQoT05FKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBOZWdhdGVzIHRoaXMgTG9uZydzIHZhbHVlLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25lZ2F0ZX0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IE5lZ2F0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5uZWcgPSBMb25nUHJvdG90eXBlLm5lZ2F0ZTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBzdW0gb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGFkZGVuZCBBZGRlbmRcclxuICogQHJldHVybnMgeyFMb25nfSBTdW1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKGFkZGVuZCkge1xyXG4gICAgaWYgKCFpc0xvbmcoYWRkZW5kKSlcclxuICAgICAgICBhZGRlbmQgPSBmcm9tVmFsdWUoYWRkZW5kKTtcclxuXHJcbiAgICAvLyBEaXZpZGUgZWFjaCBudW1iZXIgaW50byA0IGNodW5rcyBvZiAxNiBiaXRzLCBhbmQgdGhlbiBzdW0gdGhlIGNodW5rcy5cclxuXHJcbiAgICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjtcclxuICAgIHZhciBhMzIgPSB0aGlzLmhpZ2ggJiAweEZGRkY7XHJcbiAgICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2O1xyXG4gICAgdmFyIGEwMCA9IHRoaXMubG93ICYgMHhGRkZGO1xyXG5cclxuICAgIHZhciBiNDggPSBhZGRlbmQuaGlnaCA+Pj4gMTY7XHJcbiAgICB2YXIgYjMyID0gYWRkZW5kLmhpZ2ggJiAweEZGRkY7XHJcbiAgICB2YXIgYjE2ID0gYWRkZW5kLmxvdyA+Pj4gMTY7XHJcbiAgICB2YXIgYjAwID0gYWRkZW5kLmxvdyAmIDB4RkZGRjtcclxuXHJcbiAgICB2YXIgYzQ4ID0gMCwgYzMyID0gMCwgYzE2ID0gMCwgYzAwID0gMDtcclxuICAgIGMwMCArPSBhMDAgKyBiMDA7XHJcbiAgICBjMTYgKz0gYzAwID4+PiAxNjtcclxuICAgIGMwMCAmPSAweEZGRkY7XHJcbiAgICBjMTYgKz0gYTE2ICsgYjE2O1xyXG4gICAgYzMyICs9IGMxNiA+Pj4gMTY7XHJcbiAgICBjMTYgJj0gMHhGRkZGO1xyXG4gICAgYzMyICs9IGEzMiArIGIzMjtcclxuICAgIGM0OCArPSBjMzIgPj4+IDE2O1xyXG4gICAgYzMyICY9IDB4RkZGRjtcclxuICAgIGM0OCArPSBhNDggKyBiNDg7XHJcbiAgICBjNDggJj0gMHhGRkZGO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKChjMTYgPDwgMTYpIHwgYzAwLCAoYzQ4IDw8IDE2KSB8IGMzMiwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgZGlmZmVyZW5jZSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gc3VidHJhaGVuZCBTdWJ0cmFoZW5kXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gRGlmZmVyZW5jZVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uIHN1YnRyYWN0KHN1YnRyYWhlbmQpIHtcclxuICAgIGlmICghaXNMb25nKHN1YnRyYWhlbmQpKVxyXG4gICAgICAgIHN1YnRyYWhlbmQgPSBmcm9tVmFsdWUoc3VidHJhaGVuZCk7XHJcbiAgICByZXR1cm4gdGhpcy5hZGQoc3VidHJhaGVuZC5uZWcoKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgZGlmZmVyZW5jZSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc3VidHJhY3R9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBzdWJ0cmFoZW5kIFN1YnRyYWhlbmRcclxuICogQHJldHVybnMgeyFMb25nfSBEaWZmZXJlbmNlXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnN1YiA9IExvbmdQcm90b3R5cGUuc3VidHJhY3Q7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgcHJvZHVjdCBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gbXVsdGlwbGllciBNdWx0aXBsaWVyXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUHJvZHVjdFxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIG11bHRpcGx5KG11bHRpcGxpZXIpIHtcclxuICAgIGlmICh0aGlzLmlzWmVybygpKVxyXG4gICAgICAgIHJldHVybiBaRVJPO1xyXG4gICAgaWYgKCFpc0xvbmcobXVsdGlwbGllcikpXHJcbiAgICAgICAgbXVsdGlwbGllciA9IGZyb21WYWx1ZShtdWx0aXBsaWVyKTtcclxuXHJcbiAgICAvLyB1c2Ugd2FzbSBzdXBwb3J0IGlmIHByZXNlbnRcclxuICAgIGlmICh3YXNtKSB7XHJcbiAgICAgICAgdmFyIGxvdyA9IHdhc20ubXVsKHRoaXMubG93LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2gsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxpZXIubG93LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsaWVyLmhpZ2gpO1xyXG4gICAgICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc20uZ2V0X2hpZ2goKSwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG11bHRpcGxpZXIuaXNaZXJvKCkpXHJcbiAgICAgICAgcmV0dXJuIFpFUk87XHJcbiAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgIHJldHVybiBtdWx0aXBsaWVyLmlzT2RkKCkgPyBNSU5fVkFMVUUgOiBaRVJPO1xyXG4gICAgaWYgKG11bHRpcGxpZXIuZXEoTUlOX1ZBTFVFKSlcclxuICAgICAgICByZXR1cm4gdGhpcy5pc09kZCgpID8gTUlOX1ZBTFVFIDogWkVSTztcclxuXHJcbiAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcclxuICAgICAgICBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyLm5lZygpKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyKS5uZWcoKTtcclxuICAgIH0gZWxzZSBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsKG11bHRpcGxpZXIubmVnKCkpLm5lZygpO1xyXG5cclxuICAgIC8vIElmIGJvdGggbG9uZ3MgYXJlIHNtYWxsLCB1c2UgZmxvYXQgbXVsdGlwbGljYXRpb25cclxuICAgIGlmICh0aGlzLmx0KFRXT19QV1JfMjQpICYmIG11bHRpcGxpZXIubHQoVFdPX1BXUl8yNCkpXHJcbiAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIodGhpcy50b051bWJlcigpICogbXVsdGlwbGllci50b051bWJlcigpLCB0aGlzLnVuc2lnbmVkKTtcclxuXHJcbiAgICAvLyBEaXZpZGUgZWFjaCBsb25nIGludG8gNCBjaHVua3Mgb2YgMTYgYml0cywgYW5kIHRoZW4gYWRkIHVwIDR4NCBwcm9kdWN0cy5cclxuICAgIC8vIFdlIGNhbiBza2lwIHByb2R1Y3RzIHRoYXQgd291bGQgb3ZlcmZsb3cuXHJcblxyXG4gICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7XHJcbiAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgMHhGRkZGO1xyXG4gICAgdmFyIGExNiA9IHRoaXMubG93ID4+PiAxNjtcclxuICAgIHZhciBhMDAgPSB0aGlzLmxvdyAmIDB4RkZGRjtcclxuXHJcbiAgICB2YXIgYjQ4ID0gbXVsdGlwbGllci5oaWdoID4+PiAxNjtcclxuICAgIHZhciBiMzIgPSBtdWx0aXBsaWVyLmhpZ2ggJiAweEZGRkY7XHJcbiAgICB2YXIgYjE2ID0gbXVsdGlwbGllci5sb3cgPj4+IDE2O1xyXG4gICAgdmFyIGIwMCA9IG11bHRpcGxpZXIubG93ICYgMHhGRkZGO1xyXG5cclxuICAgIHZhciBjNDggPSAwLCBjMzIgPSAwLCBjMTYgPSAwLCBjMDAgPSAwO1xyXG4gICAgYzAwICs9IGEwMCAqIGIwMDtcclxuICAgIGMxNiArPSBjMDAgPj4+IDE2O1xyXG4gICAgYzAwICY9IDB4RkZGRjtcclxuICAgIGMxNiArPSBhMTYgKiBiMDA7XHJcbiAgICBjMzIgKz0gYzE2ID4+PiAxNjtcclxuICAgIGMxNiAmPSAweEZGRkY7XHJcbiAgICBjMTYgKz0gYTAwICogYjE2O1xyXG4gICAgYzMyICs9IGMxNiA+Pj4gMTY7XHJcbiAgICBjMTYgJj0gMHhGRkZGO1xyXG4gICAgYzMyICs9IGEzMiAqIGIwMDtcclxuICAgIGM0OCArPSBjMzIgPj4+IDE2O1xyXG4gICAgYzMyICY9IDB4RkZGRjtcclxuICAgIGMzMiArPSBhMTYgKiBiMTY7XHJcbiAgICBjNDggKz0gYzMyID4+PiAxNjtcclxuICAgIGMzMiAmPSAweEZGRkY7XHJcbiAgICBjMzIgKz0gYTAwICogYjMyO1xyXG4gICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XHJcbiAgICBjMzIgJj0gMHhGRkZGO1xyXG4gICAgYzQ4ICs9IGE0OCAqIGIwMCArIGEzMiAqIGIxNiArIGExNiAqIGIzMiArIGEwMCAqIGI0ODtcclxuICAgIGM0OCAmPSAweEZGRkY7XHJcbiAgICByZXR1cm4gZnJvbUJpdHMoKGMxNiA8PCAxNikgfCBjMDAsIChjNDggPDwgMTYpIHwgYzMyLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNtdWx0aXBseX0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG11bHRpcGxpZXIgTXVsdGlwbGllclxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFByb2R1Y3RcclxuICovXHJcbkxvbmdQcm90b3R5cGUubXVsID0gTG9uZ1Byb3RvdHlwZS5tdWx0aXBseTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyBkaXZpZGVkIGJ5IHRoZSBzcGVjaWZpZWQuIFRoZSByZXN1bHQgaXMgc2lnbmVkIGlmIHRoaXMgTG9uZyBpcyBzaWduZWQgb3JcclxuICogIHVuc2lnbmVkIGlmIHRoaXMgTG9uZyBpcyB1bnNpZ25lZC5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcclxuICogQHJldHVybnMgeyFMb25nfSBRdW90aWVudFxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiBkaXZpZGUoZGl2aXNvcikge1xyXG4gICAgaWYgKCFpc0xvbmcoZGl2aXNvcikpXHJcbiAgICAgICAgZGl2aXNvciA9IGZyb21WYWx1ZShkaXZpc29yKTtcclxuICAgIGlmIChkaXZpc29yLmlzWmVybygpKVxyXG4gICAgICAgIHRocm93IEVycm9yKCdkaXZpc2lvbiBieSB6ZXJvJyk7XHJcblxyXG4gICAgLy8gdXNlIHdhc20gc3VwcG9ydCBpZiBwcmVzZW50XHJcbiAgICBpZiAod2FzbSkge1xyXG4gICAgICAgIC8vIGd1YXJkIGFnYWluc3Qgc2lnbmVkIGRpdmlzaW9uIG92ZXJmbG93OiB0aGUgbGFyZ2VzdFxyXG4gICAgICAgIC8vIG5lZ2F0aXZlIG51bWJlciAvIC0xIHdvdWxkIGJlIDEgbGFyZ2VyIHRoYW4gdGhlIGxhcmdlc3RcclxuICAgICAgICAvLyBwb3NpdGl2ZSBudW1iZXIsIGR1ZSB0byB0d28ncyBjb21wbGVtZW50LlxyXG4gICAgICAgIGlmICghdGhpcy51bnNpZ25lZCAmJlxyXG4gICAgICAgICAgICB0aGlzLmhpZ2ggPT09IC0weDgwMDAwMDAwICYmXHJcbiAgICAgICAgICAgIGRpdmlzb3IubG93ID09PSAtMSAmJiBkaXZpc29yLmhpZ2ggPT09IC0xKSB7XHJcbiAgICAgICAgICAgIC8vIGJlIGNvbnNpc3RlbnQgd2l0aCBub24td2FzbSBjb2RlIHBhdGhcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBsb3cgPSAodGhpcy51bnNpZ25lZCA/IHdhc20uZGl2X3UgOiB3YXNtLmRpdl9zKShcclxuICAgICAgICAgICAgdGhpcy5sb3csXHJcbiAgICAgICAgICAgIHRoaXMuaGlnaCxcclxuICAgICAgICAgICAgZGl2aXNvci5sb3csXHJcbiAgICAgICAgICAgIGRpdmlzb3IuaGlnaFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKGxvdywgd2FzbS5nZXRfaGlnaCgpLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5pc1plcm8oKSlcclxuICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcclxuICAgIHZhciBhcHByb3gsIHJlbSwgcmVzO1xyXG4gICAgaWYgKCF0aGlzLnVuc2lnbmVkKSB7XHJcbiAgICAgICAgLy8gVGhpcyBzZWN0aW9uIGlzIG9ubHkgcmVsZXZhbnQgZm9yIHNpZ25lZCBsb25ncyBhbmQgaXMgZGVyaXZlZCBmcm9tIHRoZVxyXG4gICAgICAgIC8vIGNsb3N1cmUgbGlicmFyeSBhcyBhIHdob2xlLlxyXG4gICAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHtcclxuICAgICAgICAgICAgaWYgKGRpdmlzb3IuZXEoT05FKSB8fCBkaXZpc29yLmVxKE5FR19PTkUpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTsgIC8vIHJlY2FsbCB0aGF0IC1NSU5fVkFMVUUgPT0gTUlOX1ZBTFVFXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGRpdmlzb3IuZXEoTUlOX1ZBTFVFKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBPTkU7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgaGF2ZSB8b3RoZXJ8ID49IDIsIHNvIHx0aGlzL290aGVyfCA8IHxNSU5fVkFMVUV8LlxyXG4gICAgICAgICAgICAgICAgdmFyIGhhbGZUaGlzID0gdGhpcy5zaHIoMSk7XHJcbiAgICAgICAgICAgICAgICBhcHByb3ggPSBoYWxmVGhpcy5kaXYoZGl2aXNvcikuc2hsKDEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFwcHJveC5lcShaRVJPKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXZpc29yLmlzTmVnYXRpdmUoKSA/IE9ORSA6IE5FR19PTkU7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbSA9IHRoaXMuc3ViKGRpdmlzb3IubXVsKGFwcHJveCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IGFwcHJveC5hZGQocmVtLmRpdihkaXZpc29yKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoZGl2aXNvci5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcclxuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcclxuICAgICAgICAgICAgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IubmVnKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5kaXYoZGl2aXNvcikubmVnKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGl2KGRpdmlzb3IubmVnKCkpLm5lZygpO1xyXG4gICAgICAgIHJlcyA9IFpFUk87XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIFRoZSBhbGdvcml0aG0gYmVsb3cgaGFzIG5vdCBiZWVuIG1hZGUgZm9yIHVuc2lnbmVkIGxvbmdzLiBJdCdzIHRoZXJlZm9yZVxyXG4gICAgICAgIC8vIHJlcXVpcmVkIHRvIHRha2Ugc3BlY2lhbCBjYXJlIG9mIHRoZSBNU0IgcHJpb3IgdG8gcnVubmluZyBpdC5cclxuICAgICAgICBpZiAoIWRpdmlzb3IudW5zaWduZWQpXHJcbiAgICAgICAgICAgIGRpdmlzb3IgPSBkaXZpc29yLnRvVW5zaWduZWQoKTtcclxuICAgICAgICBpZiAoZGl2aXNvci5ndCh0aGlzKSlcclxuICAgICAgICAgICAgcmV0dXJuIFVaRVJPO1xyXG4gICAgICAgIGlmIChkaXZpc29yLmd0KHRoaXMuc2hydSgxKSkpIC8vIDE1ID4+PiAxID0gNyA7IHdpdGggZGl2aXNvciA9IDggOyB0cnVlXHJcbiAgICAgICAgICAgIHJldHVybiBVT05FO1xyXG4gICAgICAgIHJlcyA9IFVaRVJPO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlcGVhdCB0aGUgZm9sbG93aW5nIHVudGlsIHRoZSByZW1haW5kZXIgaXMgbGVzcyB0aGFuIG90aGVyOiAgZmluZCBhXHJcbiAgICAvLyBmbG9hdGluZy1wb2ludCB0aGF0IGFwcHJveGltYXRlcyByZW1haW5kZXIgLyBvdGhlciAqZnJvbSBiZWxvdyosIGFkZCB0aGlzXHJcbiAgICAvLyBpbnRvIHRoZSByZXN1bHQsIGFuZCBzdWJ0cmFjdCBpdCBmcm9tIHRoZSByZW1haW5kZXIuICBJdCBpcyBjcml0aWNhbCB0aGF0XHJcbiAgICAvLyB0aGUgYXBwcm94aW1hdGUgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSByZWFsIHZhbHVlIHNvIHRoYXQgdGhlXHJcbiAgICAvLyByZW1haW5kZXIgbmV2ZXIgYmVjb21lcyBuZWdhdGl2ZS5cclxuICAgIHJlbSA9IHRoaXM7XHJcbiAgICB3aGlsZSAocmVtLmd0ZShkaXZpc29yKSkge1xyXG4gICAgICAgIC8vIEFwcHJveGltYXRlIHRoZSByZXN1bHQgb2YgZGl2aXNpb24uIFRoaXMgbWF5IGJlIGEgbGl0dGxlIGdyZWF0ZXIgb3JcclxuICAgICAgICAvLyBzbWFsbGVyIHRoYW4gdGhlIGFjdHVhbCB2YWx1ZS5cclxuICAgICAgICBhcHByb3ggPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHJlbS50b051bWJlcigpIC8gZGl2aXNvci50b051bWJlcigpKSk7XHJcblxyXG4gICAgICAgIC8vIFdlIHdpbGwgdHdlYWsgdGhlIGFwcHJveGltYXRlIHJlc3VsdCBieSBjaGFuZ2luZyBpdCBpbiB0aGUgNDgtdGggZGlnaXQgb3JcclxuICAgICAgICAvLyB0aGUgc21hbGxlc3Qgbm9uLWZyYWN0aW9uYWwgZGlnaXQsIHdoaWNoZXZlciBpcyBsYXJnZXIuXHJcbiAgICAgICAgdmFyIGxvZzIgPSBNYXRoLmNlaWwoTWF0aC5sb2coYXBwcm94KSAvIE1hdGguTE4yKSxcclxuICAgICAgICAgICAgZGVsdGEgPSAobG9nMiA8PSA0OCkgPyAxIDogcG93X2RibCgyLCBsb2cyIC0gNDgpLFxyXG5cclxuICAgICAgICAvLyBEZWNyZWFzZSB0aGUgYXBwcm94aW1hdGlvbiB1bnRpbCBpdCBpcyBzbWFsbGVyIHRoYW4gdGhlIHJlbWFpbmRlci4gIE5vdGVcclxuICAgICAgICAvLyB0aGF0IGlmIGl0IGlzIHRvbyBsYXJnZSwgdGhlIHByb2R1Y3Qgb3ZlcmZsb3dzIGFuZCBpcyBuZWdhdGl2ZS5cclxuICAgICAgICAgICAgYXBwcm94UmVzID0gZnJvbU51bWJlcihhcHByb3gpLFxyXG4gICAgICAgICAgICBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpO1xyXG4gICAgICAgIHdoaWxlIChhcHByb3hSZW0uaXNOZWdhdGl2ZSgpIHx8IGFwcHJveFJlbS5ndChyZW0pKSB7XHJcbiAgICAgICAgICAgIGFwcHJveCAtPSBkZWx0YTtcclxuICAgICAgICAgICAgYXBwcm94UmVzID0gZnJvbU51bWJlcihhcHByb3gsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgICAgICBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gV2Uga25vdyB0aGUgYW5zd2VyIGNhbid0IGJlIHplcm8uLi4gYW5kIGFjdHVhbGx5LCB6ZXJvIHdvdWxkIGNhdXNlXHJcbiAgICAgICAgLy8gaW5maW5pdGUgcmVjdXJzaW9uIHNpbmNlIHdlIHdvdWxkIG1ha2Ugbm8gcHJvZ3Jlc3MuXHJcbiAgICAgICAgaWYgKGFwcHJveFJlcy5pc1plcm8oKSlcclxuICAgICAgICAgICAgYXBwcm94UmVzID0gT05FO1xyXG5cclxuICAgICAgICByZXMgPSByZXMuYWRkKGFwcHJveFJlcyk7XHJcbiAgICAgICAgcmVtID0gcmVtLnN1YihhcHByb3hSZW0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyBkaXZpZGVkIGJ5IHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZGl2aWRlfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUXVvdGllbnRcclxuICovXHJcbkxvbmdQcm90b3R5cGUuZGl2ID0gTG9uZ1Byb3RvdHlwZS5kaXZpZGU7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm1vZHVsbyA9IGZ1bmN0aW9uIG1vZHVsbyhkaXZpc29yKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhkaXZpc29yKSlcclxuICAgICAgICBkaXZpc29yID0gZnJvbVZhbHVlKGRpdmlzb3IpO1xyXG5cclxuICAgIC8vIHVzZSB3YXNtIHN1cHBvcnQgaWYgcHJlc2VudFxyXG4gICAgaWYgKHdhc20pIHtcclxuICAgICAgICB2YXIgbG93ID0gKHRoaXMudW5zaWduZWQgPyB3YXNtLnJlbV91IDogd2FzbS5yZW1fcykoXHJcbiAgICAgICAgICAgIHRoaXMubG93LFxyXG4gICAgICAgICAgICB0aGlzLmhpZ2gsXHJcbiAgICAgICAgICAgIGRpdmlzb3IubG93LFxyXG4gICAgICAgICAgICBkaXZpc29yLmhpZ2hcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc20uZ2V0X2hpZ2goKSwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuc3ViKHRoaXMuZGl2KGRpdmlzb3IpLm11bChkaXZpc29yKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbW9kdWxvfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm1vZCA9IExvbmdQcm90b3R5cGUubW9kdWxvO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIG1vZHVsbyB0aGUgc3BlY2lmaWVkLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI21vZHVsb30uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFJlbWFpbmRlclxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5yZW0gPSBMb25nUHJvdG90eXBlLm1vZHVsbztcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBiaXR3aXNlIE5PVCBvZiB0aGlzIExvbmcuXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICovXHJcbkxvbmdQcm90b3R5cGUubm90ID0gZnVuY3Rpb24gbm90KCkge1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKH50aGlzLmxvdywgfnRoaXMuaGlnaCwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgYml0d2lzZSBBTkQgb2YgdGhpcyBMb25nIGFuZCB0aGUgc3BlY2lmaWVkLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiBhbmQob3RoZXIpIHtcclxuICAgIGlmICghaXNMb25nKG90aGVyKSlcclxuICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgJiBvdGhlci5sb3csIHRoaXMuaGlnaCAmIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGJpdHdpc2UgT1Igb2YgdGhpcyBMb25nIGFuZCB0aGUgc3BlY2lmaWVkLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5vciA9IGZ1bmN0aW9uIG9yKG90aGVyKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhvdGhlcikpXHJcbiAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IHwgb3RoZXIubG93LCB0aGlzLmhpZ2ggfCBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBiaXR3aXNlIFhPUiBvZiB0aGlzIExvbmcgYW5kIHRoZSBnaXZlbiBvbmUuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIHhvcihvdGhlcikge1xyXG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyBeIG90aGVyLmxvdywgdGhpcy5oaWdoIF4gb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHNoaWZ0ZWQgdG8gdGhlIGxlZnQgYnkgdGhlIGdpdmVuIGFtb3VudC5cclxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc2hpZnRMZWZ0ID0gZnVuY3Rpb24gc2hpZnRMZWZ0KG51bUJpdHMpIHtcclxuICAgIGlmIChpc0xvbmcobnVtQml0cykpXHJcbiAgICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcclxuICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICBlbHNlIGlmIChudW1CaXRzIDwgMzIpXHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IDw8IG51bUJpdHMsICh0aGlzLmhpZ2ggPDwgbnVtQml0cykgfCAodGhpcy5sb3cgPj4+ICgzMiAtIG51bUJpdHMpKSwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKDAsIHRoaXMubG93IDw8IChudW1CaXRzIC0gMzIpLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgc2hpZnRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0TGVmdH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaGwgPSBMb25nUHJvdG90eXBlLnNoaWZ0TGVmdDtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgYXJpdGhtZXRpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC5cclxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc2hpZnRSaWdodCA9IGZ1bmN0aW9uIHNoaWZ0UmlnaHQobnVtQml0cykge1xyXG4gICAgaWYgKGlzTG9uZyhudW1CaXRzKSlcclxuICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xyXG4gICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMClcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIGVsc2UgaWYgKG51bUJpdHMgPCAzMilcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHMoKHRoaXMubG93ID4+PiBudW1CaXRzKSB8ICh0aGlzLmhpZ2ggPDwgKDMyIC0gbnVtQml0cykpLCB0aGlzLmhpZ2ggPj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCA+PiAobnVtQml0cyAtIDMyKSwgdGhpcy5oaWdoID49IDAgPyAwIDogLTEsIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBhcml0aG1ldGljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHR9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc2hyID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBsb2dpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC5cclxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkID0gZnVuY3Rpb24gc2hpZnRSaWdodFVuc2lnbmVkKG51bUJpdHMpIHtcclxuICAgIGlmIChpc0xvbmcobnVtQml0cykpXHJcbiAgICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcclxuICAgIG51bUJpdHMgJj0gNjM7XHJcbiAgICBpZiAobnVtQml0cyA9PT0gMClcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBoaWdoID0gdGhpcy5oaWdoO1xyXG4gICAgICAgIGlmIChudW1CaXRzIDwgMzIpIHtcclxuICAgICAgICAgICAgdmFyIGxvdyA9IHRoaXMubG93O1xyXG4gICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMoKGxvdyA+Pj4gbnVtQml0cykgfCAoaGlnaCA8PCAoMzIgLSBudW1CaXRzKSksIGhpZ2ggPj4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobnVtQml0cyA9PT0gMzIpXHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tQml0cyhoaWdoLCAwLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tQml0cyhoaWdoID4+PiAobnVtQml0cyAtIDMyKSwgMCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGxvZ2ljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHRVbnNpZ25lZH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaHJ1ID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQ7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGxvZ2ljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHRVbnNpZ25lZH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaHJfdSA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkO1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBzaWduZWQuXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gU2lnbmVkIGxvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9TaWduZWQgPSBmdW5jdGlvbiB0b1NpZ25lZCgpIHtcclxuICAgIGlmICghdGhpcy51bnNpZ25lZClcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCBmYWxzZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhpcyBMb25nIHRvIHVuc2lnbmVkLlxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFVuc2lnbmVkIGxvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9VbnNpZ25lZCA9IGZ1bmN0aW9uIHRvVW5zaWduZWQoKSB7XHJcbiAgICBpZiAodGhpcy51bnNpZ25lZClcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCB0cnVlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gaXRzIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGxlIFdoZXRoZXIgbGl0dGxlIG9yIGJpZyBlbmRpYW4sIGRlZmF1bHRzIHRvIGJpZyBlbmRpYW5cclxuICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gQnl0ZSByZXByZXNlbnRhdGlvblxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b0J5dGVzID0gZnVuY3Rpb24gdG9CeXRlcyhsZSkge1xyXG4gICAgcmV0dXJuIGxlID8gdGhpcy50b0J5dGVzTEUoKSA6IHRoaXMudG9CeXRlc0JFKCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBsaXR0bGUgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IExpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b0J5dGVzTEUgPSBmdW5jdGlvbiB0b0J5dGVzTEUoKSB7XHJcbiAgICB2YXIgaGkgPSB0aGlzLmhpZ2gsXHJcbiAgICAgICAgbG8gPSB0aGlzLmxvdztcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgbG8gICAgICAgICYgMHhmZixcclxuICAgICAgICBsbyA+Pj4gIDggJiAweGZmLFxyXG4gICAgICAgIGxvID4+PiAxNiAmIDB4ZmYsXHJcbiAgICAgICAgbG8gPj4+IDI0ICAgICAgICxcclxuICAgICAgICBoaSAgICAgICAgJiAweGZmLFxyXG4gICAgICAgIGhpID4+PiAgOCAmIDB4ZmYsXHJcbiAgICAgICAgaGkgPj4+IDE2ICYgMHhmZixcclxuICAgICAgICBoaSA+Pj4gMjRcclxuICAgIF07XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBiaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IEJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b0J5dGVzQkUgPSBmdW5jdGlvbiB0b0J5dGVzQkUoKSB7XHJcbiAgICB2YXIgaGkgPSB0aGlzLmhpZ2gsXHJcbiAgICAgICAgbG8gPSB0aGlzLmxvdztcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgaGkgPj4+IDI0ICAgICAgICxcclxuICAgICAgICBoaSA+Pj4gMTYgJiAweGZmLFxyXG4gICAgICAgIGhpID4+PiAgOCAmIDB4ZmYsXHJcbiAgICAgICAgaGkgICAgICAgICYgMHhmZixcclxuICAgICAgICBsbyA+Pj4gMjQgICAgICAgLFxyXG4gICAgICAgIGxvID4+PiAxNiAmIDB4ZmYsXHJcbiAgICAgICAgbG8gPj4+ICA4ICYgMHhmZixcclxuICAgICAgICBsbyAgICAgICAgJiAweGZmXHJcbiAgICBdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBMb25nIGZyb20gaXRzIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAqIEBwYXJhbSB7IUFycmF5LjxudW1iZXI+fSBieXRlcyBCeXRlIHJlcHJlc2VudGF0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHBhcmFtIHtib29sZWFuPX0gbGUgV2hldGhlciBsaXR0bGUgb3IgYmlnIGVuZGlhbiwgZGVmYXVsdHMgdG8gYmlnIGVuZGlhblxyXG4gKiBAcmV0dXJucyB7TG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tQnl0ZXMgPSBmdW5jdGlvbiBmcm9tQnl0ZXMoYnl0ZXMsIHVuc2lnbmVkLCBsZSkge1xyXG4gICAgcmV0dXJuIGxlID8gTG9uZy5mcm9tQnl0ZXNMRShieXRlcywgdW5zaWduZWQpIDogTG9uZy5mcm9tQnl0ZXNCRShieXRlcywgdW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBMb25nIGZyb20gaXRzIGxpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cclxuICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IGJ5dGVzIExpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEByZXR1cm5zIHtMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21CeXRlc0xFID0gZnVuY3Rpb24gZnJvbUJ5dGVzTEUoYnl0ZXMsIHVuc2lnbmVkKSB7XHJcbiAgICByZXR1cm4gbmV3IExvbmcoXHJcbiAgICAgICAgYnl0ZXNbMF0gICAgICAgfFxyXG4gICAgICAgIGJ5dGVzWzFdIDw8ICA4IHxcclxuICAgICAgICBieXRlc1syXSA8PCAxNiB8XHJcbiAgICAgICAgYnl0ZXNbM10gPDwgMjQsXHJcbiAgICAgICAgYnl0ZXNbNF0gICAgICAgfFxyXG4gICAgICAgIGJ5dGVzWzVdIDw8ICA4IHxcclxuICAgICAgICBieXRlc1s2XSA8PCAxNiB8XHJcbiAgICAgICAgYnl0ZXNbN10gPDwgMjQsXHJcbiAgICAgICAgdW5zaWduZWRcclxuICAgICk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIExvbmcgZnJvbSBpdHMgYmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxyXG4gKiBAcGFyYW0geyFBcnJheS48bnVtYmVyPn0gYnl0ZXMgQmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHJldHVybnMge0xvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcclxuICovXHJcbkxvbmcuZnJvbUJ5dGVzQkUgPSBmdW5jdGlvbiBmcm9tQnl0ZXNCRShieXRlcywgdW5zaWduZWQpIHtcclxuICAgIHJldHVybiBuZXcgTG9uZyhcclxuICAgICAgICBieXRlc1s0XSA8PCAyNCB8XHJcbiAgICAgICAgYnl0ZXNbNV0gPDwgMTYgfFxyXG4gICAgICAgIGJ5dGVzWzZdIDw8ICA4IHxcclxuICAgICAgICBieXRlc1s3XSxcclxuICAgICAgICBieXRlc1swXSA8PCAyNCB8XHJcbiAgICAgICAgYnl0ZXNbMV0gPDwgMTYgfFxyXG4gICAgICAgIGJ5dGVzWzJdIDw8ICA4IHxcclxuICAgICAgICBieXRlc1szXSxcclxuICAgICAgICB1bnNpZ25lZFxyXG4gICAgKTtcclxufTtcclxuXG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTsiLCIvKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTksIExpdmlvLCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbipcbiogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4qIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuKlxuKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4qIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4qIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZVxuKiBkaXN0cmlidXRpb24uXG4qXG4qIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIExpdmlvIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzXG4qIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZVxuKiB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbipcbiogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiogQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuKiBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFXG4qIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1JcbiogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcbiogU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXG4qIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOXG4qIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4qIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4qIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cblxuLy8gaW1wb3J0ICogYXMgQlNPTiBmcm9tICcuLy4uLy4uLy4uL3RoaXJkX3BhcnR5L2Jzb24uY29tbW9uLmpzJztcblxuLy8gY29uc29sZS5sb2coe0JTT059KTtcblxuaW1wb3J0IEJTT04gZnJvbSAnLi8uLi8uLi8uLi8uLi90aGlyZF9wYXJ0eS9ic29uLmNvbW1vbi5qcyc7XG5cbmNvbnN0IGJzb24gPSBCU09OLmJzb247XG5cbmNvbnNvbGUubG9nKHtCU09OfSxic29uKVxuXG5jbGFzcyBCc29uIHtcbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemUgYSBKYXZhc2NyaXB0IG9iamVjdC5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gb2JqZWN0IFRoZSBKYXZhc2NyaXB0IG9iamVjdCB0byBzZXJpYWxpemUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgU2VyaWFsaXplIG9wdGlvbnMuXG4gICAgICogQHJldHVybiBUaGUgQnVmZmVyIG9iamVjdCBjb250YWluaW5nIHRoZSBzZXJpYWxpemVkIG9iamVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgc2VyaWFsaXplIChvYmplY3QsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGJzb24uc2VyaWFsaXplKG9iamVjdCwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzZXJpYWxpemUgZGF0YSBhcyBCU09OLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSBidWZmZXIgVGhlIGJ1ZmZlciBjb250YWluaW5nIHRoZSBzZXJpYWxpemVkIHNldCBvZiBCU09OIGRvY3VtZW50cy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBEZXNlcmlhbGl6ZSBvcHRpb25zLlxuICAgICAqIEByZXR1cm5zIFRoZSBkZXNlcmlhbGl6ZWQgSmF2YXNjcmlwdCBPYmplY3QuXG4gICAgICovXG4gICAgc3RhdGljIGRlc2VyaWFsaXplIChvYmplY3QsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGJzb24uZGVzZXJpYWxpemUob2JqZWN0LCBvcHRpb25zKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IEJzb24gfTsiLCIvKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTksIExpdmlvLCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbipcbiogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4qIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuKlxuKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4qIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4qIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZVxuKiBkaXN0cmlidXRpb24uXG4qXG4qIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIExpdmlvIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzXG4qIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZVxuKiB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbipcbiogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiogQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuKiBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFXG4qIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1JcbiogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcbiogU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXG4qIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOXG4qIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4qIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4qIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cblxuaW1wb3J0IHsgRnJhbWVUeXBlIH0gZnJvbSAnLi9lbnVtcy9GcmFtZVR5cGUuanMnO1xuaW1wb3J0ICB7IEJzb24gfSBmcm9tICcuLy4uL3V0aWwvQnNvbi5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU2RsUGFja2V0XG4gKiBAcHJvcGVydHkge251bWJlcn0gRVhUUkFfUEFSQ0VMX0RBVEFfTEVOR1RIXG4gKiBAcHJvcGVydHkge251bWJlcn0gSEVBREVSX1NJWkVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBIRUFERVJfU0laRV9WMVxuICogQHByb3BlcnR5IHtudW1iZXJ9IEVOQ1JZUFRJT05fTUFTS1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFNFUlZJQ0VfVFlQRV9DT05UUk9MXG4gKiBAcHJvcGVydHkge251bWJlcn0gU0VSVklDRV9UWVBFX1JQQ1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFNFUlZJQ0VfVFlQRV9QQ01cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBTRVJWSUNFX1RZUEVfVklERU9cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBTRVJWSUNFX1RZUEVfQlVMS19EQVRBXG4gKiBAcHJvcGVydHkge251bWJlcn0gRlJBTUVfSU5GT19IRUFSVF9CRUFUXG4gKiBAcHJvcGVydHkge251bWJlcn0gRlJBTUVfSU5GT19TVEFSVF9TRVJWSUNFXG4gKiBAcHJvcGVydHkge251bWJlcn0gRlJBTUVfSU5GT19TVEFSVF9TRVJWSUNFX0FDS1xuICogQHByb3BlcnR5IHtudW1iZXJ9IEZSQU1FX0lORk9fU1RBUlRfU0VSVklDRV9OQUtcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBGUkFNRV9JTkZPX0VORF9TRVJWSUNFXG4gKiBAcHJvcGVydHkge251bWJlcn0gRlJBTUVfSU5GT19FTkRfU0VSVklDRV9BQ0tcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBGUkFNRV9JTkZPX0VORF9TRVJWSUNFX05BS1xuICogQHByb3BlcnR5IHtudW1iZXJ9IEZSQU1FX0lORk9fUkVHSVNURVJfU0VDT05EQVJZX1RSQU5TUE9SVFxuICogQHByb3BlcnR5IHtudW1iZXJ9IEZSQU1FX0lORk9fUkVHSVNURVJfU0VDT05EQVJZX1RSQU5TUE9SVF9BQ0tcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBGUkFNRV9JTkZPX1JFR0lTVEVSX1NFQ09OREFSWV9UUkFOU1BPUlRfTkFLXG4gKiBAcHJvcGVydHkge251bWJlcn0gRlJBTUVfSU5GT19UUkFOU1BPUlRfRVZFTlRfVVBEQVRFXG4gKiBAcHJvcGVydHkge251bWJlcn0gRlJBTUVfSU5GT19TRVJWSUNFX0RBVEFfQUNLXG4gKiBAcHJvcGVydHkge251bWJlcn0gRlJBTUVfSU5GT19IRUFSVF9CRUFUX0FDS1xuICogQHByb3BlcnR5IHtudW1iZXJ9IEZSQU1FX0lORk9fRklOQUxfQ09OTkVTQ1VUSVZFX0ZSQU1FXG4gKiBAcHJvcGVydHkge251bWJlcn0gRlJBTUVfSU5GT19SRVNFUlZFRFxuXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBnZXRWZXJzaW9uXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBnZXRFbmNyeXB0aW9uXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBnZXRTZXJ2aWNlVHlwZVxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gZ2V0RnJhbWVJbmZvXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBnZXRTZXNzaW9uSURcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IGdldE1lc3NhZ2VJRFxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gZ2V0RGF0YVNpemVcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IHNldFBheWxvYWRcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IGdldFBheWxvYWRcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IGdldEVuY3J5cHRpb25CaXRcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IGdldEZyYW1lVHlwZVxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gdG9VaW50OEFycmF5XG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSB0b1N0cmluZ1xuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gY29uc3RydWN0UGFja2V0XG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBwdXRUYWdcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IGdldFRhZ1xuICovXG5cbmNsYXNzIFNkbFBhY2tldCB7XG4gICAgLyoqXG4gICAgKiBAY29uc3RydWN0b3JcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSB2ZXJzaW9uIC0gUHJvdG9jb2wgdmVyc2lvbiB0byB1c2VcbiAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5jcnlwdGlvbiAtIFdoZXRoZXIgb3Igbm90IHRoZSBwYXlsb2FkIGluIHRoaXMgcGFja2V0IGlzIGVuY3J5cHRlZFxuICAgICogQHBhcmFtIHtGcmFtZVR5cGV9IGZyYW1lVHlwZSAtIEEgbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgcGFja2V0IGZyYW1lIHR5cGVcbiAgICAqIEBwYXJhbSB7U2VydmljZVR5cGV9IHNlcnZpY2VUeXBlIC0gVGhlIHNlcnZpY2UgdGhhdCB0aGlzIHBhY2tldCBpcyBhc3NvY2lhdGVkIHdpdGhcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBmcmFtZUluZm8gLSBTcGVjaWZpYyBmcmFtZSBpbmZvIHJlbGF0ZWQgdG8gdGhpcyBwYWNrZXRcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBzZXNzaW9uSUQgLSBJRCB0aGlzIHBhY2tldCBpcyBhc3NvY2lhdGVkIHdpdGhcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhU2l6ZSAtIFNpemUgb2YgdGhlIHBheWxvYWQgdGhhdCB3aWxsIGJlIGFkZGVkXG4gICAgKiBAcGFyYW0ge051bWJlcn0gbWVzc2FnZUlEIC0gSUQgb2YgdGhpcyBzcGVjaWZpYyBwYWNrZXRcbiAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gcGF5bG9hZCAtIFJhdyBkYXRhIHRoYXQgd2lsbCBiZSBhdHRhY2hlZCB0byB0aGUgcGFja2V0IChSUEMgbWVzc2FnZSwgcmF3IGJ5dGVzLCBldGMpXG4gICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0XG4gICAgKiBAcGFyYW0ge051bWJlcn0gYnl0ZXNUb1dyaXRlXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvciAodmVyc2lvbiA9IDEsIGVuY3J5cHRpb24gPSBmYWxzZSwgZnJhbWVUeXBlID0gLTEsIHNlcnZpY2VUeXBlID0gLTEsIGZyYW1lSW5mbyA9IC0xLCBzZXNzaW9uSWQgPSAwLCBkYXRhU2l6ZSA9IDAsIG1lc3NhZ2VJZCA9IDAsIHBheWxvYWQgPSBudWxsLCBvZmZzZXQgPSAwLCBieXRlc1RvV3JpdGUgPSAwKSB7XG4gICAgICAgIHRoaXMuX3ZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB0aGlzLl9lbmNyeXB0aW9uID0gZW5jcnlwdGlvbjtcbiAgICAgICAgdGhpcy5fZnJhbWVUeXBlID0gZnJhbWVUeXBlO1xuICAgICAgICB0aGlzLl9zZXJ2aWNlVHlwZSA9IHNlcnZpY2VUeXBlO1xuICAgICAgICB0aGlzLl9mcmFtZUluZm8gPSBmcmFtZUluZm87XG4gICAgICAgIHRoaXMuX3Nlc3Npb25JZCA9IHNlc3Npb25JZDtcbiAgICAgICAgdGhpcy5fZGF0YVNpemUgPSBkYXRhU2l6ZTtcbiAgICAgICAgdGhpcy5fbWVzc2FnZUlkID0gbWVzc2FnZUlkO1xuICAgICAgICB0aGlzLl9wYXlsb2FkID0gcGF5bG9hZDtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLl9ieXRlc1RvV3JpdGUgPSBieXRlc1RvV3JpdGU7XG5cbiAgICAgICAgdGhpcy5fYnNvblBheWxvYWQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKHBheWxvYWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3BheWxvYWQgPSBuZXcgVWludDhBcnJheShwYXlsb2FkLnNsaWNlKG9mZnNldCwgYnl0ZXNUb1dyaXRlICsgb2Zmc2V0KSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgIH1cblxuICAgIC8qKlxuICAgICogQHJldHVybiB7TnVtYmVyfSAtIFByb3RvY29sIHZlcnNpb24gdXNlZCBieSB0aGlzIHBhY2tldFxuICAgICovXG4gICAgZ2V0VmVyc2lvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92ZXJzaW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQHJldHVybiB7Qm9vbGVhbn0gLSBXaGV0aGVyIG9yIG5vdCB0aGUgcGF5bG9hZCBpbiB0aGlzIHBhY2tldCBpcyBlbmNyeXB0ZWRcbiAgICAqL1xuICAgIGdldEVuY3J5cHRpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5jcnlwdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEByZXR1cm4ge1NlcnZpY2VUeXBlfSAtIFRoZSBzZXJ2aWNlIHRoYXQgdGhpcyBwYWNrZXQgaXMgYXNzb2NpYXRlZCB3aXRoXG4gICAgKi9cbiAgICBnZXRTZXJ2aWNlVHlwZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXJ2aWNlVHlwZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEByZXR1cm4ge051bWJlcn0gLSBTcGVjaWZpYyBmcmFtZSBpbmZvIHJlbGF0ZWQgdG8gdGhpcyBwYWNrZXRcbiAgICAqL1xuICAgIGdldEZyYW1lSW5mbyAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mcmFtZUluZm87XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAcmV0dXJuIHtOdW1iZXJ9IC0gSUQgdGhpcyBwYWNrZXQgaXMgYXNzb2NpYXRlZCB3aXRoXG4gICAgKi9cbiAgICBnZXRTZXNzaW9uSWQgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2Vzc2lvbklkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQHJldHVybiB7TnVtYmVyfSAtIElEIG9mIHRoaXMgc3BlY2lmaWMgcGFja2V0XG4gICAgKi9cbiAgICBnZXRNZXNzYWdlSWQgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVzc2FnZUlkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQHJldHVybiB7TnVtYmVyfSAtIFNpemUgb2YgdGhlIHBheWxvYWQgdGhhdCB3aWxsIGJlIGFkZGVkXG4gICAgKi9cbiAgICBnZXREYXRhU2l6ZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhU2l6ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9IHBheWxvYWQgLSBSYXcgZGF0YSB0aGF0IHdpbGwgYmUgYXR0YWNoZWQgdG8gdGhlIHBhY2tldCAoUlBDIG1lc3NhZ2UsIHJhdyBieXRlcywgZXRjKVxuICAgICovXG4gICAgc2V0UGF5bG9hZCAocGF5bG9hZCkge1xuICAgICAgICB0aGlzLl9wYXlsb2FkID0gcGF5bG9hZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9IC0gUmF3IGRhdGEgdGhhdCB3aWxsIGJlIGF0dGFjaGVkIHRvIHRoZSBwYWNrZXQgKFJQQyBtZXNzYWdlLCByYXcgYnl0ZXMsIGV0YylcbiAgICAqL1xuICAgIGdldFBheWxvYWQgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGF5bG9hZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEByZXR1cm4ge051bWJlcn0gLSBSZXR1cm5zIGEgbnVtYmVyIHJlcHJlc2VudGluZyBhIGJ5dGUgbWFzayBkZXBlbmRpbmcgb24gdGhlIGJvb2xlYW4gdmFsdWVcbiAgICAqL1xuICAgIGdldEVuY3J5cHRpb25CaXQgKCkge1xuICAgICAgICByZXR1cm4gU2RsUGFja2V0LmdldEVuY3J5cHRpb25CaXQodGhpcy5fZW5jcnlwdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBlbmNyeXB0aW9uIFxuICAgICAqIEByZXR1cm4ge051bWJlcn0gLSBSZXR1cm5zIGEgbnVtYmVyIHJlcHJlc2VudGluZyBhIGJ5dGUgbWFzayBkZXBlbmRpbmcgb24gdGhlIGJvb2xlYW4gdmFsdWVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0RW5jcnlwdGlvbkJpdCAoZW5jcnlwdGlvbikge1xuICAgICAgICByZXR1cm4gZW5jcnlwdGlvbiA/IFNkbFBhY2tldC5FTkNSWVBUSU9OX01BU0sgOiAwO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAcmV0dXJuIHtGcmFtZVR5cGV9IC0gQSBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBwYWNrZXQgZnJhbWUgdHlwZVxuICAgICovXG4gICAgZ2V0RnJhbWVUeXBlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZyYW1lVHlwZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEByZXR1cm4ge1N0cmluZ30gLSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBhY2tldFxuICAgICovXG4gICAgdG9TdHJpbmcgKCkge1xuICAgICAgICBsZXQgb3V0cHV0ID0gJyoqKioqIFNkbCBQYWNrZXQgKioqKionO1xuICAgICAgICBvdXRwdXQgKz0gYFxcblZlcnNpb246ICR7dGhpcy5fdmVyc2lvbn1gO1xuICAgICAgICBvdXRwdXQgKz0gYFxcbkVuY3J5cHRpb246ICR7dGhpcy5fZW5jcnlwdGlvbn1gO1xuICAgICAgICBvdXRwdXQgKz0gYFxcbkZyYW1lVHlwZTogJHt0aGlzLl9mcmFtZVR5cGV9YDtcbiAgICAgICAgb3V0cHV0ICs9IGBcXG5TZXJ2aWNlVHlwZTogJHt0aGlzLl9zZXJ2aWNlVHlwZX1gO1xuICAgICAgICBvdXRwdXQgKz0gYFxcbkZyYW1lSW5mbzogJHt0aGlzLl9mcmFtZUluZm99YDtcbiAgICAgICAgb3V0cHV0ICs9IGBcXG5TZXNzaW9uSUQ6ICR7dGhpcy5fc2Vzc2lvbklEfWA7XG4gICAgICAgIG91dHB1dCArPSBgXFxuRGF0YVNpemU6ICR7dGhpcy5fZGF0YVNpemV9YDtcblxuICAgICAgICBpZiAodGhpcy5fdmVyc2lvbiA+IDEpIHtcbiAgICAgICAgICAgIG91dHB1dCArPSBgXFxuTWVzc2FnZUlEOiAke3RoaXMuX21lc3NhZ2VJRH1gO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0cHV0ICs9ICdcXG4qKioqKiBTZGwgUGFja2V0IEVuZCAqKioqKic7XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG5cbiAgICAvKipcblx0ICogVGhpcyBtZXRob2QgdGFrZXMgaW4gdGhlIHZhcmlvdXMgY29tcG9uZW50cyB0byB0aGUgU0RMIHBhY2tldCBzdHJ1Y3R1cmUgYW5kIGNyZWF0ZXMgYSBuZXcgYnl0ZSBhcnJheSB0aGF0IGNhbiBiZSBzZW50IHZpYSB0aGUgdHJhbnNwb3J0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZlcnNpb24gLSBQcm90b2NvbCB2ZXJzaW9uIHRvIHVzZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5jcnlwdGlvbiAtIFdoZXRoZXIgb3Igbm90IHRoZSBwYXlsb2FkIGluIHRoaXMgcGFja2V0IGlzIGVuY3J5cHRlZFxuICAgICAqIEBwYXJhbSB7RnJhbWVUeXBlfSBmcmFtZVR5cGUgLSBBIG51bWJlciByZXByZXNlbnRpbmcgdGhlIHBhY2tldCBmcmFtZSB0eXBlXG4gICAgICogQHBhcmFtIHtTZXJ2aWNlVHlwZX0gc2VydmljZVR5cGUgLSBUaGUgc2VydmljZSB0aGF0IHRoaXMgcGFja2V0IGlzIGFzc29jaWF0ZWQgd2l0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb250cm9sRnJhbWVJbmZvIC0gU3BlY2lmaWMgZnJhbWUgaW5mbyByZWxhdGVkIHRvIHRoaXMgcGFja2V0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNlc3Npb25JRCAtIElEIHRoaXMgcGFja2V0IGlzIGFzc29jaWF0ZWQgd2l0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhU2l6ZSAtIFNpemUgb2YgdGhlIHBheWxvYWQgdGhhdCB3aWxsIGJlIGFkZGVkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1lc3NhZ2VJRCAtIElEIG9mIHRoaXMgc3BlY2lmaWMgcGFja2V0XG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBwYXlsb2FkIC0gUmF3IGRhdGEgdGhhdCB3aWxsIGJlIGF0dGFjaGVkIHRvIHRoZSBwYWNrZXQgKFJQQyBtZXNzYWdlLCByYXcgYnl0ZXMsIGV0Yylcblx0ICogQHJldHVybiB7VWludDhBcnJheX0gLSBBIGJ5dGVbXSByZXByZXNlbnRhdGlvbiBvZiBhbiBTZGxQYWNrZXQgYnVpbHQgdXNpbmcgdGhlIHN1cHBsaWVkIHBhcmFtc1xuXHQgKi9cbiAgICBzdGF0aWMgY29uc3RydWN0UGFja2V0ICh2ZXJzaW9uLCBlbmNyeXB0aW9uLCBmcmFtZVR5cGUsIHNlcnZpY2VUeXBlLCBjb250cm9sRnJhbWVJbmZvLCBzZXNzaW9uSWQsIGRhdGFTaXplLCBtZXNzYWdlSWQsIHBheWxvYWQpIHtcbiAgICAgICAgbGV0IGRhdGFWaWV3ID0gbnVsbDtcbiAgICAgICAgbGV0IGRhdGFWaWV3SW5kZXggPSAwO1xuXG4gICAgICAgIGlmICh2ZXJzaW9uID4gMSkge1xuICAgICAgICAgICAgZGF0YVZpZXcgPSBuZXcgVWludDhBcnJheShTZGxQYWNrZXQuSEVBREVSX1NJWkUgKyBkYXRhU2l6ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhVmlldyA9IG5ldyBVaW50OEFycmF5KFNkbFBhY2tldC5IRUFERVJfU0laRV9WMSArIGRhdGFTaXplKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGFWaWV3W2RhdGFWaWV3SW5kZXgrK10gPSAodmVyc2lvbiA8PCA0KSArIHRoaXMuZ2V0RW5jcnlwdGlvbkJpdChlbmNyeXB0aW9uKSArIGZyYW1lVHlwZTtcbiAgICAgICAgZGF0YVZpZXdbZGF0YVZpZXdJbmRleCsrXSA9IHNlcnZpY2VUeXBlO1xuICAgICAgICBkYXRhVmlld1tkYXRhVmlld0luZGV4KytdID0gY29udHJvbEZyYW1lSW5mbztcbiAgICAgICAgZGF0YVZpZXdbZGF0YVZpZXdJbmRleCsrXSA9IHNlc3Npb25JZDtcbiAgICAgICAgZGF0YVZpZXdbZGF0YVZpZXdJbmRleCsrXSA9IChkYXRhU2l6ZSAmIDB4RkYwMDAwMDApID4+IDI0O1xuICAgICAgICBkYXRhVmlld1tkYXRhVmlld0luZGV4KytdID0gKGRhdGFTaXplICYgMHgwMEZGMDAwMCkgPj4gMTY7XG4gICAgICAgIGRhdGFWaWV3W2RhdGFWaWV3SW5kZXgrK10gPSAoZGF0YVNpemUgJiAweDAwMDBGRjAwKSA+PiA4O1xuICAgICAgICBkYXRhVmlld1tkYXRhVmlld0luZGV4KytdID0gZGF0YVNpemUgJiAweDAwMDAwMEZGO1xuXG4gICAgICAgIGlmICh2ZXJzaW9uID4gMSkge1xuICAgICAgICAgICAgZGF0YVZpZXdbZGF0YVZpZXdJbmRleCsrXSA9IChtZXNzYWdlSWQgJiAweEZGMDAwMDAwKSA+PiAyNDtcbiAgICAgICAgICAgIGRhdGFWaWV3W2RhdGFWaWV3SW5kZXgrK10gPSAobWVzc2FnZUlkICYgMHgwMEZGMDAwMCkgPj4gMTY7XG4gICAgICAgICAgICBkYXRhVmlld1tkYXRhVmlld0luZGV4KytdID0gKG1lc3NhZ2VJZCAmIDB4MDAwMEZGMDApID4+IDg7XG4gICAgICAgICAgICBkYXRhVmlld1tkYXRhVmlld0luZGV4KytdID0gbWVzc2FnZUlkICYgMHgwMDAwMDBGRjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXlsb2FkICE9PSBudWxsICYmIHBheWxvYWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZGF0YVZpZXcuc2V0KHBheWxvYWQsIGRhdGFWaWV3SW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGFWaWV3O1xuICAgIH1cblxuICAgIC8qKlxuXHQgKiBUaGlzIG1ldGhvZCB0YWtlcyBpbiB0aGUgdmFyaW91cyBjb21wb25lbnRzIHRvIHRoZSBTREwgcGFja2V0IHN0cnVjdHVyZSBhbmQgY3JlYXRlcyBhIG5ldyBieXRlIGFycmF5IHRoYXQgY2FuIGJlIHNlbnQgdmlhIHRoZSB0cmFuc3BvcnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmVyc2lvbiAtIFByb3RvY29sIHZlcnNpb24gdG8gdXNlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBlbmNyeXB0aW9uIC0gV2hldGhlciBvciBub3QgdGhlIHBheWxvYWQgaW4gdGhpcyBwYWNrZXQgaXMgZW5jcnlwdGVkXG4gICAgICogQHBhcmFtIHtGcmFtZVR5cGV9IGZyYW1lVHlwZSAtIEEgbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgcGFja2V0IGZyYW1lIHR5cGVcbiAgICAgKiBAcGFyYW0ge1NlcnZpY2VUeXBlfSBzZXJ2aWNlVHlwZSAtIFRoZSBzZXJ2aWNlIHRoYXQgdGhpcyBwYWNrZXQgaXMgYXNzb2NpYXRlZCB3aXRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbnRyb2xGcmFtZUluZm8gLSBTcGVjaWZpYyBmcmFtZSBpbmZvIHJlbGF0ZWQgdG8gdGhpcyBwYWNrZXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2Vzc2lvbklEIC0gSUQgdGhpcyBwYWNrZXQgaXMgYXNzb2NpYXRlZCB3aXRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGFTaXplIC0gU2l6ZSBvZiB0aGUgcGF5bG9hZCB0aGF0IHdpbGwgYmUgYWRkZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWVzc2FnZUlEIC0gSUQgb2YgdGhpcyBzcGVjaWZpYyBwYWNrZXRcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHBheWxvYWQgLSBSYXcgZGF0YSB0aGF0IHdpbGwgYmUgYXR0YWNoZWQgdG8gdGhlIHBhY2tldCAoUlBDIG1lc3NhZ2UsIHJhdyBieXRlcywgZXRjKVxuXHQgKiBAcmV0dXJuIHtVaW50OEFycmF5fSAtIEEgYnl0ZVtdIHJlcHJlc2VudGF0aW9uIG9mIGFuIFNkbFBhY2tldCBidWlsdCB1c2luZyB0aGUgc3VwcGxpZWQgcGFyYW1zXG5cdCAqL1xuICAgIGNvbnN0cnVjdFBhY2tldCAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9ic29uUGF5bG9hZCkge1xuICAgICAgICAgICAgdGhpcy5fcGF5bG9hZCA9IEJzb24uc2VyaWFsaXplKHRoaXMuX2Jzb25QYXlsb2FkKTtcbiAgICAgICAgICAgIHRoaXMuX2RhdGFTaXplID0gdGhpcy5fcGF5bG9hZC5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5jb25zdHJ1Y3RQYWNrZXQodGhpcy5fdmVyc2lvbiwgdGhpcy5fZW5jcnlwdGlvbiwgdGhpcy5fZnJhbWVUeXBlLCB0aGlzLl9zZXJ2aWNlVHlwZSwgdGhpcy5fZnJhbWVJbmZvLCB0aGlzLl9zZXNzaW9uSWQsIHRoaXMuX2RhdGFTaXplLCB0aGlzLl9tZXNzYWdlSWQsIHRoaXMuX3BheWxvYWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0YWcgLSBTdHJpbmcga2V5IHRvIGFkZCBhcyBhIHByb3BlcnR5IHRvIHRoZSBCU09OIG1hcFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gT2JqZWN0IHRvIGFkZCBhcyBhIHZhbHVlIHRvIHRoZSBCU09OIG1hcFxuICAgICAqL1xuICAgIHB1dFRhZyAodGFnLCBkYXRhKSB7XG4gICAgICAgIGlmICghdGhpcy5fYnNvblBheWxvYWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2Jzb25QYXlsb2FkID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYnNvblBheWxvYWRbdGFnXSA9IGRhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRhZyAtIFN0cmluZyBrZXkgdG8gYWRkIGFzIGEgcHJvcGVydHkgdG8gdGhlIEJTT04gbWFwXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBkYXRhIC0gT2JqZWN0IGFzIGEgdmFsdWUgZm91bmQgZnJvbSB0aGUgdGhlIEJTT04gbWFwXG4gICAgICovXG5cbiAgICBnZXRUYWcgKHRhZykge1xuICAgICAgICBpZiAoIXRoaXMuX2Jzb25QYXlsb2FkKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3BheWxvYWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2Jzb25QYXlsb2FkID0gQnNvbi5kZXNlcmlhbGl6ZSh0aGlzLl9wYXlsb2FkKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ic29uUGF5bG9hZFt0YWddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxufVxuXG5TZGxQYWNrZXQuRVhUUkFfUEFSQ0VMX0RBVEFfTEVOR1RIICAgICAgICAgICAgICAgICAgICAgID0gMjQ7XG5TZGxQYWNrZXQuSEVBREVSX1NJWkUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMTI7XG5TZGxQYWNrZXQuSEVBREVSX1NJWkVfVjEgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gODtcblNkbFBhY2tldC5FTkNSWVBUSU9OX01BU0sgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAweDA4O1xuXG4vKipcbiAqIFNlcnZpY2UgVHlwZVxuICovXG5TZGxQYWNrZXQuU0VSVklDRV9UWVBFX0NPTlRST0wgICAgICAgICAgICAgICAgICAgICAgICAgID0gMHgwMDtcbi8vIFJFU0VSVkVEIDB4MDEgLSAweDA2XG5TZGxQYWNrZXQuU0VSVklDRV9UWVBFX1JQQyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMHgwNztcbi8vIFJFU0VSVkVEIDB4MDggLSAweDA5XG5TZGxQYWNrZXQuU0VSVklDRV9UWVBFX1BDTSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMHgwQTtcblNkbFBhY2tldC5TRVJWSUNFX1RZUEVfVklERU8gICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAweDBCO1xuLy8gUkVTRVJWRUQgMHgwQyAtIDB4MEVcblNkbFBhY2tldC5TRVJWSUNFX1RZUEVfQlVMS19EQVRBICAgICAgICAgICAgICAgICAgICAgICAgPSAweDBGO1xuLy8gUkVTRVJWRUQgMHgxMCAtIDB4RkZcblxuLyoqXG4gKiBGcmFtZSBJbmZvXG4gKi9cblNkbFBhY2tldC5GUkFNRV9JTkZPX0hFQVJUX0JFQVQgICAgICAgICAgICAgICAgICAgICAgICAgPSAweDAwO1xuU2RsUGFja2V0LkZSQU1FX0lORk9fU1RBUlRfU0VSVklDRSAgICAgICAgICAgICAgICAgICAgICA9IDB4MDE7XG5TZGxQYWNrZXQuRlJBTUVfSU5GT19TVEFSVF9TRVJWSUNFX0FDSyAgICAgICAgICAgICAgICAgID0gMHgwMjtcblNkbFBhY2tldC5GUkFNRV9JTkZPX1NUQVJUX1NFUlZJQ0VfTkFLICAgICAgICAgICAgICAgICAgPSAweDAzO1xuU2RsUGFja2V0LkZSQU1FX0lORk9fRU5EX1NFUlZJQ0UgICAgICAgICAgICAgICAgICAgICAgICA9IDB4MDQ7XG5TZGxQYWNrZXQuRlJBTUVfSU5GT19FTkRfU0VSVklDRV9BQ0sgICAgICAgICAgICAgICAgICAgID0gMHgwNTtcblNkbFBhY2tldC5GUkFNRV9JTkZPX0VORF9TRVJWSUNFX05BSyAgICAgICAgICAgICAgICAgICAgPSAweDA2O1xuU2RsUGFja2V0LkZSQU1FX0lORk9fUkVHSVNURVJfU0VDT05EQVJZX1RSQU5TUE9SVCAgICAgICA9IDB4MDc7XG5TZGxQYWNrZXQuRlJBTUVfSU5GT19SRUdJU1RFUl9TRUNPTkRBUllfVFJBTlNQT1JUX0FDSyAgID0gMHgwODtcblNkbFBhY2tldC5GUkFNRV9JTkZPX1JFR0lTVEVSX1NFQ09OREFSWV9UUkFOU1BPUlRfTkFLICAgPSAweDA5O1xuLy8gMHgwQS0weEZDIGFyZSByZXNlcnZlZFxuU2RsUGFja2V0LkZSQU1FX0lORk9fVFJBTlNQT1JUX0VWRU5UX1VQREFURSAgICAgICAgICAgICA9IDB4RkQ7XG5TZGxQYWNrZXQuRlJBTUVfSU5GT19TRVJWSUNFX0RBVEFfQUNLICAgICAgICAgICAgICAgICAgID0gMHhGRTtcblNkbFBhY2tldC5GUkFNRV9JTkZPX0hFQVJUX0JFQVRfQUNLICAgICAgICAgICAgICAgICAgICAgPSAweEZGO1xuU2RsUGFja2V0LkZSQU1FX0lORk9fRklOQUxfQ09OTkVTQ1VUSVZFX0ZSQU1FICAgICAgICAgICA9IDB4MDA7XG5TZGxQYWNrZXQuRlJBTUVfSU5GT19SRVNFUlZFRCAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMHgwMDtcblxuZXhwb3J0IHsgU2RsUGFja2V0IH07XG4iLCIvKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTksIExpdmlvLCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbipcbiogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4qIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuKlxuKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4qIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4qIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZVxuKiBkaXN0cmlidXRpb24uXG4qXG4qIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIExpdmlvIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzXG4qIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZVxuKiB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbipcbiogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiogQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuKiBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFXG4qIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1JcbiogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcbiogU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXG4qIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOXG4qIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4qIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4qIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cblxuaW1wb3J0IHsgRW51bSB9IGZyb20gJy4uL3V0aWwvRW51bS5qcyc7XG5cbmNsYXNzIFJwY1N0cnVjdCB7XG5cbiAgICAvKipcbiAgICAqIEBjb25zdHJ1Y3RvclxuICAgICovXG4gICAgY29uc3RydWN0b3IocGFyYW1ldGVycyA9IHt9KSB7XG4gICAgICAgIHRoaXMuX2lzRm9ybWF0UmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3JwY1NwZWNWZXJzaW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcGFyYW1ldGVycyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocGFyYW1ldGVycyB8fCB7fSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICovXG4gICAgZ2V0UGFyYW1ldGVycygpIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5fcGFyYW1ldGVycykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgICogQHJldHVybiB7Kn1cbiAgICAqL1xuICAgIGdldFBhcmFtZXRlcihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtZXRlcnNba2V5XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAqIEByZXR1cm4ge1JwY1N0cnVjdH1cbiAgICAqL1xuICAgIHNldFBhcmFtZXRlcihrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3BhcmFtZXRlcnNba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcmFtZXRlcnNba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0Q2xhc3NcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAqL1xuICAgIGdldE9iamVjdCh0Q2xhc3MsIGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXRPYmplY3QodENsYXNzLCB0aGlzLmdldFBhcmFtZXRlcihrZXkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHRDbGFzc1xuICAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgICogQHJldHVybiB7bnVsbHxPYmplY3R9XG4gICAgKi9cbiAgICBmb3JtYXRPYmplY3QodENsYXNzLCBvYmopIHtcbiAgICAgICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAob2JqLmNvbnN0cnVjdG9yID09PSB0Q2xhc3MpIHtcbiAgICAgICAgICAgIC8vIGlmIHRDbGFzcyBpcyBTdHJpbmcgYW5kIG9iaiBpcyBhIFN0cmluZywgdGhpcyBzaG91bGQgZXhlY3V0ZVxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfSBlbHNlIGlmIChvYmouY29uc3RydWN0b3IgPT09IFN0cmluZykge1xuICAgICAgICAgICAgaWYgKHRDbGFzcyBpbnN0YW5jZW9mIEVudW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdENsYXNzLnZhbHVlRm9yU3RyaW5nKG9iaik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRDbGFzcyBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgbWF5IGJlIHJlZHVuZGFudFxuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChvYmouY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICAgICAgaWYgKHRDbGFzcyBpbnN0YW5jZW9mIFJwY1N0cnVjdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdENsYXNzKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChvYmouY29uc3RydWN0b3IgPT09IEFycmF5KSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBlbnN1cmUgY29tcGxldGVuZXNzXG4gICAgICAgICAgICBpZiAob2JqLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgb3V0QXJyYXkgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGl0ZW0gaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dEFycmF5LnB1c2godGhpcy5mb3JtYXRPYmplY3QodGNsYXNzLCBpdGVtKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBvdXRBcnJheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHRDbGFzc1xuICAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgICovXG4gICAgdmFsaWRhdGVUeXBlKHRDbGFzcywgb2JqKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICh0Q2xhc3MgaW5zdGFuY2VvZiBFbnVtICYmIHRDbGFzcy52YWx1ZUZvclN0cmluZyhvYmopID09PSBudWxsKVxuICAgICAgICAgICAgfHwgKG9iaiAhPT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT09IHRDbGFzcylcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aHJvdyBgJHtvYmoubmFtZX0gbXVzdCBiZSBvZiB0eXBlICR7dENsYXNzLm5hbWV9YDtcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5leHBvcnQgeyBScGNTdHJ1Y3QgfTsiLCIvKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTksIExpdmlvLCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbipcbiogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4qIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuKlxuKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4qIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4qIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZVxuKiBkaXN0cmlidXRpb24uXG4qXG4qIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIExpdmlvIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzXG4qIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZVxuKiB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbipcbiogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiogQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuKiBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFXG4qIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1JcbiogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcbiogU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXG4qIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOXG4qIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4qIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4qIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cblxuaW1wb3J0IHsgUnBjU3RydWN0IH0gZnJvbSAnLi9ScGNTdHJ1Y3QuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFJwY01lc3NhZ2VcbiAqIEBwcm9wZXJ0eSB7UnBjVHlwZX0gcnBjVHlwZVxuICovXG5jbGFzcyBScGNNZXNzYWdlIGV4dGVuZHMgUnBjU3RydWN0IHtcblxuICAgIC8qXG4gICAge1xuICAgICAgICBcInJwY1R5cGVcIjogXCJSZXF1ZXN0XCIsXG4gICAgICAgIFwiZnVuY3Rpb25OYW1lXCI6IFwiUmVnaXN0ZXJBcHBJbnRlcmZhY2VcIixcbiAgICAgICAgXCJjb29yZWxhdGlvbklEXCI6IFwiMzIwOTQ4XCIsXG4gICAgICAgIFwiaXNFbmNyeXB0ZWRcIjogZmFsc2UsXG4gICAgICAgIFwicGFyYW1ldGVyc1wiOiB7XG4gICAgICAgICAgICBcImFwcE5hbWVcIjogXCJIZWxsb1wiXG4gICAgICAgIH0sXG4gICAgICAgIFwiYnVsa0RhdGFcIjogXCIuLi5cIixcbiAgICB9XG4gICAgKi9cblxuICAgIC8qKlxuICAgICogQGNvbnN0cnVjdG9yXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzdG9yZSA9IHt9KSB7XG4gICAgICAgIHN1cGVyKHN0b3JlLnBhcmFtZXRlcnMpO1xuICAgICAgICB0aGlzLl9pc0VuY3J5cHRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9ycGNUeXBlID0gc3RvcmUucnBjVHlwZTtcbiAgICAgICAgdGhpcy5fZnVuY3Rpb25OYW1lID0gc3RvcmUuZnVuY3Rpb25OYW1lO1xuICAgICAgICB0aGlzLl9jb3JyZWxhdGlvbklEID0gc3RvcmUuY29ycmVsYXRpb25JRDtcbiAgICAgICAgdGhpcy5fYnVsa0RhdGEgPSB0aGlzLnNldEJ1bGtEYXRhKHN0b3JlLmJ1bGtEYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEByZXR1cm4ge1JwY1R5cGV9XG4gICAgKi9cbiAgICBnZXRSUENUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcnBjVHlwZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7UnBjVHlwZX0gdHlwZVxuICAgICogQHJldHVybiB7UnBjTWVzc2FnZX1cbiAgICAqL1xuICAgIHNldFJQQ1R5cGUodHlwZSkge1xuICAgICAgICB0aGlzLl9ycGNUeXBlID0gdHlwZTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEByZXR1cm4ge1N0cmluZ30gdHlwZVxuICAgICovXG4gICAgZ2V0RnVuY3Rpb25OYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZnVuY3Rpb25OYW1lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAqIEByZXR1cm4ge1JwY01lc3NhZ2V9XG4gICAgKi9cbiAgICBzZXRGdW5jdGlvbk5hbWUobmFtZSkge1xuICAgICAgICB0aGlzLl9mdW5jdGlvbk5hbWUgPSBuYW1lO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQHJldHVybiB7VWludDhBcnJheX0gZGF0YVxuICAgICovXG4gICAgZ2V0QnVsa0RhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9idWxrRGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7VUludDhBcnJheX0gZGF0YVxuICAgICogQHJldHVybiB7UnBjTWVzc2FnZX1cbiAgICAqL1xuICAgIHNldEJ1bGtEYXRhKGRhdGEgPSBudWxsKSB7XG4gICAgICAgIGlmIChkYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9idWxrRGF0YSA9IGRhdGEuc2xpY2UoMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9idWxrRGF0YSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgKi9cbiAgICBnZXRJc0VuY3J5cHRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRW5jcnlwdGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQHBhcmFtIHtCb29sZWFufSBib29sXG4gICAgKiBAcmV0dXJuIHtScGNNZXNzYWdlfVxuICAgICovXG4gICAgc2V0SXNFbmNyeXB0ZWQoYm9vbCkge1xuICAgICAgICB0aGlzLl9pc0VuY3J5cHRlZCA9IGJvb2w7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG59XG5cbmV4cG9ydCB7IFJwY01lc3NhZ2UgfTtcbiIsIi8qXG4qIENvcHlyaWdodCAoYykgMjAxOSwgTGl2aW8sIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4qIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuKlxuKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiogbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4qXG4qIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiogdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiogZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlXG4qIGRpc3RyaWJ1dGlvbi5cbipcbiogTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgTGl2aW8gSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnNcbiogbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4qIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuKlxuKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuKiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4qIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4qIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkVcbiogTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRlxuKiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1NcbiogSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU5cbiogQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcbiogQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiogUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuXG5pbXBvcnQgeyBFbnVtIH0gZnJvbSAnLi4vLi4vdXRpbC9FbnVtLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7RW51bX0gU2VydmljZVR5cGVcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBNQVBcbiAqL1xuY2xhc3MgU2VydmljZVR5cGUgZXh0ZW5kcyBFbnVtIHtcblxuICAgIC8qKlxuICAgICogQGNvbnN0cnVjdG9yXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAqL1xuICAgIHN0YXRpYyBnZXQgQ09OVFJPTCgpIHtcbiAgICAgICAgcmV0dXJuIFNlcnZpY2VUeXBlLk1BUC5DT05UUk9MO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICovXG4gICAgc3RhdGljIGdldCBSUEMoKSB7XG4gICAgICAgIHJldHVybiBTZXJ2aWNlVHlwZS5NQVAuUlBDO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICovXG4gICAgc3RhdGljIGdldCBBVURJTygpIHtcbiAgICAgICAgcmV0dXJuIFNlcnZpY2VUeXBlLk1BUC5BVURJTztcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAqL1xuICAgIHN0YXRpYyBnZXQgVklERU8oKSB7XG4gICAgICAgIHJldHVybiBTZXJ2aWNlVHlwZS5NQVAuVklERU87XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgKi9cbiAgICBzdGF0aWMgZ2V0IEhZQlJJRCgpIHtcbiAgICAgICAgcmV0dXJuIFNlcnZpY2VUeXBlLk1BUC5IWUJSSUQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBDb25maXJtcyB3aGV0aGVyIHRoZSB2YWx1ZSBwYXNzZWQgaW4gZXhpc3RzIGluIHRoZSBFbnVtcyBvZiB0aGlzIGNsYXNzXG4gICAgKiBAcmV0dXJuIHtudWxsfE51bWJlcn0gLSBSZXR1cm5zIG51bGwgaWYgdGhlIGVudW0gdmFsdWUgZG9lc24ndCBleGlzdFxuICAgICovXG4gICAgc3RhdGljIHZhbHVlRm9yU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBTZXJ2aWNlVHlwZS5NQVApIHtcbiAgICAgICAgICAgIGlmIChTZXJ2aWNlVHlwZS5NQVBba2V5XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU2VydmljZVR5cGUuTUFQW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cblNlcnZpY2VUeXBlLk1BUCA9IE9iamVjdC5mcmVlemUoe1xuICAgICdDT05UUk9MJzogMHgwMCxcbiAgICAnUlBDJzogMHgwNyxcbiAgICAnQVVESU8nOiAweDBBLFxuICAgICdWSURFTyc6IDB4MEIsXG4gICAgJ0hZQlJJRCc6MHgwRixcbn0pO1xuXG5leHBvcnQgeyBTZXJ2aWNlVHlwZSB9O1xuIiwiLypcbiogQ29weXJpZ2h0IChjKSAyMDE5LCBMaXZpbywgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4qXG4qIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuKiBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbipcbiogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuKiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuKiBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGVcbiogZGlzdHJpYnV0aW9uLlxuKlxuKiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBMaXZpbyBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9yc1xuKiBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbiogd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4qXG4qIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4qIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiogQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRVxuKiBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4qIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GXG4qIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTU1xuKiBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTlxuKiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKVxuKiBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuKiBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cbmltcG9ydCB7IFJwY01lc3NhZ2UgfSBmcm9tICcuLi9ycGMvUnBjTWVzc2FnZS5qcydcbmltcG9ydCB7IFNkbFBhY2tldCB9IGZyb20gJy4vU2RsUGFja2V0LmpzJ1xuaW1wb3J0IHsgU2VydmljZVR5cGUgfSBmcm9tICcuL2VudW1zL1NlcnZpY2VUeXBlLmpzJztcblxuXG4vL1RPRE8gY2hlY2sgaG93IHRvIGhhbmRsZSB0aGUgcHJvcGVydHkvZnVuY3Rpb24gZXhwb3N1cmVcbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU2RsUHJvdG9jb2xMaXN0ZW5lclxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gc2V0T25ScGNNZXNzYWdlUmVjZWl2ZWRMaXN0ZW5lclxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gc2V0T25Db250cm9sU2VydmljZU1lc3NhZ2VSZWNlaXZlZExpc3RlbmVyXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBzZXRPbkRlY3J5cHRSZXF1ZXN0TGlzdGVuZXJcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IG9uQ29udHJvbFNlcnZpY2VNZXNzYWdlUmVjZWl2ZWRcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IG9uUnBjTWVzc2FnZVJlY2VpdmVkXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBvblN0YXJ0U2VydmljZUFDS1JlY2VpdmVkXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBvblN0YXJ0U2VydmljZU5BS1JlY2VpdmVkXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBvbkVuZFNlcnZpY2VBQ0tSZWNlaXZlZFxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gb25FbmRTZXJ2aWNlTkFLUmVjZWl2ZWRcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IG9uU2VydmljZUVuY3J5cHRpb25TdGFydGVkXG4gKi9cbmNsYXNzIFNkbFByb3RvY29sTGlzdGVuZXIge1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yIFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9vblJwY01lc3NhZ2VSZWNlaXZlZCA9IG51bGw7XG4gICAgICAgIHRoaXMuX29uQ29udHJvbFNlcnZpY2VNZXNzYWdlUmVjZWl2ZWQgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIFxuICAgICAqL1xuICAgIHNldE9uUnBjTWVzc2FnZVJlY2VpdmVkTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5fb25ScGNNZXNzYWdlUmVjZWl2ZWQgPSBsaXN0ZW5lcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciBcbiAgICAgKi9cbiAgICBzZXRPbkNvbnRyb2xTZXJ2aWNlTWVzc2FnZVJlY2VpdmVkTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5fb25Db250cm9sU2VydmljZU1lc3NhZ2VSZWNlaXZlZCA9IGxpc3RlbmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIFxuICAgICAqL1xuICAgIHNldE9uRGVjcnlwdFJlcXVlc3RMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9vbkRlY3J5cHRSZXF1ZXN0TGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICB9XG5cbiAgICAvL1RPRE8gYWRkIHRoZSBzZXR0ZXJzIGZvciB0aGUgYWRkZWQgZnVuY3Rpb25zXG5cbiAgICAvKlxuICAgICogTGlzdGVuZXIgbWV0aG9kcyB0byBiZSBjYWxsZWRcbiAgICAqXG4gICAgKi9cblxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTZGxQYWNrZXR9IHNkbFBhY2tldCBcbiAgICAgKi9cbiAgICBvbkNvbnRyb2xTZXJ2aWNlTWVzc2FnZVJlY2VpdmVkKHNkbFBhY2tldCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX29uQ29udHJvbFNlcnZpY2VNZXNzYWdlUmVjZWl2ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuX29uQ29udHJvbFNlcnZpY2VNZXNzYWdlUmVjZWl2ZWQoc2RsUGFja2V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UnBjTWVzc2FnZX0gcnBjTWVzc2FnZSBcbiAgICAgKi9cbiAgICBvblJwY01lc3NhZ2VSZWNlaXZlZChycGNNZXNzYWdlKXtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9vblJwY01lc3NhZ2VSZWNlaXZlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5fb25ScGNNZXNzYWdlUmVjZWl2ZWQocnBjTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U2RsUGFja2V0fSBzZGxQYWNrZXQgXG4gICAgICovXG4gICAgb25TdGFydFNlcnZpY2VBQ0tSZWNlaXZlZChzZGxQYWNrZXQpe1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX29uU3RhcnRTZXJ2aWNlQUNLUmVjZWl2ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuX29uU3RhcnRTZXJ2aWNlQUNLUmVjZWl2ZWQoc2RsUGFja2V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U2RsUGFja2V0fSBzZGxQYWNrZXQgXG4gICAgICovXG4gICAgb25TdGFydFNlcnZpY2VOQUtSZWNlaXZlZChzZGxQYWNrZXQpe1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX29uU3RhcnRTZXJ2aWNlTkFLUmVjZWl2ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuX29uU3RhcnRTZXJ2aWNlTkFLUmVjZWl2ZWQoc2RsUGFja2V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U2RsUGFja2V0fSBzZGxQYWNrZXQgXG4gICAgICovXG4gICAgb25FbmRTZXJ2aWNlQUNLUmVjZWl2ZWQoc2RsUGFja2V0KXtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9vbkVuZFNlcnZpY2VBQ0tSZWNlaXZlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5fb25FbmRTZXJ2aWNlQUNLUmVjZWl2ZWQoc2RsUGFja2V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U2RsUGFja2V0fSBzZGxQYWNrZXQgXG4gICAgICovXG4gICAgb25FbmRTZXJ2aWNlTkFLUmVjZWl2ZWQoc2RsUGFja2V0KXtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9vbkVuZFNlcnZpY2VOQUtSZWNlaXZlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5fb25FbmRTZXJ2aWNlTkFLUmVjZWl2ZWQoc2RsUGFja2V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U2VydmljZVR5cGV9IHNlcnZpY2VUeXBlIFxuICAgICAqL1xuICAgIG9uU2VydmljZUVuY3J5cHRpb25TdGFydGVkKHNlcnZpY2VUeXBlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vblNlcnZpY2VFbmNyeXB0aW9uU3RhcnRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5vblNlcnZpY2VFbmNyeXB0aW9uU3RhcnRlZChzZXJ2aWNlVHlwZSk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuXG5leHBvcnQgeyBTZGxQcm90b2NvbExpc3RlbmVyIH07IiwiLypcbiogQ29weXJpZ2h0IChjKSAyMDE5LCBMaXZpbywgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4qXG4qIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuKiBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbipcbiogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuKiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuKiBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGVcbiogZGlzdHJpYnV0aW9uLlxuKlxuKiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBMaXZpbyBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9yc1xuKiBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbiogd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4qXG4qIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4qIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiogQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRVxuKiBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4qIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GXG4qIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTU1xuKiBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTlxuKiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKVxuKiBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuKiBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cbmltcG9ydCB7IFNkbFBhY2tldCB9IGZyb20gJy4uL3Byb3RvY29sL1NkbFBhY2tldC5qcyc7XG5cbmNsYXNzIFRyYW5zcG9ydExpc3RlbmVyIHtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9vblRyYW5zcG9ydENvbm5lY3RlZCA9IG51bGw7XG4gICAgICAgIHRoaXMuX29uVHJhbnNwb3J0RGlzY29ubmVjdGVkID0gbnVsbDtcbiAgICAgICAgdGhpcy5fb25FcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMuX29uUGFja2V0UmVjZWl2ZWQgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmNcbiAgICAgKiBAcmV0dXJuIHtUcmFuc3BvcnRMaXN0ZW5lcn1cbiAgICAgKi9cbiAgICBzZXRPblRyYW5zcG9ydENvbm5lY3RlZChmdW5jKSB7XG4gICAgICAgIHRoaXMuX29uVHJhbnNwb3J0Q29ubmVjdGVkID0gZnVuYztcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jXG4gICAgICogQHJldHVybiB7VHJhbnNwb3J0TGlzdGVuZXJ9XG4gICAgICovXG4gICAgc2V0T25UcmFuc3BvcnREaXNjb25uZWN0ZWQoZnVuYykge1xuICAgICAgICB0aGlzLl9vblRyYW5zcG9ydERpc2Nvbm5lY3RlZCA9IGZ1bmM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY1xuICAgICAqIEByZXR1cm4ge1RyYW5zcG9ydExpc3RlbmVyfVxuICAgICAqL1xuICAgIHNldE9uRXJyb3IoZnVuYykge1xuICAgICAgICB0aGlzLl9vbkVycm9yID0gZnVuYztcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jXG4gICAgICogQHJldHVybiB7VHJhbnNwb3J0TGlzdGVuZXJ9XG4gICAgICovXG4gICAgc2V0T25QYWNrZXRSZWNlaXZlZChmdW5jKSB7XG4gICAgICAgIHRoaXMuX29uUGFja2V0UmVjZWl2ZWQgPSBmdW5jO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIFxuICAgIG9uVHJhbnNwb3J0Q29ubmVjdGVkKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX29uVHJhbnNwb3J0Q29ubmVjdGVkID09PSAnZnVuY3Rpb24nICkge1xuICAgICAgICAgICAgdGhpcy5fb25UcmFuc3BvcnRDb25uZWN0ZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uVHJhbnNwb3J0RGlzY29ubmVjdGVkKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX29uVHJhbnNwb3J0RGlzY29ubmVjdGVkID09PSAnZnVuY3Rpb24nICkge1xuICAgICAgICAgICAgdGhpcy5fb25UcmFuc3BvcnREaXNjb25uZWN0ZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uRXJyb3IoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5fb25FcnJvciA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgICAgICAgIHRoaXMuX29uRXJyb3IoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uUGFja2V0UmVjZWl2ZWQoc2RsUGFja2V0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5fb25QYWNrZXRSZWNlaXZlZCA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgICAgICAgIHRoaXMuX29uUGFja2V0UmVjZWl2ZWQoc2RsUGFja2V0KTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5leHBvcnQgeyBUcmFuc3BvcnRMaXN0ZW5lciB9O1xuIiwiLypcbiogQ29weXJpZ2h0IChjKSAyMDE5LCBMaXZpbywgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4qXG4qIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuKiBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbipcbiogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuKiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuKiBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGVcbiogZGlzdHJpYnV0aW9uLlxuKlxuKiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBMaXZpbyBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9yc1xuKiBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbiogd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4qXG4qIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4qIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiogQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRVxuKiBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4qIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GXG4qIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTU1xuKiBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTlxuKiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKVxuKiBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuKiBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVHJhbnNwb3J0Q29uZmlnQmFzZVxuICogQHByb3BlcnR5IHtUcmFuc3BvcnRUeXBlfSBfdHJhbnNwb3J0VHlwZVxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZ2V0VHJhbnNwb3J0VHlwZVxuICovXG5jbGFzcyBUcmFuc3BvcnRDb25maWdCYXNlIHtcblxuXHQvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge1RyYW5zcG9ydFR5cGV9IHRyYW5zcG9ydFR5cGUgLSBlbnVtXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodHJhbnNwb3J0VHlwZSkge1xuICAgICAgICB0aGlzLl90cmFuc3BvcnRUeXBlID0gdHJhbnNwb3J0VHlwZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtUcmFuc3BvcnRUeXBlfVxuICAgICAqL1xuICAgIGdldFRyYW5zcG9ydFR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnRUeXBlO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgVHJhbnNwb3J0Q29uZmlnQmFzZSB9OyIsIi8qXG4qIENvcHlyaWdodCAoYykgMjAxOSwgTGl2aW8sIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4qIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuKlxuKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiogbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4qXG4qIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiogdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiogZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlXG4qIGRpc3RyaWJ1dGlvbi5cbipcbiogTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgTGl2aW8gSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnNcbiogbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4qIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuKlxuKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuKiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4qIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4qIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkVcbiogTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRlxuKiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1NcbiogSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU5cbiogQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcbiogQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiogUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuXG5jbGFzcyBWZXJzaW9uIHtcblxuICAgIC8qKlxuICAgICogQGNvbnN0cnVjdG9yXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtYWpvciwgbWlub3IsIHBhdGNoKSB7XG4gICAgICAgIHRoaXMuc2V0TWFqb3IobWFqb3IpO1xuICAgICAgICB0aGlzLnNldE1pbm9yKG1pbm9yKTtcbiAgICAgICAgdGhpcy5zZXRQYXRjaChwYXRjaCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge051bWJlcn0gbWFqb3JcbiAgICAqIEByZXR1cm4ge1ZlcnNpb259XG4gICAgKi9cbiAgICBzZXRNYWpvcihtYWpvcikge1xuICAgICAgICB0aGlzLl9tYWpvciA9IHBhcnNlSW50KG1ham9yKSB8fCAwO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICovXG4gICAgZ2V0TWFqb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYWpvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBtaW5vclxuICAgICogQHJldHVybiB7VmVyc2lvbn1cbiAgICAqL1xuICAgIHNldE1pbm9yKG1pbm9yKSB7XG4gICAgICAgIHRoaXMuX21pbm9yID0gcGFyc2VJbnQobWlub3IpIHx8IDA7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgKi9cbiAgICBnZXRNaW5vcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21pbm9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQHBhcmFtIHtOdW1iZXJ9IHBhdGNoXG4gICAgKiBAcmV0dXJuIHtWZXJzaW9ufVxuICAgICovXG4gICAgc2V0UGF0Y2gocGF0Y2gpIHtcbiAgICAgICAgdGhpcy5fcGF0Y2ggPSBwYXJzZUludChwYXRjaCkgfHwgMDtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAqL1xuICAgIGdldFBhdGNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGF0Y2g7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gdmVyc2lvbiAtIFBhcnNlIHRoaXMgc3RyaW5nIHRvIGEgVmVyc2lvbiBvYmplY3RcbiAgICAqIEByZXR1cm4ge1ZlcnNpb259XG4gICAgKi9cbiAgICBmcm9tU3RyaW5nKHZlcnNpb24pIHtcbiAgICAgICAgbGV0IHZlcnNpb25zID0gdmVyc2lvbi5zcGxpdChcIi5cIik7XG4gICAgICAgIGlmICh2ZXJzaW9ucy5sZW5ndGggIT0gMykgdGhyb3cgXCJJbmNvcnJlY3QgdmVyc2lvbiBzdHJpbmcgZm9ybWF0XCI7XG4gICAgICAgIHRoaXMuc2V0TWFqb3IodmVyc2lvbnNbMF0pO1xuICAgICAgICB0aGlzLnNldE1pbm9yKHZlcnNpb25zWzFdKTtcbiAgICAgICAgdGhpcy5zZXRQYXRjaCh2ZXJzaW9uc1syXSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuZ2V0TWFqb3IoKX0uJHt0aGlzLmdldE1pbm9yKCl9LiR7dGhpcy5nZXRQYXRjaCgpfWA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBNZXRob2QgdG8gdGVzdCBpZiB0aGlzIGluc3RhbmNlIG9mIFZlcnNpb24gaXMgbmV3ZXIgdGhhbiB0aGUgc3VwcGxpZWQgb25lLlxuICAgICogQHBhcmFtIHZlcnNpb24gLSB0aGUgdmVyc2lvbiB0byBjaGVjayBhZ2FpbnN0XG4gICAgKiBAcmV0dXJuIHtOdW1iZXJ9IC0gMSBpZiB0aGlzIGluc3RhbmNlIGlzIG5ld2VyLCAtMSBpZiBzdXBwbGllZCB2ZXJzaW9uIGlzIG5ld2VyLCBhbmQgMCBpZiB0aGV5IGFyZSBlcXVhbFxuICAgICovXG4gICAgaXNOZXdlclRoYW4odmVyc2lvbikge1xuICAgICAgICBpZih0aGlzLmdldE1ham9yKCkgPiB2ZXJzaW9uLmdldE1ham9yKCkpe1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1lbHNlIGlmKHRoaXMuZ2V0TWFqb3IoKSA9PSB2ZXJzaW9uLmdldE1ham9yKCkpe1xuICAgICAgICAgICAgaWYodGhpcy5nZXRNaW5vcigpID4gdmVyc2lvbi5nZXRNaW5vcigpKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZih0aGlzLmdldE1pbm9yKCkgPT0gdmVyc2lvbi5nZXRNaW5vcigpKXtcbiAgICAgICAgICAgICAgICBpZih0aGlzLmdldFBhdGNoKCkgPiB2ZXJzaW9uLmdldFBhdGNoKCkpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICB9ZWxzZSBpZih0aGlzLmdldFBhdGNoKCkgPT0gdmVyc2lvbi5nZXRQYXRjaCgpKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IFZlcnNpb24gfTsiLCIvKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTksIExpdmlvLCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbipcbiogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4qIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuKlxuKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4qIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4qIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZVxuKiBkaXN0cmlidXRpb24uXG4qXG4qIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIExpdmlvIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzXG4qIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZVxuKiB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbipcbiogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiogQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuKiBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFXG4qIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1JcbiogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcbiogU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXG4qIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOXG4qIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4qIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4qIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cblxuaW1wb3J0IHsgU2RsUHJvdG9jb2xMaXN0ZW5lciB9IGZyb20gJy4vU2RsUHJvdG9jb2xMaXN0ZW5lci5qcyc7XG5pbXBvcnQgeyBUcmFuc3BvcnRMaXN0ZW5lciB9IGZyb20gJy4uL3RyYW5zcG9ydC9UcmFuc3BvcnRMaXN0ZW5lci5qcydcbmltcG9ydCB7IFRyYW5zcG9ydENvbmZpZ0Jhc2UgfSBmcm9tICcuLi90cmFuc3BvcnQvVHJhbnNwb3J0Q29uZmlnQmFzZS5qcydcbmltcG9ydCB7IFZlcnNpb24gfSBmcm9tICcuLi91dGlsL1ZlcnNpb24uanMnXG5pbXBvcnQgeyBTZXJ2aWNlVHlwZSB9IGZyb20gJy4vZW51bXMvU2VydmljZVR5cGUuanMnXG5pbXBvcnQgeyBGcmFtZVR5cGUgfSBmcm9tICcuL2VudW1zL0ZyYW1lVHlwZS5qcydcbmltcG9ydCB7IE1lc3NhZ2VGcmFtZUFzc2VtYmxlciB9IGZyb20gJy4vTWVzc2FnZUZyYW1lQXNzZW1ibGVyLmpzJ1xuaW1wb3J0IHsgU2RsUGFja2V0IH0gZnJvbSAnLi9TZGxQYWNrZXQuanMnO1xuXG5jbGFzcyBTZGxQcm90b2NvbEJhc2Uge1xuXG4gICAgLyoqXG4gICAgICogXG4gICAgICogQHBhcmFtIHsgVHJhbnNwb3J0Q29uZmlnQmFzZSB9IGJhc2VUcmFuc3BvcnRDb25maWdcbiAgICAgKiBAcGFyYW0geyBTZGxQcm90b2NvbExpc3RlbmVyIH0gc2RsUHJvdG9jb2xMaXN0ZW5lclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGJhc2VUcmFuc3BvcnRDb25maWcsIHNkbFByb3RvY29sTGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0Q29uZmlnID0gYmFzZVRyYW5zcG9ydENvbmZpZztcbiAgICAgICAgdGhpcy5fc2RsUHJvdG9jb2xsaXN0ZW5lciA9IHNkbFByb3RvY29sTGlzdGVuZXI7XG4gICAgICAgIHJlc2V0KCk7XG5cbiAgICAgICAgX2NyZWF0ZVRyYW5zcG9ydExpc3RlbmVyKCk7XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydE1hbmFnZXIgPSBudWxsOyAvL1RoZSB0cmFuc3BvcnQgbWFuYWdlciBzaG91bGQgYmUgY3JlYXRlZFxuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdGVucyBmb3IgdHJhbnNwb3J0LXJlbGF0ZWQgZXZlbnRzIGFuZCBoYW5kbGVzIHRoZW0gaGVyZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZVRyYW5zcG9ydExpc3RlbmVyKCkge1xuICAgICAgICB0aGlzLl90cmFuc3BvcnRMaXN0ZW5lciA9IG5ldyBUcmFuc3BvcnRMaXN0ZW5lcigpO1xuICAgICAgICB0aGlzLl90cmFuc3BvcnRMaXN0ZW5lci5zZXRPblRyYW5zcG9ydENvbm5lY3RlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvL1RyYW5zcG9ydCBjb25uZWN0ZWRcbiAgICAgICAgICAgIC8vU3RhcnQgUlBDIHNlc3Npb25cblxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0TGlzdGVuZXIuc2V0T25UcmFuc3BvcnREaXNjb25uZWN0ZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy9UcmFuc3BvcnQgZGlzY29ubmVjdGVkXG4gICAgICAgICAgICAvL1NodXQgZXZlcnl0aGluZyBkb3duXG5cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydExpc3RlbmVyLnNldE9uUGFja2V0UmVjZWl2ZWQoZnVuY3Rpb24gKHNkbFBhY2tldCkge1xuICAgICAgICAgICAgLy9TZGxQYWNrZXQgcmVjZWl2ZWRcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZVBhY2tldFJlY2VpdmVkKHNkbFBhY2tldCk7IC8vQ291bGQganVzdCBwYXNzIGluIHRoaXMgZnVuY2l0b24gaW5zdGVhZCBvZiBjcmVhdGluZyBhbiBhbm9ueW1vdXNlIGZ1bmNpdG9uIHRvIGNhbGwgaXRcblxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0TGlzdGVuZXIuc2V0T25FcnJvcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvL0hhbmRsZSBlcnJvcj9cblxuICAgICAgICB9KTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyB1cCB0aGUgU0RMIHByb3RvY29sIGNsYXNzLiBJdCB3aWxsIGtpY2sgb2ZmIHRoZSB0cmFuc3BvcnQgbWFuYWdlciBhbmQgdW5kZXJseWluZyB0cmFuc3BvcnQuXG4gICAgICovXG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLl90cmFuc3BvcnRNYW5hZ2VyID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IFwidHJhbnNwb3J0IG1hbmFnZXIgd2FzIG51bGwsIHVuYWJsZSB0byBzdGFydCBTREwgUHJvdG9jb2xcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydE1hbmFnZXIuc3RhcnQoKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1NlcnZpY2VUeXBlfSBzZXJ2aWNlVHlwZSBcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IG1heCB0cmFuc3BvcnQgdW5pdCBmb3IgdGhlIGdpdmUgc2VydmljZSB0eXBlXG4gICAgICovXG4gICAgZ2V0TXR1KHNlcnZpY2VUeXBlKSB7XG4gICAgICAgIGxldCByZXRWYWwgPSB0aGlzLl9tdHVzLmdldChzZXJ2aWNlVHlwZSk7XG4gICAgICAgIGlmIChyZXRWYWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHJldFZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU2RsUHJvdG9jb2xCYXNlLlYxX1YyX01UVV9TSVpFO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IGlzQ29ubmVjdGVkXG4gICAgICovXG4gICAgaXNDb25uZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnRNYW5hZ2VyICE9IG51bGwgJiYgdGhpcy5fdHJhbnNwb3J0TWFuYWdlci5pc0Nvbm5lY3RlZChudWxsLCBudWxsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGludGVybmFsIGNsYXNzIG1lbWJlcnMgdG8gZGVmYXVsdCB2YWx1ZXNcbiAgICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5fcHJvdG9jb2xfdmVyc2lvbiA9IG5ldyBWZXJzaW9uKDEsIDAsIDApO1xuICAgICAgICB0aGlzLl90cmFuc3BvcnRDb25maWcgPSBiYXNlVHJhbnNwb3J0Q29uZmlnO1xuICAgICAgICB0aGlzLl9oZWFkZXJTaXplID0gU2RsUHJvdG9jb2xCYXNlLlYxX0hFQURFUl9TSVpFO1xuICAgICAgICB0aGlzLnNlcnZpY2VTdGF0dXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc2VydmljZVN0YXR1c1tTZXJ2aWNlVHlwZS5DT05UUk9MXSA9IHRydWU7XG4gICAgICAgIHRoaXMuX210dXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX210dXNbU2VydmljZVR5cGUuUlBDXSA9IFNkbFByb3RvY29sQmFzZS5WMV9WMl9NVFVfU0laRSAtIHRoaXMuX2hlYWRlclNpemU7XG4gICAgICAgIHRoaXMuX2hhc2hJRCA9IDA7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VJRCA9IDA7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VGcmFtZUFzc2VtYmxlcnMgPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7VmVyc2lvbn0gcHJvdG9jb2xfdmVyc2lvblxuICAgICAqL1xuICAgIGdldFByb3RvY29sVmVyc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3RvY29sX3ZlcnNpb247XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHNldCB0aGUgbWFqb3IgcHJvdG9jb2wgdmVyc2lvbiB0aGF0IHdlIHNob3VsZCB1c2UuIEl0IHdpbGwgYWxzbyBzZXQgdGhlIGRlZmF1bHQgTVRVIGJhc2VkIG9uIHZlcnNpb24uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZlcnNpb24gLSBtYWpvciB2ZXJzaW9uIHRvIHVzZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldFZlcnNpb24odmVyc2lvbikge1xuICAgICAgICBpZiAodmVyc2lvbiA+IDUpIHtcbiAgICAgICAgICAgIHRoaXMucHJvdG9jb2xWZXJzaW9uID0gbmV3IFZlcnNpb24oXCI1LjEuMFwiKTsgLy9wcm90ZWN0IGZvciBmdXR1cmUsIHByb3h5IG9ubHkgc3VwcG9ydHMgdjUgb3IgbG93ZXJcbiAgICAgICAgICAgIGhlYWRlclNpemUgPSBTZGxQcm90b2NvbEJhc2UuVjJfSEVBREVSX1NJWkU7XG4gICAgICAgICAgICBtdHVzW1NlcnZpY2VUeXBlLlJQQ10gPSBTZGxQcm90b2NvbEJhc2UuVjNfVjRfTVRVX1NJWkU7XG4gICAgICAgIH0gZWxzZSBpZiAodmVyc2lvbiA9PSA1KSB7XG4gICAgICAgICAgICB0aGlzLnByb3RvY29sVmVyc2lvbiA9IG5ldyBWZXJzaW9uKFwiNS4wLjBcIik7XG4gICAgICAgICAgICBoZWFkZXJTaXplID0gU2RsUHJvdG9jb2xCYXNlLlYyX0hFQURFUl9TSVpFO1xuICAgICAgICAgICAgbXR1c1tTZXJ2aWNlVHlwZS5SUENdID0gU2RsUHJvdG9jb2xCYXNlLlYzX1Y0X01UVV9TSVpFO1xuICAgICAgICB9IGVsc2UgaWYgKHZlcnNpb24gPT0gNCkge1xuICAgICAgICAgICAgdGhpcy5wcm90b2NvbFZlcnNpb24gPSBuZXcgVmVyc2lvbihcIjQuMC4wXCIpO1xuICAgICAgICAgICAgaGVhZGVyU2l6ZSA9IFNkbFByb3RvY29sQmFzZS5WMl9IRUFERVJfU0laRTtcbiAgICAgICAgICAgIG10dXNbU2VydmljZVR5cGUuUlBDXSA9IFNkbFByb3RvY29sQmFzZS5WM19WNF9NVFVfU0laRTsgLy92ZXJzaW9ucyA0IHN1cHBvcnRzIDEyOGsgTVRVXG4gICAgICAgIH0gZWxzZSBpZiAodmVyc2lvbiA9PSAzKSB7XG4gICAgICAgICAgICB0aGlzLnByb3RvY29sVmVyc2lvbiA9IG5ldyBWZXJzaW9uKFwiMy4wLjBcIik7XG4gICAgICAgICAgICBoZWFkZXJTaXplID0gU2RsUHJvdG9jb2xCYXNlLlYyX0hFQURFUl9TSVpFO1xuICAgICAgICAgICAgbXR1c1tTZXJ2aWNlVHlwZS5SUENdID0gU2RsUHJvdG9jb2xCYXNlLlYzX1Y0X01UVV9TSVpFOyAvL3ZlcnNpb25zIDMgc3VwcG9ydHMgMTI4ayBNVFVcbiAgICAgICAgfSBlbHNlIGlmICh2ZXJzaW9uID09IDIpIHtcbiAgICAgICAgICAgIHRoaXMucHJvdG9jb2xWZXJzaW9uID0gbmV3IFZlcnNpb24oXCIyLjAuMFwiKTtcbiAgICAgICAgICAgIGhlYWRlclNpemUgPSBTZGxQcm90b2NvbEJhc2UuVjJfSEVBREVSX1NJWkU7XG4gICAgICAgICAgICBtdHVzW1NlcnZpY2VUeXBlLlJQQ10gPSBTZGxQcm90b2NvbEJhc2UuVjFfVjJfTVRVX1NJWkUgLSBoZWFkZXJTaXplO1xuICAgICAgICB9IGVsc2UgaWYgKHZlcnNpb24gPT0gMSkge1xuICAgICAgICAgICAgdGhpcy5wcm90b2NvbFZlcnNpb24gPSBuZXcgVmVyc2lvbihcIjEuMC4wXCIpO1xuICAgICAgICAgICAgaGVhZGVyU2l6ZSA9IFNkbFByb3RvY29sQmFzZS5WMV9IRUFERVJfU0laRTtcbiAgICAgICAgICAgIG10dXNbU2VydmljZVR5cGUuUlBDXSA9IFNkbFByb3RvY29sQmFzZS5WMV9WMl9NVFVfU0laRSAtIGhlYWRlclNpemU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1NkbFBhY2tldH0gc2RsUGFja2V0XG4gICAgICovXG4gICAgc2VuZFBhY2tldChzZGxQYWNrZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyYW5zcG9ydE1hbmFnZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fdHJhbnNwb3J0TWFuYWdlci5zZW5kUGFja2V0KHNkbFBhY2tldCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1JwY01lc3NhZ2V9IHJwY01lc3NhZ2UgXG4gICAgICovXG4gICAgc2VuZFJwYyhycGNNZXNzYWdlKSB7XG4gICAgICAgIGlmIChycGNNZXNzYWdlICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vKHZlcnNpb24gPSAxLCBlbmNyeXB0aW9uID0gZmFsc2UsIGZyYW1lVHlwZSA9IC0xLCBzZXJ2aWNlVHlwZSA9IC0xLCBmcmFtZUluZm8gPSAtMSwgc2Vzc2lvbklEID0gMCwgZGF0YVNpemUgPSAwLCBtZXNzYWdlSUQgPSAwLCBwYXlsb2FkID0gbnVsbCwgb2Zmc2V0ID0gMCwgYnl0ZXNUb1dyaXRlID0gMCkge1xuXG4gICAgICAgICAgICBsZXQgcGFyYW1CeXRlcyA9IG5ldyBVaW50OEFycmF5KHJwY01lc3NhZ2UuZ2V0UGFyYW1ldGVycygpKTtcbiAgICAgICAgICAgIGxldCBzZGxQYWNrZXQgPSBuZXcgU2RsUGFja2V0KHRoaXMuX3Byb3RvY29sX3ZlcnNpb24uZ2V0TWFqb3IoKSwgZmFsc2UpO1xuICAgICAgICAgICAgLy9UT0RPOiBzZGxQYWNrZXQuc2V0XG5cblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBzZW5kTWVzc2FnZShwcm90b2NvbE1lc3NhZ2UpIHtcbiAgICAgICAgLy9UT0RPIFxuICAgICAgICAvLyBUaGlzIGlzIHRoZSBtZXRob2QgdGhhdCBoYW5kbGVzIGFsbCB0aGUgYnVpbGRpbmcgb2Ygc2RsIHBhY2tldHMgdGhhdCBnZXQgc2VudCBcbiAgICAgICAgLy8gaW4gdGhlIGphdmEgc3VpdGUgbGliLiBXZSB3YW50IHRvIGF2b2lkIHVzaW5nIHByb3RvY29sIG1lc3NhZ2UgaGVyZSBhcyBhbiBleHRyYSBcbiAgICAgICAgLy8gY2xhc3MgdGhhdCBkb2Vzbid0IG1ha2UgbXVjaCBzZW5zZS4gSSBiZWxpZXZlIHdlIHNob3VsZCBwcm9iYWJseSBhbHRlciBTZGxQYWNrZXRcbiAgICAgICAgLy8gdG8gaGFuZGxlIHRoZSBzaXR1YXRpb24gcHJvdG9jb2wgbWVzc2FnZSB1c2VkIHRvXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIGFuIFNkbFBhY2tldCBkZXBlbmRpbmcgb24gaXRzIEZyYW1lVHlwZVxuICAgICAqIEBwYXJhbSB7U2RsUGFja2V0fSBzZGxQYWNrZXQgXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaGFuZGxlUGFja2V0UmVjZWl2ZWQoc2RsUGFja2V0KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcm90b2NvbF92ZXJzaW9uID09IG51bGwgfHwgdGhpcy5fcHJvdG9jb2xfdmVyc2lvbi5nZXRNYWpvcigpID09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFZlcnNpb24ocGFja2V0LnZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZGxQYWNrZXQuZ2V0RnJhbWVUeXBlKCkgPT0gRnJhbWVUeXBlLkZJUlNUIHx8IHNkbFBhY2tldC5nZXRGcmFtZVR5cGUoKSA9PSBGcmFtZVR5cGUuQ09OU0VDVVRJVkUpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VGcmFtZUFzc2VtYmxlciA9IF9nZXRNZXNzYWdlRnJhbWVBc3NlbWJsZXIoc2RsUGFja2V0KTtcbiAgICAgICAgICAgIG1lc3NhZ2VGcmFtZUFzc2VtYmxlci5oYW5kbGVGcmFtZShzZGxQYWNrZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9QYWNrZXQgY2FuIGJlIGhhbmRsZWQgYXMgaXNcbiAgICAgICAgICAgIHN3aXRjaCAoc2RsUGFja2V0LmdldEZyYW1lVHlwZSgpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBGcmFtZVR5cGUuQ09OVFJPTDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlQ29udHJvbFBhY2tldChzZGxQYWNrZXQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEZyYW1lVHlwZS5TSU5HTEU6XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc2RsUGFja2V0LmdldFNlcnZpY2VUeXBlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU2VydmljZVR5cGUuUlBDOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZVJQQ1BhY2tldChzZGxQYWNrZXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U2RsUGFja2V0fSBzZGxQYWNrZXQgXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0TWVzc2FnZUZyYW1lQXNzZW1ibGVyKHNkbFBhY2tldCkge1xuICAgICAgICBsZXQgbWVzc2FnZUZyYW1lQXNzZW1ibGVyID0gdGhpcy5fbWVzc2FnZUZyYW1lQXNzZW1ibGVyc1tzZGxQYWNrZXQuZ2V0TWVzc2FnZUlEKCldO1xuICAgICAgICBpZiAobWVzc2FnZUZyYW1lQXNzZW1ibGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VGcmFtZUFzc2VtYmxlciA9IE1lc3NhZ2VGcmFtZUFzc2VtYmxlcih0aGlzLl9oZWFkZXJTaXplLCBuZXcgZnVuY3Rpb24gKHNkbFBhY2tldCkge1xuICAgICAgICAgICAgICAgIC8vVE9ET1xuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSB3YW50IHRvIHBhc3MgYmFjayBhbiBTREwgUGFja2V0LiBcblxuICAgICAgICAgICAgICAgIHRoaXMuX21lc3NhZ2VGcmFtZUFzc2VtYmxlcnNbc2RsUGFja2V0LmdldE1lc3NhZ2VJRCgpXSA9IG51bGw7IC8vUmVtb3ZlIHRoZSBtYXBwaW5nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX21lc3NhZ2VGcmFtZUFzc2VtYmxlcnNbc2RsUGFja2V0LmdldE1lc3NhZ2VJRCgpXSA9IG1lc3NhZ2VGcmFtZUFzc2VtYmxlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZXNzYWdlRnJhbWVBc3NlbWJsZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBoYW5kbGUgY29udHJvbCBwYWNrZXRzIGZvciBhbGwgc2VydmljZSB0eXBlc1xuICAgICAqIEBwYXJhbSB7U2RsUGFja2V0fSBzZGxQYWNrZXQgXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaGFuZGxlQ29udHJvbFBhY2tldChzZGxQYWNrZXQpIHtcbiAgICAgICAgbGV0IHNlcnZpY2VUeXBlID0gc2RsUGFja2V0LmdldFNlcnZpY2VUeXBlKCk7XG4gICAgICAgIGxldCBmcmFtZUluZm8gPSBzZGxQYWNrZXQuZ2V0RnJhbWVJbmZvKCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0gc2RsUGFja2V0LmdldFBheWxvYWQoKTtcblxuICAgICAgICBzd2l0Y2ggKGZyYW1lSW5mbykge1xuICAgICAgICAgICAgY2FzZSBzZGxQYWNrZXQuRlJBTUVfSU5GT19TVEFSVF9TRVJWSUNFX0FDSzpcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVTdGFydFNlcnZpY2VBQ0soc2RsUGFja2V0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugc2RsUGFja2V0LkZSQU1FX0lORk9fU1RBUlRfU0VSVklDRV9OQUs6XG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlU3RhcnRTZXJ2aWNlTkFLKHNkbFBhY2tldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHNkbFBhY2tldC5GUkFNRV9JTkZPX0VORF9TRVJWSUNFX0FDSzpcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVFbmRTZXJ2aWNlQUNLKHNkbFBhY2tldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHNkbFBhY2tldC5GUkFNRV9JTkZPX0VORF9TRVJWSUNFX05BSzpcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVFbmRTZXJ2aWNlQUNLKHNkbFBhY2tldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U2RsUGFja2V0fSBzZGxQYWNrZXQgXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaGFuZGxlU3RhcnRTZXJ2aWNlQUNLKHNkbFBhY2tldCkge1xuICAgICAgICAvL1RPRE9cbiAgICAgICAgLy9IYW5kbGUgdGhpbmdzIGludGVybmFsbHkgZmlyc3RcbiAgICAgICAgc3dpdGNoIChzZXJ2aWNlVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBTZXJ2aWNlVHlwZS5SUEM6XG4gICAgICAgICAgICBjYXNlIFNlcnZpY2VUeXBlLkNPTlRST0w6XG4gICAgICAgICAgICBjYXNlIFNlcnZpY2VUeXBlLkhZQlJJRDpcbiAgICAgICAgICAgIGNhc2UgU2VydmljZVR5cGUuQVVESU86XG4gICAgICAgICAgICBjYXNlIFNlcnZpY2VUeXBlLlZJREVPOlxuICAgICAgICB9XG5cbiAgICAgICAgLy9UaGVuIGNhbGwgdGhlIGxpc3RlbmVyIChzaG91bGQgYmUgU2RsU2Vzc2lvbilcbiAgICAgICAgaWYgKHRoaXMuX3NkbFByb3RvY29sbGlzdGVuZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fc2RsUHJvdG9jb2xsaXN0ZW5lci5vblN0YXJ0U2VydmljZUFDS1JlY2VpdmVkKHNkbFBhY2tldCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1NkbFBhY2tldH0gc2RsUGFja2V0IFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2hhbmRsZVN0YXJ0U2VydmljZU5BSyhzZGxQYWNrZXQpIHtcbiAgICAgICAgLy9UT0RPXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTZGxQYWNrZXR9IHNkbFBhY2tldCBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9oYW5kbGVFbmRTZXJ2aWNlQUNLKHNkbFBhY2tldCkge1xuICAgICAgICAvL1RPRE9cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1NkbFBhY2tldH0gc2RsUGFja2V0IFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2hhbmRsZUVuZFNlcnZpY2VOQUsoc2RsUGFja2V0KSB7XG4gICAgICAgIC8vVE9ET1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTZGxQYWNrZXR9IHNkbFBhY2tldCBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9oYW5kbGVDb250cm9sU2VydmljZVBhY2tldChzZGxQYWNrZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NkbFByb3RvY29sbGlzdGVuZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fc2RsUHJvdG9jb2xsaXN0ZW5lci5vbkNvbnRyb2xTZXJ2aWNlTWVzc2FnZVJlY2VpdmVkKHNkbFBhY2tldCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1NkbFBhY2tldH0gc2RsUGFja2V0IFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2hhbmRsZVJQQ1BhY2tldChzZGxQYWNrZXQpIHtcbiAgICAgICAgbGV0IHBheWxvYWQgPSBzZGxQYWNrZXQuZ2V0UGF5bG9hZCgpO1xuICAgICAgICAvLyBUT0RPIHBvc3NpYmx5IGFkZCBlcnJvciBjaGVja2luZyB0aGF0IGVuc3VyZXMgdGhpcyBpcyBhbiBSUEMgcGFja2V0XG4gICAgICAgIGxldCBycGNNZXNzYWdlID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuX3Byb3RvY29sX3ZlcnNpb24uZ2V0TWFqb3IoKSA9PSAxKSB7XG4gICAgICAgICAgICAvL1RoZXJlIGlzIG5vIGJpbmFyeSBmcmFtZSBoZWFkZXJcblxuICAgICAgICB9XG4gICAgICAgIC8vVE9ETyBhY3R1YWxseSBjcmVhdGUgdGhlIFJQQyBtZXNzYWdlXG5cbiAgICAgICAgaWYgKHRoaXMuX3NkbFByb3RvY29sbGlzdGVuZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fc2RsUHJvdG9jb2xsaXN0ZW5lci5vblJwY01lc3NhZ2VSZWNlaXZlZChycGNNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG5cbiAgICAvL05vdCBzdXJlIGlmIHdlIG5lZWRcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Kn0gc2Vzc2lvbklEIFxuICAgICAqIEBwYXJhbSB7Kn0gX2hhc2hJRCBcbiAgICAgKi9cbiAgICBlbmRTZXNzaW9uKHNlc3Npb25JRCwgX2hhc2hJRCkgeyB9O1xuXG59XG5cbi8qKlxuICogT3JpZ2luYWwgaGVhZGVyIHNpemUgYmFzZWQgb24gdmVyc2lvbiAxLjAuMCBvbmx5XG4gKi9cblNkbFByb3RvY29sQmFzZS5WMV9IRUFERVJfU0laRSAgICAgICAgICAgICAgPSA4O1xuLyoqXG4gKiBMYXJnZXIgaGVhZGVyIHNpemUgdGhhdCBpcyB1c2VkIGJ5IHZlcnNpb25zIDIuMC4wIGFuZCB1cFxuICovXG5TZGxQcm90b2NvbEJhc2UuVjJfSEVBREVSX1NJWkUgICAgICAgICAgICAgID0gMTI7XG5TZGxQcm90b2NvbEJhc2UuVjFfVjJfTVRVX1NJWkUgICAgICAgICAgICAgID0gMTUwMDtcblNkbFByb3RvY29sQmFzZS5WM19WNF9NVFVfU0laRSAgICAgICAgICAgICAgPSAxMzEwNzI7XG4vKipcbiAqIE1heCBzdXBwb3J0ZWQgcHJvdG9jb2wgdmVyc2lvbiBpbiB0aGlzIHJlbGVhc2Ugb2YgdGhlIGxpYnJhcnlcbiovXG5TZGxQcm90b2NvbEJhc2UuTUFYX1BST1RPQ09MX1ZFUlNJT04gICAgICAgID0gbmV3IFZlcnNpb24oNSwgMiwgMCk7XG5cbmV4cG9ydCB7IFNkbFByb3RvY29sQmFzZSB9O1xuIiwiLypcbiogQ29weXJpZ2h0IChjKSAyMDE5LCBMaXZpbywgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4qXG4qIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuKiBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbipcbiogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuKiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuKiBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGVcbiogZGlzdHJpYnV0aW9uLlxuKlxuKiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBMaXZpbyBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9yc1xuKiBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbiogd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4qXG4qIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4qIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiogQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRVxuKiBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4qIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GXG4qIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTU1xuKiBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTlxuKiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKVxuKiBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuKiBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cbmNsYXNzIENvbnRyb2xGcmFtZVRhZ3Mge1xufVxuXG4vLyBoaWRkZW4gaW5uZXIgb2JqZWN0c1xuXG5jb25zdCBTdGFydFNlcnZpY2VBQ0tCYXNlID0ge1xuICAgIE1UVTogXCJtdHVcIixcbn07XG5cbmNvbnN0IE5BS0Jhc2UgPSB7XG4gICAgUkVKRUNURURfUEFSQU1TOiBcInJlamVjdGVkUGFyYW1zXCIsXG59O1xuXG5jb25zdCBTdGFydFNlcnZpY2VQcm90b2NvbFZlcnNpb24gPSB7XG4gICAgLyoqIFRoZSBuZWdvdGlhdGVkIHZlcnNpb24gb2YgdGhlIHByb3RvY29sLiBNdXN0IGJlIGluIHRoZSBmb3JtYXQgXCJNYWpvci5NaW5vci5QYXRjaFwiKi9cbiAgICBQUk9UT0NPTF9WRVJTSU9OOiBcInByb3RvY29sVmVyc2lvblwiLFxufTtcblxuY29uc3QgU3RhcnRTZXJ2aWNlSGFzaElkID0ge1xuICAgIC8qKiBIYXNoIElEIHRvIGlkZW50aWZ5IHRoaXMgc2VydmljZSBhbmQgdXNlZCB3aGVuIHNlbmRpbmcgYW4gRW5kU2VydmljZSBjb250cm9sIGZyYW1lKi9cbiAgICBIQVNIX0lEOiBcImhhc2hJZFwiLFxufTtcblxuY29uc3QgU3RhcnRTZXJ2aWNlRGltZW5zaW9ucyA9IHtcbiAgICBIRUlHSFQ6IFwiaGVpZ2h0XCIsXG4gICAgV0lEVEg6IFwid2lkdGhcIixcbn07XG5cbi8vc3RhdGljIG1lbWJlcnMgXG5cbkNvbnRyb2xGcmFtZVRhZ3MuUlBDID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgU3RhcnRTZXJ2aWNlOiBTdGFydFNlcnZpY2VQcm90b2NvbFZlcnNpb24sXG5cbiAgICBTdGFydFNlcnZpY2VBQ0s6IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAvKiogSFUgYWxsb3dlZCB0cmFuc3BvcnQgZm9yIHNlY29uZGFyeSBjb25uZWN0aW9uICovXG4gICAgICAgIFNFQ09OREFSWV9UUkFOU1BPUlRTOiBcInNlY29uZGFyeVRyYW5zcG9ydHNcIixcbiAgICAgICAgLyoqIEhVIGFsbG93ZWQgdHJhbnNwb3J0cyBmb3IgYXVkaW8gYW5kIHZpZGVvIHNlcnZpY2VzICgxID09IFByaW1hcnksIDIgPT0gU2Vjb25kYXJ5KSAqL1xuICAgICAgICBBVURJT19TRVJWSUNFX1RSQU5TUE9SVFM6IFwiYXVkaW9TZXJ2aWNlVHJhbnNwb3J0c1wiLFxuICAgICAgICBWSURFT19TRVJWSUNFX1RSQU5TUE9SVFM6IFwidmlkZW9TZXJ2aWNlVHJhbnNwb3J0c1wiLFxuICAgICAgICAvKiogQXV0aCB0b2tlbiB0byBiZSB1c2VkIGZvciBsb2cgaW4gaW50byBzZXJ2aWNlcyAqKi9cbiAgICAgICAgQVVUSF9UT0tFTjogXCJhdXRoVG9rZW5cIixcbiAgICB9LCBTdGFydFNlcnZpY2VBQ0tCYXNlLCBTdGFydFNlcnZpY2VQcm90b2NvbFZlcnNpb24sIFN0YXJ0U2VydmljZUhhc2hJZCksXG5cbiAgICBTdGFydFNlcnZpY2VOQUs6IE5BS0Jhc2UsXG5cbiAgICBFbmRTZXJ2aWNlOiBTdGFydFNlcnZpY2VIYXNoSWQsXG5cbiAgICBFbmRTZXJ2aWNlQUNLOiB7fSxcblxuICAgIEVuZFNlcnZpY2VOQUs6IE5BS0Jhc2UsXG5cbiAgICBUcmFuc3BvcnRFdmVudFVwZGF0ZToge1xuICAgICAgICBUQ1BfSVBfQUREUkVTUzogXCJ0Y3BJcEFkZHJlc3NcIixcbiAgICAgICAgVENQX1BPUlQ6IFwidGNwUG9ydFwiLFxuICAgIH0sXG5cbiAgICBSZWdpc3RlclNlY29uZGFyeVRyYW5zcG9ydDoge30sXG5cbiAgICBSZWdpc3RlclNlY29uZGFyeVRyYW5zcG9ydEFDSzoge30sXG5cbiAgICBSZWdpc3RlclNlY29uZGFyeVRyYW5zcG9ydE5BSzogT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIFJFQVNPTjogXCJyZWFzb25cIixcbiAgICB9LCBOQUtCYXNlKSxcbn0pO1xuXG5Db250cm9sRnJhbWVUYWdzLkF1ZGlvID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgU3RhcnRTZXJ2aWNlOiB7fSxcblxuICAgIFN0YXJ0U2VydmljZUFDSzogU3RhcnRTZXJ2aWNlQUNLQmFzZSxcblxuICAgIFN0YXJ0U2VydmljZU5BSzogTkFLQmFzZSxcblxuICAgIEVuZFNlcnZpY2U6IHt9LFxuXG4gICAgRW5kU2VydmljZUFDSzoge30sXG5cbiAgICBFbmRTZXJ2aWNlTkFLOiBOQUtCYXNlLFxufSk7XG5cbkNvbnRyb2xGcmFtZVRhZ3MuVmlkZW8gPSBPYmplY3QuZnJlZXplKHtcbiAgICBTdGFydFNlcnZpY2U6IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBWSURFT19QUk9UT0NPTDogXCJ2aWRlb1Byb3RvY29sXCIsXG4gICAgICAgIFZJREVPX0NPREVDOiBcInZpZGVvQ29kZWNcIixcbiAgICB9LCBTdGFydFNlcnZpY2VEaW1lbnNpb25zKSxcblxuICAgIFN0YXJ0U2VydmljZUFDSzogT2JqZWN0LmFzc2lnbih7fSwgU3RhcnRTZXJ2aWNlQUNLQmFzZSwgU3RhcnRTZXJ2aWNlRGltZW5zaW9ucyksXG59KTtcblxuZXhwb3J0IHsgQ29udHJvbEZyYW1lVGFncyB9OyIsIi8qXG4qIENvcHlyaWdodCAoYykgMjAxOSwgTGl2aW8sIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4qIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuKlxuKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiogbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4qXG4qIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiogdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiogZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlXG4qIGRpc3RyaWJ1dGlvbi5cbipcbiogTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgTGl2aW8gSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnNcbiogbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4qIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuKlxuKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuKiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4qIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4qIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkVcbiogTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRlxuKiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1NcbiogSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU5cbiogQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcbiogQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiogUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuXG5pbXBvcnQgeyBFbnVtIH0gZnJvbSAnLi4vLi4vdXRpbC9FbnVtLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7RW51bX0gUnBjVHlwZVxuICogQHByb3BlcnR5IHtPYmplY3R9IE1BUFxuICovXG5jbGFzcyBScGNUeXBlIGV4dGVuZHMgRW51bSB7XG5cbiAgICAvKipcbiAgICAqIEBjb25zdHJ1Y3RvclxuICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IE5PVElGSUNBVElPTigpIHtcbiAgICAgICAgcmV0dXJuIFJwY1R5cGUuTUFQLk5PVElGSUNBVElPTjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgUkVTUE9OU0UoKSB7XG4gICAgICAgIHJldHVybiBScGNUeXBlLk1BUC5SRVNQT05TRTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgUkVRVUVTVCgpIHtcbiAgICAgICAgcmV0dXJuIFJwY1R5cGUuTUFQLlJFUVVFU1Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBDb25maXJtcyB3aGV0aGVyIHRoZSB2YWx1ZSBwYXNzZWQgaW4gZXhpc3RzIGluIHRoZSBFbnVtcyBvZiB0aGlzIGNsYXNzXG4gICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAqIEByZXR1cm4ge251bGx8TnVtYmVyfSAtIFJldHVybnMgbnVsbCBpZiB0aGUgZW51bSB2YWx1ZSBkb2Vzbid0IGV4aXN0XG4gICAgKi9cbiAgICBzdGF0aWMgdmFsdWVGb3JTdHJpbmcodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFJwY1R5cGUudmFsdWVGb3JTdHJpbmdJbnRlcm5hbCh2YWx1ZSwgUnBjVHlwZS5NQVApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogUmV0dXJucyB0aGUga2V5IG9mIHRoZSBtYXAgd2l0aCB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZVxuICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgKiBAcmV0dXJuIHtudWxsfFN0cmluZ30gLSBSZXR1cm5zIG51bGwgaWYgbm90IGZvdW5kXG4gICAgKi9cbiAgICBzdGF0aWMga2V5Rm9yVmFsdWUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFJwY1R5cGUua2V5Rm9yVmFsdWVJbnRlcm5hbCh2YWx1ZSwgUnBjVHlwZS5NQVApO1xuICAgIH1cbn1cblxuUnBjVHlwZS5NQVAgPSBPYmplY3QuZnJlZXplKHtcbiAgICAnTk9USUZJQ0FUSU9OJzogMHgyLFxuICAgICdSRVNQT05TRSc6IDB4MSxcbiAgICAnUkVRVUVTVCc6IDB4MCxcbn0pO1xuXG5leHBvcnQgeyBScGNUeXBlIH07XG4iLCIvKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTksIExpdmlvLCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbipcbiogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4qIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuKlxuKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4qIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4qIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZVxuKiBkaXN0cmlidXRpb24uXG4qXG4qIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIExpdmlvIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzXG4qIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZVxuKiB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbipcbiogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiogQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuKiBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFXG4qIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1JcbiogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcbiogU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXG4qIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOXG4qIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4qIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4qIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cblxuaW1wb3J0IHsgUnBjTWVzc2FnZSB9IGZyb20gJy4vUnBjTWVzc2FnZS5qcyc7XG5pbXBvcnQgeyBScGNUeXBlIH0gZnJvbSAnLi9lbnVtcy9ScGNUeXBlLmpzJztcblxuY2xhc3MgUnBjTm90aWZpY2F0aW9uIGV4dGVuZHMgUnBjTWVzc2FnZSB7XG5cblx0LyoqXG4gICAgKiBAY29uc3RydWN0b3JcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHN0b3JlKSB7XG4gICAgICAgIHN1cGVyKHN0b3JlKTtcbiAgICAgICAgdGhpcy5zZXRSUENUeXBlKFJwY1R5cGUuTk9USUZJQ0FUSU9OKTtcbiAgICB9XG5cbn1cblxuZXhwb3J0IHsgUnBjTm90aWZpY2F0aW9uIH07IiwiLypcbiogQ29weXJpZ2h0IChjKSAyMDE5LCBMaXZpbywgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4qXG4qIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuKiBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbipcbiogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuKiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuKiBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGVcbiogZGlzdHJpYnV0aW9uLlxuKlxuKiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBMaXZpbyBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9yc1xuKiBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbiogd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4qXG4qIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4qIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiogQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRVxuKiBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4qIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GXG4qIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTU1xuKiBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTlxuKiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKVxuKiBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuKiBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cblxuaW1wb3J0IHsgUnBjTWVzc2FnZSB9IGZyb20gJy4vUnBjTWVzc2FnZS5qcyc7XG5pbXBvcnQgeyBScGNUeXBlIH0gZnJvbSAnLi9lbnVtcy9ScGNUeXBlLmpzJztcblxuY2xhc3MgUnBjUmVxdWVzdCBleHRlbmRzIFJwY01lc3NhZ2Uge1xuXG4gICAgLyoqXG4gICAgKiBAY29uc3RydWN0b3JcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHN0b3JlKSB7XG4gICAgICAgIHN1cGVyKHN0b3JlKTtcbiAgICAgICAgdGhpcy5zZXRSUENUeXBlKFJwY1R5cGUuUkVRVUVTVCk7XG4gICAgICAgIHRoaXMuX3Byb21pc2UgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICovXG4gICAgZ2V0Q29ycmVsYXRpb25JRCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvcnJlbGF0aW9uSUQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge051bWJlcn0gaWRcbiAgICAqIEByZXR1cm4ge1JwY01lc3NhZ2V9XG4gICAgKi9cbiAgICBzZXRDb3JyZWxhdGlvbklEKGlkKSB7XG4gICAgICAgIHRoaXMuX2NvcnJlbGF0aW9uSUQgPSBpZDtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgKi9cbiAgICBnZXRPblJQQ1Jlc3BvbnNlUHJvbWlzZSgpe1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvbWlzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7UHJvbWlzZX0gcHJvbWlzZVxuICAgICogQHJldHVybiB7UnBjTWVzc2FnZX1cbiAgICAqL1xuICAgIHNldE9uUlBDUmVzcG9uc2VQcm9taXNlKHByb21pc2Upe1xuICAgICAgICB0aGlzLnZhbGlkYXRlVHlwZShQcm9taXNlLCBwcm9taXNlKTtcblxuICAgICAgICB0aGlzLl9wcm9taXNlID0gcHJvbWlzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG59XG5cbmV4cG9ydCB7IFJwY1JlcXVlc3QgfTsiLCIvKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTksIExpdmlvLCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbipcbiogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4qIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuKlxuKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4qIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4qIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZVxuKiBkaXN0cmlidXRpb24uXG4qXG4qIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIExpdmlvIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzXG4qIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZVxuKiB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbipcbiogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiogQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuKiBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFXG4qIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1JcbiogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcbiogU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXG4qIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOXG4qIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4qIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4qIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cblxuaW1wb3J0IHsgRW51bSB9IGZyb20gJy4uLy4uL3V0aWwvRW51bS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge0VudW19IFJlc3VsdFxuICogQHByb3BlcnR5IHtPYmplY3R9IE1BUFxuICovXG5jbGFzcyBSZXN1bHQgZXh0ZW5kcyBFbnVtIHtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gXG4gICAgICovXG4gICAgc3RhdGljIGdldCBTVUNDRVNTKCkge1xuICAgICAgICByZXR1cm4gUmVzdWx0Lk1BUC5TVUNDRVNTO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gXG4gICAgICovXG4gICAgc3RhdGljIGdldCBVTlNVUFBPUlRFRF9SRVFVRVNUKCkge1xuICAgICAgICByZXR1cm4gUmVzdWx0Lk1BUC5VTlNVUFBPUlRFRF9SRVFVRVNUO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gXG4gICAgICovXG4gICAgc3RhdGljIGdldCBVTlNVUFBPUlRFRF9SRVNPVVJDRSgpIHtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5NQVAuVU5TVVBQT1JURURfUkVRVUVTVDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgRElTQUxMT1dFRCgpIHtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5NQVAuRElTQUxMT1dFRDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgUkVKRUNURUQoKSB7XG4gICAgICAgIHJldHVybiBSZXN1bHQuTUFQLlJFSkVDVEVEO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gXG4gICAgICovXG4gICAgc3RhdGljIGdldCBBQk9SVEVEKCkge1xuICAgICAgICByZXR1cm4gUmVzdWx0Lk1BUC5BQk9SVEVEO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gXG4gICAgICovXG4gICAgc3RhdGljIGdldCBJR05PUkVEKCkge1xuICAgICAgICByZXR1cm4gUmVzdWx0Lk1BUC5JR05PUkVEO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gXG4gICAgICovXG4gICAgc3RhdGljIGdldCBSRVRSWSgpIHtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5NQVAuUkVUUlk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IElOX1VTRSgpIHtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5NQVAuSU5fVVNFO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gXG4gICAgICovXG4gICAgc3RhdGljIGdldCBWRUhJQ0xFX0RBVEFfTk9UX0FWQUlMQUJMRSgpIHtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5NQVAuVkVISUNMRV9EQVRBX05PVF9BVkFJTEFCTEU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IFRJTUVEX09VVCgpIHtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5NQVAuVElNRURfT1VUO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gXG4gICAgICovXG4gICAgc3RhdGljIGdldCBJTlZBTElEX0RBVEEoKSB7XG4gICAgICAgIHJldHVybiBSZXN1bHQuTUFQLklOVkFMSURfREFUQTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgQ0hBUl9MSU1JVF9FWENFRURFRCgpIHtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5NQVAuQ0hBUl9MSU1JVF9FWENFRURFRDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgSU5WQUxJRF9JRCgpIHtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5NQVAuSU5WQUxJRF9JRDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgRFVQTElDQVRFX05BTUUoKSB7XG4gICAgICAgIHJldHVybiBSZXN1bHQuTUFQLkRVUExJQ0FURV9OQU1FO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gXG4gICAgICovXG4gICAgc3RhdGljIGdldCBBUFBMSUNBVElPTl9OT1RfUkVHSVNURVJFRCgpIHtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5NQVAuQVBQTElDQVRJT05fTk9UX1JFR0lTVEVSRUQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IFdST05HX0xBTkdVQUdFKCkge1xuICAgICAgICByZXR1cm4gUmVzdWx0Lk1BUC5XUk9OR19MQU5HVUFHRTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgT1VUX09GX01FTU9SWSgpIHtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5NQVAuT1VUX09GX01FTU9SWTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgVE9PX01BTllfUEVORElOR19SRVFVRVNUUygpIHtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5NQVAuVE9PX01BTllfUEVORElOR19SRVFVRVNUUztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgVE9PX01BTllfQVBQTElDQVRJT05TKCkge1xuICAgICAgICByZXR1cm4gUmVzdWx0Lk1BUC5UT09fTUFOWV9BUFBMSUNBVElPTlM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IEFQUExJQ0FUSU9OX1JFR0lTVEVSRURfQUxSRUFEWSgpIHtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5NQVAuQVBQTElDQVRJT05fUkVHSVNURVJFRF9BTFJFQURZO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gXG4gICAgICovXG4gICAgc3RhdGljIGdldCBXQVJOSU5HUygpIHtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5NQVAuV0FSTklOR1M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IEdFTkVSSUNfRVJST1IoKSB7XG4gICAgICAgIHJldHVybiBSZXN1bHQuTUFQLkdFTkVSSUNfRVJST1I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IFVTRVJfRElTQUxMT1dFRCgpIHtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5NQVAuVVNFUl9ESVNBTExPV0VEO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gXG4gICAgICovXG4gICAgc3RhdGljIGdldCBUUlVOQ0FURURfREFUQSgpIHtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5NQVAuVFJVTkNBVEVEX0RBVEE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IFVOU1VQUE9SVEVEX1ZFUlNJT04oKSB7XG4gICAgICAgIHJldHVybiBSZXN1bHQuTUFQLlVOU1VQUE9SVEVEX1ZFUlNJT047XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IFZFSElDTEVfREFUQV9OT1RfQUxMT1dFRCgpIHtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5NQVAuVkVISUNMRV9EQVRBX05PVF9BTExPV0VEO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gXG4gICAgICovXG4gICAgc3RhdGljIGdldCBGSUxFX05PVF9GT1VORCgpIHtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5NQVAuRklMRV9OT1RfRk9VTkQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IENBTkNFTF9ST1VURSgpIHtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5NQVAuQ0FOQ0VMX1JPVVRFO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gXG4gICAgICovXG4gICAgc3RhdGljIGdldCBTQVZFRCgpIHtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5NQVAuU0FWRUQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IElOVkFMSURfQ0VSVCgpIHtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5NQVAuSU5WQUxJRF9DRVJUO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gXG4gICAgICovXG4gICAgc3RhdGljIGdldCBFWFBJUkVEX0NFUlQoKSB7XG4gICAgICAgIHJldHVybiBSZXN1bHQuTUFQLkVYUElSRURfQ0VSVDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgUkVTVU1FX0ZBSUxFRCgpIHtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5NQVAuUkVTVU1FX0ZBSUxFRDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgREFUQV9OT1RfQVZBSUxBQkxFKCkge1xuICAgICAgICByZXR1cm4gUmVzdWx0Lk1BUC5EQVRBX05PVF9BVkFJTEFCTEU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IFJFQURfT05MWSgpIHtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5NQVAuUkVBRF9PTkxZO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gXG4gICAgICovXG4gICAgc3RhdGljIGdldCBDT1JSVVBURURfREFUQSgpIHtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5NQVAuQ09SUlVQVEVEX0RBVEE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBDb25maXJtcyB3aGV0aGVyIHRoZSB2YWx1ZSBwYXNzZWQgaW4gZXhpc3RzIGluIHRoZSBFbnVtcyBvZiB0aGlzIGNsYXNzXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAqIEByZXR1cm4ge251bGx8U3RyaW5nfSAtIFJldHVybnMgbnVsbCBpZiB0aGUgZW51bSB2YWx1ZSBkb2Vzbid0IGV4aXN0XG4gICAgKi9cbiAgICBzdGF0aWMgdmFsdWVGb3JTdHJpbmcodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC52YWx1ZUZvclN0cmluZ0ludGVybmFsKHZhbHVlLCBSZXN1bHQuTUFQKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIFJldHVybnMgdGhlIGtleSBvZiB0aGUgbWFwIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgICogQHJldHVybiB7bnVsbHxTdHJpbmd9IC0gUmV0dXJucyBudWxsIGlmIG5vdCBmb3VuZFxuICAgICovXG4gICAgc3RhdGljIGtleUZvclZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBSZXN1bHQua2V5Rm9yVmFsdWVJbnRlcm5hbCh2YWx1ZSwgUmVzdWx0Lk1BUCk7XG4gICAgfVxuXG59XG5cblJlc3VsdC5NQVAgPSBPYmplY3QuZnJlZXplKHtcbiAgICAnU1VDQ0VTUyc6ICdTVUNDRVNTJyxcbiAgICAnVU5TVVBQT1JURURfUkVRVUVTVCc6ICdVTlNVUFBPUlRFRF9SRVFVRVNUJyxcbiAgICAnVU5TVVBQT1JURURfUkVTT1VSQ0UnOiAnVU5TVVBQT1JURURfUkVTT1VSQ0UnLFxuICAgICdESVNBTExPV0VEJzogJ0RJU0FMTE9XRUQnLFxuICAgICdSRUpFQ1RFRCc6ICdSRUpFQ1RFRCcsXG4gICAgJ0FCT1JURUQnOiAnQUJPUlRFRCcsXG4gICAgJ0lHTk9SRUQnOiAnSUdOT1JFRCcsXG4gICAgJ1JFVFJZJzogJ1JFVFJZJyxcbiAgICAnSU5fVVNFJzogJ0lOX1VTRScsXG4gICAgJ1ZFSElDTEVfREFUQV9OT1RfQVZBSUxBQkxFJzogJ1ZFSElDTEVfREFUQV9OT1RfQVZBSUxBQkxFJyxcbiAgICAnVElNRURfT1VUJzogJ1RJTUVEX09VVCcsXG4gICAgJ0lOVkFMSURfREFUQSc6ICdJTlZBTElEX0RBVEEnLFxuICAgICdDSEFSX0xJTUlUX0VYQ0VFREVEJzogJ0NIQVJfTElNSVRfRVhDRUVERUQnLFxuICAgICdJTlZBTElEX0lEJzogJ0lOVkFMSURfSUQnLFxuICAgICdEVVBMSUNBVEVfTkFNRSc6ICdEVVBMSUNBVEVfTkFNRScsXG4gICAgJ0FQUExJQ0FUSU9OX05PVF9SRUdJU1RFUkVEJzogJ0FQUExJQ0FUSU9OX05PVF9SRUdJU1RFUkVEJyxcbiAgICAnV1JPTkdfTEFOR1VBR0UnOiAnV1JPTkdfTEFOR1VBR0UnLFxuICAgICdPVVRfT0ZfTUVNT1JZJzogJ09VVF9PRl9NRU1PUlknLFxuICAgICdUT09fTUFOWV9QRU5ESU5HX1JFUVVFU1RTJzogJ1RPT19NQU5ZX1BFTkRJTkdfUkVRVUVTVFMnLFxuICAgICdUT09fTUFOWV9BUFBMSUNBVElPTlMnOiAnVE9PX01BTllfQVBQTElDQVRJT05TJyxcbiAgICAnQVBQTElDQVRJT05fUkVHSVNURVJFRF9BTFJFQURZJzogJ0FQUExJQ0FUSU9OX1JFR0lTVEVSRURfQUxSRUFEWScsXG4gICAgJ1dBUk5JTkdTJzogJ1dBUk5JTkdTJyxcbiAgICAnR0VORVJJQ19FUlJPUic6ICdHRU5FUklDX0VSUk9SJyxcbiAgICAnVVNFUl9ESVNBTExPV0VEJzogJ1VTRVJfRElTQUxMT1dFRCcsXG4gICAgJ1RSVU5DQVRFRF9EQVRBJzogJ1RSVU5DQVRFRF9EQVRBJyxcbiAgICAnVU5TVVBQT1JURURfVkVSU0lPTic6ICdVTlNVUFBPUlRFRF9WRVJTSU9OJyxcbiAgICAnVkVISUNMRV9EQVRBX05PVF9BTExPV0VEJzogJ1ZFSElDTEVfREFUQV9OT1RfQUxMT1dFRCcsXG4gICAgJ0ZJTEVfTk9UX0ZPVU5EJzogJ0ZJTEVfTk9UX0ZPVU5EJyxcbiAgICAnQ0FOQ0VMX1JPVVRFJzogJ0NBTkNFTF9ST1VURScsXG4gICAgJ1NBVkVEJzogJ1NBVkVEJyxcbiAgICAnSU5WQUxJRF9DRVJUJzogJ0lOVkFMSURfQ0VSVCcsXG4gICAgJ0VYUElSRURfQ0VSVCc6ICdFWFBJUkVEX0NFUlQnLFxuICAgICdSRVNVTUVfRkFJTEVEJzogJ1JFU1VNRV9GQUlMRUQnLFxuICAgICdEQVRBX05PVF9BVkFJTEFCTEUnOiAnREFUQV9OT1RfQVZBSUxBQkxFJyxcbiAgICAnUkVBRF9PTkxZJzogJ1JFQURfT05MWScsXG4gICAgJ0NPUlJVUFRFRF9EQVRBJzogJ0NPUlJVUFRFRF9EQVRBJyxcbn0pO1xuXG5leHBvcnQgeyBSZXN1bHQgfTtcbiIsIi8qXG4qIENvcHlyaWdodCAoYykgMjAxOSwgTGl2aW8sIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4qIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuKlxuKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiogbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4qXG4qIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiogdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiogZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlXG4qIGRpc3RyaWJ1dGlvbi5cbipcbiogTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgTGl2aW8gSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnNcbiogbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4qIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuKlxuKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuKiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4qIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4qIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkVcbiogTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRlxuKiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1NcbiogSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU5cbiogQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcbiogQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiogUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuXG5pbXBvcnQgeyBScGNNZXNzYWdlIH0gZnJvbSAnLi9ScGNNZXNzYWdlLmpzJztcbmltcG9ydCB7IFJwY1R5cGUgfSBmcm9tICcuL2VudW1zL1JwY1R5cGUuanMnO1xuaW1wb3J0IHsgUmVzdWx0IH0gZnJvbSAnLi9lbnVtcy9SZXN1bHQuanMnO1xuXG5jbGFzcyBScGNSZXNwb25zZSBleHRlbmRzIFJwY01lc3NhZ2Uge1xuXG4gICAgLyoqXG4gICAgKiBAY29uc3RydWN0b3JcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHN0b3JlKSB7XG4gICAgICAgIHN1cGVyKHN0b3JlKTtcbiAgICAgICAgdGhpcy5zZXRSUENUeXBlKFJwY1R5cGUuUkVTUE9OU0UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICovXG4gICAgZ2V0Q29ycmVsYXRpb25JRCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvcnJlbGF0aW9uSUQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge051bWJlcn0gaWRcbiAgICAqIEByZXR1cm4ge1JwY1Jlc3BvbnNlfVxuICAgICovXG4gICAgc2V0Q29ycmVsYXRpb25JRChpZCkge1xuICAgICAgICB0aGlzLl9jb3JyZWxhdGlvbklEID0gaWQ7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICovXG4gICAgZ2V0U3VjY2VzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFyYW1ldGVyKEtFWV9TVUNDRVNTKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEByZXR1cm4ge1JwY1Jlc3BvbnNlfVxuICAgICovXG4gICAgc2V0U3VjY2VzcyhzdWNjZXNzKSB7XG4gICAgICAgIHRoaXMuc2V0UGFyYW1ldGVyKEtFWV9TVUNDRVNTLCBzdWNjZXNzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgKi9cbiAgICBnZXRJbmZvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQYXJhbWV0ZXIoS0VZX0lORk8pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQHJldHVybiB7UnBjUmVzcG9uc2V9XG4gICAgKi9cbiAgICBzZXRJbmZvKGluZm8pIHtcbiAgICAgICAgdGhpcy5zZXRQYXJhbWV0ZXIoS0VZX0lORk8sIGluZm8pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEByZXR1cm4ge1Jlc3VsdH1cbiAgICAqL1xuICAgIGdldFJlc3VsdENvZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9iamVjdChSZXN1bHQsIEtFWV9SRVNVTFRfQ09ERSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAcmV0dXJuIHtScGNSZXNwb25zZX1cbiAgICAqL1xuICAgIHNldFJlc3VsdENvZGUocmVzdWx0Q29kZSkge1xuICAgICAgICB0aGlzLnZhbGlkYXRlVHlwZShSZXN1bHQsIHJlc3VsdENvZGUpO1xuXG4gICAgICAgIHRoaXMuc2V0UGFyYW1ldGVyKEtFWV9SRVNVTFRfQ09ERSwgcmVzdWx0Q29kZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuUnBjUmVzcG9uc2UuS0VZX1NVQ0NFU1MgICAgID0gJ3N1Y2Nlc3MnO1xuUnBjUmVzcG9uc2UuS0VZX0lORk8gICAgICAgID0gJ2luZm8nO1xuUnBjUmVzcG9uc2UuS0VZX1JFU1VMVF9DT0RFID0gJ3Jlc3VsdENvZGUnO1xuXG5leHBvcnQgeyBScGNSZXNwb25zZSB9O1xuIiwiLypcbiogQ29weXJpZ2h0IChjKSAyMDE5LCBMaXZpbywgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4qXG4qIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuKiBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbipcbiogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuKiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuKiBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGVcbiogZGlzdHJpYnV0aW9uLlxuKlxuKiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBMaXZpbyBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9yc1xuKiBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbiogd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4qXG4qIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4qIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiogQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRVxuKiBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4qIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GXG4qIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTU1xuKiBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTlxuKiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKVxuKiBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuKiBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cbmltcG9ydCB7IEVudW0gfSBmcm9tICcuLi8uLi91dGlsL0VudW0uanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtFbnVtfSBGdW5jdGlvbklEXG4gKiBAcHJvcGVydHkge09iamVjdH0gTUFQXG4gKi9cbmNsYXNzIEZ1bmN0aW9uSUQgZXh0ZW5kcyBFbnVtIHtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvciBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAqL1xuICAgIHN0YXRpYyBnZXQgQUREX0NPTU1BTkQoKXtcbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uSUQuTUFQLkFkZENvbW1hbmQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgKi9cbiAgICBzdGF0aWMgZ2V0IE9OX0xBTkdVQUdFX0NIQU5HRSgpe1xuICAgICAgICByZXR1cm4gRnVuY3Rpb25JRC5NQVAuT25MYW5ndWFnZUNoYW5nZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIENvbmZpcm1zIHdoZXRoZXIgdGhlIHZhbHVlIHBhc3NlZCBpbiBleGlzdHMgaW4gdGhlIEVudW1zIG9mIHRoaXMgY2xhc3NcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICogQHJldHVybiB7bnVsbHxOdW1iZXJ9IC0gUmV0dXJucyBudWxsIGlmIHRoZSBlbnVtIHZhbHVlIGRvZXNuJ3QgZXhpc3RcbiAgICAqL1xuICAgIHN0YXRpYyB2YWx1ZUZvclN0cmluZyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gRnVuY3Rpb25JRC52YWx1ZUZvclN0cmluZ0ludGVybmFsKHZhbHVlLCBGdW5jdGlvbklELk1BUCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBSZXR1cm5zIHRoZSBrZXkgb2YgdGhlIG1hcCB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlXG4gICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAqIEByZXR1cm4ge251bGx8U3RyaW5nfSAtIFJldHVybnMgbnVsbCBpZiBub3QgZm91bmRcbiAgICAqL1xuICAgIHN0YXRpYyBrZXlGb3JWYWx1ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gRnVuY3Rpb25JRC5rZXlGb3JWYWx1ZUludGVybmFsKHZhbHVlLCBGdW5jdGlvbklELk1BUCk7XG4gICAgfVxufVxuXG5GdW5jdGlvbklELk1BUCA9IE9iamVjdC5mcmVlemUoe1xuICAgICdBZGRDb21tYW5kJzogMHgwNSxcbiAgICAnT25MYW5ndWFnZUNoYW5nZSc6IDB4ODAwQSxcbiAgICAvL1RPRE8gdGhpcyBuZWVkcyB0byBiZSBjb21wbGV0ZWx5IGZpbGxlZCBvdXQgc3RpbGxcbn0pO1xuXG5leHBvcnQgeyBGdW5jdGlvbklEIH0iLCIvKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTksIExpdmlvLCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbipcbiogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4qIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuKlxuKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4qIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4qIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZVxuKiBkaXN0cmlidXRpb24uXG4qXG4qIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIExpdmlvIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzXG4qIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZVxuKiB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbipcbiogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiogQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuKiBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFXG4qIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1JcbiogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcbiogU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXG4qIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOXG4qIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4qIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4qIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cblxuaW1wb3J0IHsgRW51bSB9IGZyb20gJy4uLy4uL3V0aWwvRW51bS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge0VudW19IEltYWdlVHlwZVxuICogQHByb3BlcnR5IHtPYmplY3R9IE1BUFxuICovXG5jbGFzcyBJbWFnZVR5cGUgZXh0ZW5kcyBFbnVtIHtcblxuICAgIC8qKlxuICAgICogQGNvbnN0cnVjdG9yXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgU1RBVElDKCkge1xuICAgICAgICByZXR1cm4gSW1hZ2VUeXBlLk1BUC5TVEFUSUM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IERZTkFNSUMoKSB7XG4gICAgICAgIHJldHVybiBJbWFnZVR5cGUuTUFQLkRZTkFNSUM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBDb25maXJtcyB3aGV0aGVyIHRoZSB2YWx1ZSBwYXNzZWQgaW4gZXhpc3RzIGluIHRoZSBFbnVtcyBvZiB0aGlzIGNsYXNzXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAqIEByZXR1cm4ge251bGx8U3RyaW5nfSAtIFJldHVybnMgbnVsbCBpZiB0aGUgZW51bSB2YWx1ZSBkb2Vzbid0IGV4aXN0XG4gICAgKi9cbiAgICBzdGF0aWMgdmFsdWVGb3JTdHJpbmcodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEltYWdlVHlwZS52YWx1ZUZvclN0cmluZ0ludGVybmFsKHZhbHVlLCBJbWFnZVR5cGUuTUFQKTtcbiAgICB9XG59XG5cbkltYWdlVHlwZS5NQVAgPSBPYmplY3QuZnJlZXplKHtcbiAgICAnU1RBVElDJzogJ1NUQVRJQycsXG4gICAgJ0RZTkFNSUMnOiAnRFlOQU1JQycsXG59KTtcblxuZXhwb3J0IHsgSW1hZ2VUeXBlIH07IiwiLypcbiogQ29weXJpZ2h0IChjKSAyMDE5LCBMaXZpbywgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4qXG4qIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuKiBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbipcbiogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuKiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuKiBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGVcbiogZGlzdHJpYnV0aW9uLlxuKlxuKiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBMaXZpbyBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9yc1xuKiBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbiogd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4qXG4qIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4qIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiogQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRVxuKiBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4qIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GXG4qIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTU1xuKiBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTlxuKiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKVxuKiBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuKiBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cbmltcG9ydCB7IEVudW0gfSBmcm9tICcuLi8uLi91dGlsL0VudW0uanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtFbnVtfSBMYW5ndWFnZVxuICogQHByb3BlcnR5IHtPYmplY3R9IE1BUFxuICovXG5jbGFzcyBMYW5ndWFnZSBleHRlbmRzIEVudW0ge1xuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yIFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gXG4gICAgICovXG4gICAgc3RhdGljIGdldCBFTl9TQSgpIHtcbiAgICAgICAgcmV0dXJuIExhbmd1YWdlLk1BUC5FTl9TQTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgSEVfSUwoKSB7XG4gICAgICAgIHJldHVybiBMYW5ndWFnZS5NQVAuSEVfSUw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IFJPX1JPKCkge1xuICAgICAgICByZXR1cm4gTGFuZ3VhZ2UuTUFQLlJPX1JPO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gXG4gICAgICovXG4gICAgc3RhdGljIGdldCBVS19VQSgpIHtcbiAgICAgICAgcmV0dXJuIExhbmd1YWdlLk1BUC5VS19VQTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgSURfSUQoKSB7XG4gICAgICAgIHJldHVybiBMYW5ndWFnZS5NQVAuSURfSUQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IFZJX1ZOKCkge1xuICAgICAgICByZXR1cm4gTGFuZ3VhZ2UuTUFQLlZJX1ZOO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gXG4gICAgICovXG4gICAgc3RhdGljIGdldCBNU19NWSgpIHtcbiAgICAgICAgcmV0dXJuIExhbmd1YWdlLk1BUC5NU19NWTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgSElfSU4oKSB7XG4gICAgICAgIHJldHVybiBMYW5ndWFnZS5NQVAuSElfSU47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IE5MX0JFKCkge1xuICAgICAgICByZXR1cm4gTGFuZ3VhZ2UuTUFQLk5MX0JFO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gXG4gICAgICovXG4gICAgc3RhdGljIGdldCBFTF9HUigpIHtcbiAgICAgICAgcmV0dXJuIExhbmd1YWdlLk1BUC5FTF9HUjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgSFVfSFUoKSB7XG4gICAgICAgIHJldHVybiBMYW5ndWFnZS5NQVAuSFVfSFU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IEZJX0ZJKCkge1xuICAgICAgICByZXR1cm4gTGFuZ3VhZ2UuTUFQLkZJX0ZJO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gXG4gICAgICovXG4gICAgc3RhdGljIGdldCBTS19TSygpIHtcbiAgICAgICAgcmV0dXJuIExhbmd1YWdlLk1BUC5TS19TSztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgRU5fVVMoKSB7XG4gICAgICAgIHJldHVybiBMYW5ndWFnZS5NQVAuRU5fVVM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IEVTX01YKCkge1xuICAgICAgICByZXR1cm4gTGFuZ3VhZ2UuTUFQLkVTX01YO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gXG4gICAgICovXG4gICAgc3RhdGljIGdldCBGUl9DQSgpIHtcbiAgICAgICAgcmV0dXJuIExhbmd1YWdlLk1BUC5GUl9DQTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgREVfREUoKSB7XG4gICAgICAgIHJldHVybiBMYW5ndWFnZS5NQVAuREVfREU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IEVTX0VTKCkge1xuICAgICAgICByZXR1cm4gTGFuZ3VhZ2UuTUFQLkVTX0VTO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gXG4gICAgICovXG4gICAgc3RhdGljIGdldCBFTl9HQigpIHtcbiAgICAgICAgcmV0dXJuIExhbmd1YWdlLk1BUC5FTl9HQjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgUlVfUlUoKSB7XG4gICAgICAgIHJldHVybiBMYW5ndWFnZS5NQVAuUlVfUlU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IFRSX1RSKCkge1xuICAgICAgICByZXR1cm4gTGFuZ3VhZ2UuTUFQLlRSX1RSO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gXG4gICAgICovXG4gICAgc3RhdGljIGdldCBQTF9QTCgpIHtcbiAgICAgICAgcmV0dXJuIExhbmd1YWdlLk1BUC5QTF9QTDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgRlJfRlIoKSB7XG4gICAgICAgIHJldHVybiBMYW5ndWFnZS5NQVAuRlJfRlI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IElUX0lUKCkge1xuICAgICAgICByZXR1cm4gTGFuZ3VhZ2UuTUFQLklUX0lUO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gXG4gICAgICovXG4gICAgc3RhdGljIGdldCBTVl9TRSgpIHtcbiAgICAgICAgcmV0dXJuIExhbmd1YWdlLk1BUC5TVl9TRTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgUFRfUFQoKSB7XG4gICAgICAgIHJldHVybiBMYW5ndWFnZS5NQVAuUFRfUFQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IE5MX05MKCkge1xuICAgICAgICByZXR1cm4gTGFuZ3VhZ2UuTUFQLk5MX05MO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gXG4gICAgICovXG4gICAgc3RhdGljIGdldCBFTl9BVSgpIHtcbiAgICAgICAgcmV0dXJuIExhbmd1YWdlLk1BUC5FTl9BVTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgWkhfQ04oKSB7XG4gICAgICAgIHJldHVybiBMYW5ndWFnZS5NQVAuWkhfQ047XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IFpIX1RXKCkge1xuICAgICAgICByZXR1cm4gTGFuZ3VhZ2UuTUFQLlpIX1RXO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gXG4gICAgICovXG4gICAgc3RhdGljIGdldCBKQV9KUCgpIHtcbiAgICAgICAgcmV0dXJuIExhbmd1YWdlLk1BUC5KQV9KUDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgQVJfU0EoKSB7XG4gICAgICAgIHJldHVybiBMYW5ndWFnZS5NQVAuQVJfU0E7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IEtPX0tSKCkge1xuICAgICAgICByZXR1cm4gTGFuZ3VhZ2UuTUFQLktPX0tSO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gXG4gICAgICovXG4gICAgc3RhdGljIGdldCBQVF9CUigpIHtcbiAgICAgICAgcmV0dXJuIExhbmd1YWdlLk1BUC5QVF9CUjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgQ1NfQ1ooKSB7XG4gICAgICAgIHJldHVybiBMYW5ndWFnZS5NQVAuQ1NfQ1o7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IERBX0RLKCkge1xuICAgICAgICByZXR1cm4gTGFuZ3VhZ2UuTUFQLkRBX0RLO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gXG4gICAgICovXG4gICAgc3RhdGljIGdldCBOT19OTygpIHtcbiAgICAgICAgcmV0dXJuIExhbmd1YWdlLk1BUC5OT19OTztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgRU5fSU4oKSB7XG4gICAgICAgIHJldHVybiBMYW5ndWFnZS5NQVAuRU5fSU47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IFRIX1RIKCkge1xuICAgICAgICByZXR1cm4gTGFuZ3VhZ2UuTUFQLlRIX1RIO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQ29uZmlybXMgd2hldGhlciB0aGUgdmFsdWUgcGFzc2VkIGluIGV4aXN0cyBpbiB0aGUgRW51bXMgb2YgdGhpcyBjbGFzc1xuICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgKiBAcmV0dXJuIHtudWxsfFN0cmluZ30gLSBSZXR1cm5zIG51bGwgaWYgdGhlIGVudW0gdmFsdWUgZG9lc24ndCBleGlzdFxuICAgICovXG4gICAgc3RhdGljIHZhbHVlRm9yU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBMYW5ndWFnZS5NQVApIHtcbiAgICAgICAgICAgIGlmIChMYW5ndWFnZS5NQVBba2V5XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTGFuZ3VhZ2UuTUFQW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbkxhbmd1YWdlLk1BUCA9IE9iamVjdC5mcmVlemUoe1xuICAgICdFTl9TQSc6ICdFTi1TQScsXG4gICAgJ0hFX0lMJzogJ0hFLUlMJyxcbiAgICAnUk9fUk8nOiAnUk8tUk8nLFxuICAgICdVS19VQSc6ICdVSy1VQScsXG4gICAgJ0lEX0lEJzogJ0lELUlEJyxcbiAgICAnVklfVk4nOiAnVkktVk4nLFxuICAgICdNU19NWSc6ICdNUy1NWScsXG4gICAgJ0hJX0lOJzogJ0hJLUlOJyxcbiAgICAnTkxfQkUnOiAnTkwtQkUnLFxuICAgICdFTF9HUic6ICdFTC1HUicsXG4gICAgJ0hVX0hVJzogJ0hVLUhVJyxcbiAgICAnRklfRkknOiAnRkktRkknLFxuICAgICdTS19TSyc6ICdTSy1TSycsXG4gICAgJ0VOX1VTJzogJ0VOLVVTJyxcbiAgICAnRVNfTVgnOiAnRVMtTVgnLFxuICAgICdGUl9DQSc6ICdGUi1DQScsXG4gICAgJ0RFX0RFJzogJ0RFLURFJyxcbiAgICAnRVNfRVMnOiAnRVMtRVMnLFxuICAgICdFTl9HQic6ICdFTi1HQicsXG4gICAgJ1JVX1JVJzogJ1JVLVJVJyxcbiAgICAnVFJfVFInOiAnVFItVFInLFxuICAgICdQTF9QTCc6ICdQTC1QTCcsXG4gICAgJ0ZSX0ZSJzogJ0ZSLUZSJyxcbiAgICAnSVRfSVQnOiAnSVQtSVQnLFxuICAgICdTVl9TRSc6ICdTVi1TRScsXG4gICAgJ1BUX1BUJzogJ1BULVBUJyxcbiAgICAnTkxfTkwnOiAnTkwtTkwnLFxuICAgICdFTl9BVSc6ICdFTi1BVScsXG4gICAgJ1pIX0NOJzogJ1pILUNOJyxcbiAgICAnWkhfVFcnOiAnWkgtVFcnLFxuICAgICdKQV9KUCc6ICdKQS1KUCcsXG4gICAgJ0FSX1NBJzogJ0FSLVNBJyxcbiAgICAnS09fS1InOiAnS08tS1InLFxuICAgICdQVF9CUic6ICdQVC1CUicsXG4gICAgJ0NTX0NaJzogJ0NTLUNaJyxcbiAgICAnREFfREsnOiAnREEtREsnLFxuICAgICdOT19OTyc6ICdOTy1OTycsXG4gICAgJ0VOX0lOJzogJ0VOLUlOJyxcbiAgICAnVEhfVEgnOiAnVEgtVEgnLFxufSk7XG5cblxuZXhwb3J0IHsgTGFuZ3VhZ2UgfTsiLCIvKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTksIExpdmlvLCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbipcbiogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4qIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuKlxuKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4qIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4qIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZVxuKiBkaXN0cmlidXRpb24uXG4qXG4qIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIExpdmlvIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzXG4qIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZVxuKiB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbipcbiogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiogQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuKiBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFXG4qIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1JcbiogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcbiogU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXG4qIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOXG4qIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4qIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4qIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cblxuaW1wb3J0IHsgUnBjU3RydWN0IH0gZnJvbSAnLi4vUnBjU3RydWN0LmpzJztcbmltcG9ydCB7IEltYWdlVHlwZSB9IGZyb20gJy4uL2VudW1zL0ltYWdlVHlwZS5qcyc7XG5cbmNsYXNzIEltYWdlIGV4dGVuZHMgUnBjU3RydWN0IHtcblxuICAgIC8qKlxuICAgICogQGNvbnN0cnVjdG9yXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgKiBAcmV0dXJuIHtJbWFnZX1cbiAgICAqL1xuICAgIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2V0UGFyYW1ldGVyKEltYWdlLktFWV9WQUxVRSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAqL1xuICAgIGdldFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQYXJhbWV0ZXIoSW1hZ2UuS0VZX1ZBTFVFKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7SW1hZ2VUeXBlfSB0eXBlXG4gICAgKiBAcmV0dXJuIHtJbWFnZX1cbiAgICAqL1xuICAgIHNldEltYWdlVHlwZSh0eXBlKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGVUeXBlKEltYWdlVHlwZSwgdHlwZSk7XG5cbiAgICAgICAgdGhpcy5zZXRQYXJhbWV0ZXIoSW1hZ2UuS0VZX0lNQUdFX1RZUEUsIHR5cGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEByZXR1cm4ge0ltYWdlVHlwZX1cbiAgICAqL1xuICAgIGdldEltYWdlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0KEltYWdlLCBJbWFnZS5LRVlfSU1BR0VfVFlQRSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzVGVtcGxhdGVcbiAgICAqIEByZXR1cm4ge0ltYWdlfVxuICAgICovXG4gICAgc2V0SXNUZW1wbGF0ZShpc1RlbXBsYXRlKSB7XG4gICAgICAgIHRoaXMuc2V0UGFyYW1ldGVyKEltYWdlLktFWV9JU19URU1QTEFURSwgaXNUZW1wbGF0ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAqL1xuICAgIGdldElzVGVtcGxhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFBhcmFtZXRlcihJbWFnZS5LRVlfSVNfVEVNUExBVEUpO1xuICAgIH1cblxufVxuXG5JbWFnZS5LRVlfVkFMVUUgPSAndmFsdWUnO1xuSW1hZ2UuS0VZX0lNQUdFX1RZUEUgPSAnaW1hZ2VUeXBlJztcbkltYWdlLktFWV9JU19URU1QTEFURSA9ICdpc1RlbXBsYXRlJztcblxuZXhwb3J0IHsgSW1hZ2UgfTtcbiIsIi8qXG4qIENvcHlyaWdodCAoYykgMjAxOSwgTGl2aW8sIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4qIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuKlxuKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiogbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4qXG4qIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiogdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiogZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlXG4qIGRpc3RyaWJ1dGlvbi5cbipcbiogTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgTGl2aW8gSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnNcbiogbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4qIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuKlxuKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuKiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4qIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4qIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkVcbiogTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRlxuKiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1NcbiogSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU5cbiogQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcbiogQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiogUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuXG5pbXBvcnQgeyBScGNTdHJ1Y3QgfSBmcm9tICcuLi9ScGNTdHJ1Y3QuanMnO1xuXG5jbGFzcyBNZW51UGFyYW1zIGV4dGVuZHMgUnBjU3RydWN0IHtcblxuICAgIC8qKlxuICAgICogQGNvbnN0cnVjdG9yXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQHBhcmFtIHtOdW1iZXJ9IGlkXG4gICAgKiBAcmV0dXJuIHtNZW51UGFyYW1zfVxuICAgICovXG4gICAgc2V0UGFyZW50SUQoaWQpIHtcbiAgICAgICAgdGhpcy5zZXRQYXJhbWV0ZXIoTWVudVBhcmFtcy5LRVlfUEFSRU5UX0lELCBpZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICovXG4gICAgZ2V0UGFyZW50SUQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFBhcmFtZXRlcihNZW51UGFyYW1zLktFWV9QQVJFTlRfSUQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uXG4gICAgKiBAcmV0dXJuIHtNZW51UGFyYW1zfVxuICAgICovXG4gICAgc2V0UG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy5zZXRQYXJhbWV0ZXIoTWVudVBhcmFtcy5LRVlfUE9TSVRJT04sIHBvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgKi9cbiAgICBnZXRQb3NpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFyYW1ldGVyKE1lbnVQYXJhbXMuS0VZX1BPU0lUSU9OKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZW51TmFtZVxuICAgICogQHJldHVybiB7TWVudVBhcmFtc31cbiAgICAqL1xuICAgIHNldE1lbnVOYW1lKG1lbnVOYW1lKSB7XG4gICAgICAgIHRoaXMuc2V0UGFyYW1ldGVyKE1lbnVQYXJhbXMuS0VZX01FTlVfTkFNRSwgbWVudU5hbWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBwYXJhbSB7U3RyaW5nfVxuICAgICovXG4gICAgZ2V0TWVudU5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFBhcmFtZXRlcihNZW51UGFyYW1zLktFWV9NRU5VX05BTUUpO1xuICAgIH1cblxufVxuXG5NZW51UGFyYW1zLktFWV9QQVJFTlRfSUQgPSAncGFyZW50SUQnO1xuTWVudVBhcmFtcy5LRVlfUE9TSVRJT04gID0gJ3Bvc2l0aW9uJztcbk1lbnVQYXJhbXMuS0VZX01FTlVfTkFNRSA9ICdtZW51TmFtZSc7XG5cbmV4cG9ydCB7IE1lbnVQYXJhbXMgfTtcbiIsIi8qXG4qIENvcHlyaWdodCAoYykgMjAxOSwgTGl2aW8sIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4qIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuKlxuKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiogbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4qXG4qIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiogdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiogZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlXG4qIGRpc3RyaWJ1dGlvbi5cbipcbiogTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgTGl2aW8gSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnNcbiogbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4qIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuKlxuKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuKiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4qIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4qIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkVcbiogTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRlxuKiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1NcbiogSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU5cbiogQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcbiogQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiogUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuXG5pbXBvcnQgeyBScGNSZXF1ZXN0IH0gZnJvbSAnLi4vUnBjUmVxdWVzdC5qcyc7XG5pbXBvcnQgeyBJbWFnZSB9IGZyb20gJy4uL3N0cnVjdHMvSW1hZ2UuanMnO1xuaW1wb3J0IHsgTWVudVBhcmFtcyB9IGZyb20gJy4uL3N0cnVjdHMvTWVudVBhcmFtcy5qcyc7XG5pbXBvcnQgeyBGdW5jdGlvbklEIH0gZnJvbSAnLi4vZW51bXMvRnVuY3Rpb25JRC5qcyc7XG5cbmNsYXNzIEFkZENvbW1hbmQgZXh0ZW5kcyBScGNSZXF1ZXN0IHtcblxuICAgIC8qKlxuICAgICogQGNvbnN0cnVjdG9yXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzdG9yZSkge1xuICAgICAgICBzdXBlcihzdG9yZSk7XG4gICAgICAgIHRoaXMuc2V0RnVuY3Rpb25OYW1lKEZ1bmN0aW9uSUQuQUREX0NPTU1BTkQpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge051bWJlcn0gaWRcbiAgICAqIEByZXR1cm4ge0FkZENvbW1hbmR9XG4gICAgKi9cbiAgICBzZXRDbWRJRChpZCkge1xuICAgICAgICB0aGlzLnNldFBhcmFtZXRlcihBZGRDb21tYW5kLktFWV9DTURfSUQsIGlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgKi9cbiAgICBnZXRDbWRJRCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFyYW1ldGVyKEFkZENvbW1hbmQuS0VZX0NNRF9JRCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge01lbnVQYXJhbXN9IG1lbnVQYXJhbXNcbiAgICAqIEByZXR1cm4ge0FkZENvbW1hbmR9XG4gICAgKi9cbiAgICBzZXRNZW51UGFyYW1zKG1lbnVQYXJhbXMpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0ZVR5cGUoTWVudVBhcmFtcywgbWVudVBhcmFtcyk7XG5cbiAgICAgICAgdGhpcy5zZXRQYXJhbWV0ZXIoQWRkQ29tbWFuZC5LRVlfTUVOVV9QQVJBTVMsIG1lbnVQYXJhbXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAqL1xuICAgIGdldE1lbnVQYXJhbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9iamVjdChNZW51UGFyYW1zLCBBZGRDb21tYW5kLktFWV9NRU5VX1BBUkFNUyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge0FycmF5PFN0cmluZz59IHZyQ29tbWFuZHNcbiAgICAqIEByZXR1cm4ge0FkZENvbW1hbmR9XG4gICAgKi9cbiAgICBzZXRWckNvbW1hbmRzKHZyQ29tbWFuZHMpIHtcbiAgICAgICAgdGhpcy5zZXRQYXJhbWV0ZXIoQWRkQ29tbWFuZC5LRVlfVlJfQ09NTUFORFMsIHZyQ29tbWFuZHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEByZXR1cm4ge0FycmF5PFN0cmluZz59XG4gICAgKi9cbiAgICBnZXRWckNvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQYXJhbWV0ZXIoQWRkQ29tbWFuZC5LRVlfVlJfQ09NTUFORFMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQHBhcmFtIHtJbWFnZX0gaWNvblxuICAgICogQHJldHVybiB7QWRkQ29tbWFuZH1cbiAgICAqL1xuICAgIHNldENtZEljb24oaWNvbikge1xuICAgICAgICB0aGlzLnZhbGlkYXRlVHlwZShJbWFnZSwgaWNvbik7XG5cbiAgICAgICAgdGhpcy5zZXRQYXJhbWV0ZXIoQWRkQ29tbWFuZC5LRVlfQ01EX0lDT04sIGljb24pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEByZXR1cm4ge0ltYWdlfVxuICAgICovXG4gICAgZ2V0Q21kSWNvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0KEltYWdlLCBBZGRDb21tYW5kLktFWV9DTURfSUNPTik7XG4gICAgfVxuXG59XG5cbkFkZENvbW1hbmQuS0VZX0NNRF9JQ09OID0gJ2NtZEljb24nO1xuQWRkQ29tbWFuZC5LRVlfTUVOVV9QQVJBTVMgPSAnbWVudVBhcmFtcyc7XG5BZGRDb21tYW5kLktFWV9DTURfSUQgPSAnY21kSUQnO1xuQWRkQ29tbWFuZC5LRVlfVlJfQ09NTUFORFMgPSAndnJDb21tYW5kcyc7XG5cbmV4cG9ydCB7IEFkZENvbW1hbmQgfTtcbiIsIi8qXG4qIENvcHlyaWdodCAoYykgMjAxOSwgTGl2aW8sIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4qIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuKlxuKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiogbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4qXG4qIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiogdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiogZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlXG4qIGRpc3RyaWJ1dGlvbi5cbipcbiogTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgTGl2aW8gSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnNcbiogbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4qIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuKlxuKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuKiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4qIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4qIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkVcbiogTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRlxuKiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1NcbiogSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU5cbiogQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcbiogQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiogUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuXG5pbXBvcnQgeyBScGNSZXNwb25zZSB9IGZyb20gJy4uL1JwY1Jlc3BvbnNlLmpzJztcbmltcG9ydCB7IEZ1bmN0aW9uSUQgfSBmcm9tICcuLi9lbnVtcy9GdW5jdGlvbklELmpzJztcblxuY2xhc3MgQWRkQ29tbWFuZFJlc3BvbnNlIGV4dGVuZHMgUnBjUmVzcG9uc2Uge1xuXG5cdC8qKlxuICAgICogQGNvbnN0cnVjdG9yXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzdG9yZSkge1xuICAgICAgICBzdXBlcihzdG9yZSk7XG4gICAgICAgIHRoaXMuc2V0RnVuY3Rpb25OYW1lKEZ1bmN0aW9uSUQuQUREX0NPTU1BTkQpO1xuICAgIH1cblxufVxuXG5leHBvcnQgeyBBZGRDb21tYW5kUmVzcG9uc2UgfTtcbiIsIi8qXG4qIENvcHlyaWdodCAoYykgMjAxOSwgTGl2aW8sIEluYy5cbiogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbipcbiogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4qIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuKlxuKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiogbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4qXG4qIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiogdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiogZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlXG4qIGRpc3RyaWJ1dGlvbi5cbipcbiogTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgTGl2aW8gSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnNcbiogbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlXG4qIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuKlxuKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuKiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4qIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4qIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkVcbiogTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRlxuKiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1NcbiogSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU5cbiogQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcbiogQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEVcbiogUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuXG5pbXBvcnQgeyBScGNOb3RpZmljYXRpb24gfSBmcm9tICcuLi9ScGNOb3RpZmljYXRpb24uanMnO1xuaW1wb3J0IHsgTGFuZ3VhZ2UgfSBmcm9tICcuLi9lbnVtcy9MYW5ndWFnZS5qcyc7XG5pbXBvcnQgeyBGdW5jdGlvbklEIH0gZnJvbSAnLi4vZW51bXMvRnVuY3Rpb25JRC5qcyc7XG5cbmNsYXNzIE9uTGFuZ3VhZ2VDaGFuZ2UgZXh0ZW5kcyBScGNOb3RpZmljYXRpb24ge1xuXG4gICAgLyoqXG4gICAgKiBAY29uc3RydWN0b3JcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHN0b3JlKSB7XG4gICAgICAgIHN1cGVyKHN0b3JlKTtcbiAgICAgICAgdGhpcy5zZXRGdW5jdGlvbk5hbWUoRnVuY3Rpb25JRC5PTl9MQU5HVUFHRV9DSEFOR0UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQHBhcmFtIHtMYW5ndWFnZX0gbGFuZ2F1Z2VcbiAgICAqIEByZXR1cm4ge09uTGFuZ3VhZ2VDaGFuZ2V9XG4gICAgKi9cbiAgICBzZXRMYW5ndWFnZShsYW5nYXVnZSkge1xuICAgICAgICB0aGlzLnZhbGlkYXRlVHlwZShMYW5ndWFnZSwgbGFuZ3VhZ2UpO1xuXG4gICAgICAgIHRoaXMuc2V0UGFyYW1ldGVyKE9uTGFuZ3VhZ2VDaGFuZ2UuS0VZX0xBTkdVQUdFLCBsYW5ndWFnZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQHJldHVybiB7TGFuZ3VhZ2V9XG4gICAgKi9cbiAgICBnZXRMYW5ndWFnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0KExhbmd1YWdlLCBPbkxhbmd1YWdlQ2hhbmdlLktFWV9MQU5HVUFHRSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAcGFyYW0ge0xhbmd1YWdlfSBsYW5nYXVnZVxuICAgICogQHJldHVybiB7T25MYW5ndWFnZUNoYW5nZX1cbiAgICAqL1xuICAgIHNldEhNSURpc3BsYXlMYW5ndWFnZShsYW5ndWFnZSkge1xuICAgICAgICB0aGlzLnZhbGlkYXRlVHlwZShMYW5ndWFnZSwgbGFuZ3VhZ2UpO1xuXG4gICAgICAgIHRoaXMuc2V0UGFyYW1ldGVyKE9uTGFuZ3VhZ2VDaGFuZ2UuS0VZX0hNSV9ESVNQTEFZX0xBTkdVQUdFLCBsYW5ndWFnZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQHJldHVybiB7TGFuZ3VhZ2V9XG4gICAgKi9cbiAgICBnZXRITUlEaXNwbGF5TGFuZ3VhZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9iamVjdChMYW5ndWFnZSwgT25MYW5ndWFnZUNoYW5nZS5LRVlfSE1JX0RJU1BMQVlfTEFOR1VBR0UpO1xuICAgIH1cbn1cblxuT25MYW5ndWFnZUNoYW5nZS5LRVlfTEFOR1VBR0UgPSAnbGFuZ3VhZ2UnO1xuT25MYW5ndWFnZUNoYW5nZS5LRVlfSE1JX0RJU1BMQVlfTEFOR1VBR0UgPSAnaG1pRGlzcGxheUxhbmd1YWdlJztcblxuZXhwb3J0IHsgT25MYW5ndWFnZUNoYW5nZSB9O1xuIiwiLypcbiogQ29weXJpZ2h0IChjKSAyMDE5LCBMaXZpbywgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4qXG4qIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuKiBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbipcbiogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuKiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuKiBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGVcbiogZGlzdHJpYnV0aW9uLlxuKlxuKiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBMaXZpbyBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9yc1xuKiBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbiogd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4qXG4qIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4qIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiogQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRVxuKiBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4qIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GXG4qIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTU1xuKiBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTlxuKiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKVxuKiBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuKiBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU2RsU2Vzc2lvbkxpc3RlbmVyXG4gKi9cbmNsYXNzIFNkbFNlc3Npb25MaXN0ZW5lciB7XG5cblx0LyoqXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy9UT0RPIGFkZCBhbGwgY2FsbGJhY2tzXG4gICAgfVxuXG4gICAgXG5cbn1cblxuZXhwb3J0IHsgU2RsU2Vzc2lvbkxpc3RlbmVyIH07IiwiLypcbiogQ29weXJpZ2h0IChjKSAyMDE5LCBMaXZpbywgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4qXG4qIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuKiBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbipcbiogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuKiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuKiBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGVcbiogZGlzdHJpYnV0aW9uLlxuKlxuKiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBMaXZpbyBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9yc1xuKiBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbiogd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4qXG4qIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4qIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiogQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRVxuKiBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4qIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GXG4qIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTU1xuKiBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTlxuKiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKVxuKiBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuKiBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cbmltcG9ydCB7IFNkbFNlc3Npb25MaXN0ZW5lciB9IGZyb20gXCIuL1NkbFNlc3Npb25MaXN0ZW5lci5qc1wiO1xuaW1wb3J0IHsgU2RsUHJvdG9jb2xMaXN0ZW5lciB9IGZyb20gXCIuLi9wcm90b2NvbC9TZGxQcm90b2NvbExpc3RlbmVyLmpzXCI7XG5pbXBvcnQgeyBTZGxQcm90b2NvbEJhc2UgfSBmcm9tIFwiLi4vcHJvdG9jb2wvU2RsUHJvdG9jb2xCYXNlLmpzXCI7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU2RsU2Vzc2lvblxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gX3NldHVwU2RsUHJvdG9jb2xMaXN0ZW5lclxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gc3RhcnRcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGVuZFNlc3Npb25cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGFkZFNlcnZpY2VMaXN0ZW5lclxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gcmVtb3ZlU2VydmljZUxpc3RlbmVyXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBzZW5kUnBjXG4gKi9cbmNsYXNzIFNkbFNlc3Npb24ge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtUcmFuc3BvcnRDb25maWdCYXNlfSBiYXNlVHJhbnNwb3J0Q29uZmlnIFxuICAgICAqIEBwYXJhbSB7U2RsU2Vzc2lvbkxpc3RlbmVyfSBzZGxTZXNzaW9uTGlzdGVuZXIgXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYmFzZVRyYW5zcG9ydENvbmZpZywgc2RsU2Vzc2lvbkxpc3RlbmVyKSB7XG5cbiAgICAgICAgdGhpcy5fc2VydmljZUxpc3RlbmVycyA9IG5ldyBBcnJheSgpO1xuXG4gICAgICAgIHRoaXMuX3NkbFNlc3Npb25MaXN0ZW5lciA9IHNkbFNlc3Npb25MaXN0ZW5lcjtcbiAgICAgICAgbGV0IHNkbFByb3RvY29sTGlzdGVuZXIgPSBfc2V0dXBTZGxQcm90b2NvbExpc3RlbmVyKCk7XG5cbiAgICAgICAgdGhpcy5fc2RsUHJvdG9jb2wgPSBuZXcgU2RsUHJvdG9jb2xCYXNlKHNkbFByb3RvY29sTGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1NkbFByb3RvY29sTGlzdGVuZXJ9IFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NldHVwU2RsUHJvdG9jb2xMaXN0ZW5lcigpIHtcbiAgICAgICAgbGV0IHNkbFByb3RvY29sTGlzdGVuZXIgPSBuZXcgU2RsUHJvdG9jb2xMaXN0ZW5lcigpO1xuXG4gICAgICAgIC8vVE9ETyBjcmVhdGUgYWxsIHRoZSBmdW5jdGlvbnMgdGhhdCB3aWxsIGJlIHNldCBmb3IgdGhpcyBsaXN0ZW5lclxuXG4gICAgICAgIHJldHVybiBzZGxQcm90b2NvbExpc3RlbmVyO1xuICAgIH1cblxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy5fc2RsUHJvdG9jb2wgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fc2RsUHJvdG9jb2wuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVuZFNlc3Npb24oKSB7XG4gICAgICAgIC8vVE9ETyBoYW5kbGUgaW50ZXJuYWwgaXRlbXNcbiAgICAgICAgaWYgKHRoaXMuX3NkbFByb3RvY29sICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3NkbFByb3RvY29sLmVuZFNlc3Npb24oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U2RsU2Vzc2lvbkxpc3RlbmVyfSBzZXJ2aWNlTGlzdGVuZXIgXG4gICAgICovXG4gICAgYWRkU2VydmljZUxpc3RlbmVyKHNlcnZpY2VMaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9zZXJ2aWNlTGlzdGVuZXJzLnB1c2goc2VydmljZUxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1NkbFNlc3Npb25MaXN0ZW5lcn0gc2VydmljZUxpc3RlbmVyIFxuICAgICAqL1xuICAgIHJlbW92ZVNlcnZpY2VMaXN0ZW5lcihzZXJ2aWNlTGlzdGVuZXIpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5fc2VydmljZUxpc3RlbmVycy5pbmRleE9mKHNlcnZpY2VMaXN0ZW5lcik7XG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXJ2aWNlTGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1JwY01lc3NhZ2V9IHJwY01lc3NhZ2UgXG4gICAgICovXG4gICAgc2VuZFJwYyhycGNNZXNzYWdlKSB7XG5cbiAgICB9XG5cbn1cblxuZXhwb3J0IHsgU2RsU2Vzc2lvbiB9OyIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTksIExpdmlvLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gKlxuICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gKiBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICogZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlXG4gKiBkaXN0cmlidXRpb24uXG4gKlxuICogTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgTGl2aW8gSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnNcbiAqIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZVxuICogd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAqIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAqIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gKiBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFXG4gKiBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4gKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRlxuICogU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXG4gKiBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTlxuICogQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcbiAqIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4gKiBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG5pbXBvcnQgeyBGcmFtZVR5cGUgfSBmcm9tICcuLi9wcm90b2NvbC9lbnVtcy9GcmFtZVR5cGUuanMnO1xuaW1wb3J0IHsgU2RsUGFja2V0IH0gZnJvbSAnLi4vcHJvdG9jb2wvU2RsUGFja2V0LmpzJztcbmltcG9ydCB7IFNkbFByb3RvY29sQmFzZSB9IGZyb20gJy4uL3Byb3RvY29sL1NkbFByb3RvY29sQmFzZS5qcyc7XG5cblxuY2xhc3MgU2RsUHNtIHtcdFx0XHRcdFx0XHRcdC8vVE9ETyBjaGVjayB0byBzZWUgaWYgaXQncyBiZXR0ZXIgdG8gdXNlICc9PScgb3IgJz09PSdcblx0XG5cdC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyBhbGwgaW50ZXJuYWwgbWVtYmVycyB0byBkZWZhdWx0XG4gICAgICovXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gU2RsUHNtLlNUQVJUX1NUQVRFO1xuICAgICAgICB0aGlzLl92ZXJzaW9uID0gMDtcbiAgICAgICAgdGhpcy5fZW5jcnlwdGlvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9mcmFtZVR5cGUgPSBGcmFtZVR5cGUuU0lOR0xFO1xuICAgICAgICB0aGlzLl9zZXJ2aWNlVHlwZSA9IDA7XG4gICAgICAgIHRoaXMuX2NvbnRyb2xGcmFtZUluZm8gPSBudWxsO1xuICAgICAgICB0aGlzLl9zZXNzaW9uSUQgPSBudWxsO1xuICAgICAgICB0aGlzLl9kdW1wU2l6ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2RhdGFMZW5ndGggPSAwO1xuICAgICAgICB0aGlzLl9tZXNzYWdlSUQgPSAwO1xuICAgICAgICB0aGlzLl9wYXlsb2FkID0gbnVsbDtcblx0fVxuXG5cdC8qKlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gLSBTdGF0ZSByZXByZXNlbnRlZCBieSBhIE51bWJlclxuICAgICAqL1xuICAgIGdldFN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7U2RsUGFja2V0fSAtIFJldHVybnMgbnVsbCBpZiBub3QgY29tcGxldGVcbiAgICAgKi9cbiAgICBnZXRGb3JtZWRQYWNrZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PSBTZGxQc20uRklOSVNIRURfU1RBVEUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2RsUGFja2V0KHRoaXMuX3ZlcnNpb24sIHRoaXMuX2VuY3J5cHRpb24sIHRoaXMuX2ZyYW1lVHlwZSwgdGhpcy5fc2VydmljZVR5cGUsIHRoaXMuX2NvbnRyb2xGcmFtZUluZm8sIHRoaXMuX3Nlc3Npb25JRCwgdGhpcy5fZGF0YUxlbmd0aCwgdGhpcy5fbWVzc2FnZUlELCB0aGlzLl9wYXlsb2FkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEgLSBSZXByZXNlbnRzIGEgYnl0ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaGFuZGxlQnl0ZShkYXRhKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gdGhpcy5fdHJhbnNpdGlvbk9uSW5wdXQoZGF0YSwgdGhpcy5fc3RhdGUpO1xuXG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PSBTZGxQc20uRVJST1JfU1RBVEUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuXHR9XG5cblx0LyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhd0J5dGUgLSBSZXByZXNlbnRzIGEgYnl0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGF0ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdHJhbnNpdGlvbk9uSW5wdXQocmF3Qnl0ZSwgc3RhdGUpIHtcbiAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBTZGxQc20uU1RBUlRfU1RBVEU6XG5cbiAgICAgICAgICAgICAgICB0aGlzLl92ZXJzaW9uID0gKHJhd0J5dGUgJiBTZGxQc20uVkVSU0lPTl9NQVNLKT4+NDtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl92ZXJzaW9uID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNkbFBzbS5FUlJPUl9TVEFURTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5jcnlwdGlvbiA9ICgxID09IChyYXdCeXRlICYgU2RsUHNtLkVOQ1JZUFRJT05fTUFTSyk+PjMpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fZnJhbWVUeXBlID0gcmF3Qnl0ZSAmIFNkbFBzbS5GUkFNRV9UWVBFX01BU0s7XG5cbiAgICAgICAgICAgICAgICBpZiAoKHRoaXMuX3ZlcnNpb24gPCAxIHx8IHRoaXMuX3ZlcnNpb24gPiA1KVxuICAgICAgICAgICAgICAgICAgICAmJiB0aGlzLl9mcmFtZVR5cGUgIT0gU2RsUGFja2V0LkZSQU1FX1RZUEVfQ09OVFJPTCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU2RsUHNtLkVSUk9SX1NUQVRFO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9mcmFtZVR5cGUgPCBTZGxQYWNrZXQuRlJBTUVfVFlQRV9DT05UUk9MIHx8IHRoaXMuX2ZyYW1lVHlwZSA+IFNkbFBhY2tldC5GUkFNRV9UWVBFX0NPTlNFQ1VUSVZFKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTZGxQc20uRVJST1JfU1RBVEU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNkbFBzbS5TRVJWSUNFX1RZUEVfU1RBVEU7XG5cbiAgICAgICAgICAgIGNhc2UgU2RsUHNtLlNFUlZJQ0VfVFlQRV9TVEFURTpcblxuXHRcdHRoaXMuX3NlcnZpY2VUeXBlID0gcmF3Qnl0ZSAmIDB4RkY7XG5cdFx0cmV0dXJuIFNkbFBzbS5DT05UUk9MX0ZSQU1FX0lORk9fU1RBVEU7XG5cbiAgICAgICAgICAgIGNhc2UgU2RsUHNtLkNPTlRST0xfRlJBTUVfSU5GT19TVEFURTpcblx0XHRcdFx0XG5cdFx0dGhpcy5fY29udHJvbEZyYW1lSW5mbyA9IHJhd0J5dGUgJiAweEZGO1xuXHRcdFx0XHRzd2l0Y2godGhpcy5fZnJhbWVUeXBlKXtcblx0XHRcdFx0XHRjYXNlIFNkbFBhY2tldC5GUkFNRV9UWVBFX0NPTlRST0w6XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFNkbFBhY2tldC5GUkFNRV9UWVBFX1NJTkdMRTpcblx0XHRcdFx0XHRjYXNlIFNkbFBhY2tldC5GUkFNRV9UWVBFX0ZJUlNUOlxuXHRcdFx0XHRcdFx0aWYodGhpcy5fY29udHJvbEZyYW1lSW5mbyAhPSAweDAwKXtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFNkbFBzbS5FUlJPUl9TVEFURTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgU2RsUGFja2V0LkZSQU1FX1RZUEVfQ09OU0VDVVRJVkU6XG5cdFx0XHRcdFx0XHQvL0l0IG1pZ2h0IGJlIGEgZ29vZCBpZGVhIHRvIGNoZWNrIHBhY2tldCBzZXF1ZW5jZSBudW1iZXJzIGhlcmVcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRyZXR1cm4gU2RsUHNtLkVSUk9SX1NUQVRFO1x0XHRcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBTZGxQc20uU0VTU0lPTl9JRF9TVEFURTtcblxuICAgICAgICAgICAgY2FzZSBTZGxQc20uU0VTU0lPTl9JRF9TVEFURTpcblx0XHRcdFx0XG5cdFx0dGhpcy5fc2Vzc2lvbklEID0gcmF3Qnl0ZSAmIDB4RkY7XG5cdFx0XHRcdHJldHVybiBTZGxQc20uREFUQV9TSVpFXzFfU1RBVEU7XG5cbiAgICAgICAgICAgIGNhc2UgU2RsUHNtLkRBVEFfU0laRV8xX1NUQVRFOlxuXHRcdFx0XHRcblx0XHR0aGlzLl9kYXRhTGVuZ3RoICs9IChyYXdCeXRlICYgMHhGRikgPDwgMjQ7IC8vU2hpZnQgMyBieXRlcyB4IDggYml0c1xuXHRcdFx0XHRyZXR1cm4gU2RsUHNtLkRBVEFfU0laRV8yX1NUQVRFO1xuXG4gICAgICAgICAgICBjYXNlIFNkbFBzbS5EQVRBX1NJWkVfMl9TVEFURTpcblx0XHRcdFx0XG5cdFx0dGhpcy5fZGF0YUxlbmd0aCArPSAocmF3Qnl0ZSAmIDB4RkYpIDw8IDE2OyAvL1NpZnQgMiBieXRlcyB4IDggYml0c1xuXHRcdFx0XHRyZXR1cm4gREFUQV9TSVpFXzNfU1RBVEU7XG5cbiAgICAgICAgICAgIGNhc2UgU2RsUHNtLkRBVEFfU0laRV8zX1NUQVRFOlxuXHRcdFx0XHRcblx0XHR0aGlzLl9kYXRhTGVuZ3RoICs9IChyYXdCeXRlICYgMHhGRikgPDwgODsgLy9TaWZ0IDEgYnl0ZSB4IDggYml0c1xuXHRcdFx0XHRyZXR1cm4gREFUQV9TSVpFXzRfU1RBVEU7XG5cbiAgICAgICAgICAgIGNhc2UgU2RsUHNtLkRBVEFfU0laRV80X1NUQVRFOlxuXHRcdFx0XHRcblx0XHR0aGlzLl9kYXRhTGVuZ3RoICs9IChyYXdCeXRlICYgMHhGRilcblx0XHRcdFx0XG5cdFx0XHRcdC8vV2Ugc2hvdWxkIGhhdmUgZGF0YSBsZW5ndGggbm93IGZvciB0aGUgcHVtcCBzdGF0ZVxuXHRcdHN3aXRjaCAodGhpcy5fZnJhbWVUeXBlKSB7IC8vSWYgYWxsIGlzIGNvcnJlY3Qgd2Ugc2hvdWxkIGJyZWFrIG91dCBvZiB0aGlzIHN3aXRjaCBzdGF0ZW1lbnRcblx0XHRcdFx0XHRjYXNlIFNkbFBhY2tldC5GUkFNRV9UWVBFX1NJTkdMRTpcblx0XHRcdFx0XHRjYXNlIFNkbFBhY2tldC5GUkFNRV9UWVBFX0NPTlNFQ1VUSVZFOlxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSBTZGxQYWNrZXQuRlJBTUVfVFlQRV9DT05UUk9MOlxuXHRcdFx0XHRcdFx0Ly9Paywgd2VsbCBoZXJlJ3Mgc29tZSBpbnRlcmVzdGluZyBiaXQgb2Yga25vd2xlZGdlLiBCZWNhdXNlIHRoZSBzdGFydCBzZXNzaW9uIHJlcXVlc3QgaXMgZnJvbSB0aGUgcGhvbmUgd2l0aCBubyBrbm93bGVkZ2Ugb2YgdmVyc2lvbiBpdCBzZW5kcyBvdXRcblx0XHRcdFx0XHRcdC8vYSB2MSBwYWNrZXQuIFRIRVJFRk9SRSB0aGVyZSBpcyBubyBtZXNzYWdlIGlkIGZpZWxkLiAqKioqIE5vdyB5b3Uga25vdyBhbmQga25vd2luZyBpcyBoYWxmIHRoZSBiYXR0bGUgKioqKlxuXHRcdFx0XHRpZiAodGhpcy5fdmVyc2lvbiA9PSAxICYmIHRoaXMuX2NvbnRyb2xGcmFtZUluZm8gPT0gU2RsUGFja2V0LkZSQU1FX0lORk9fU1RBUlRfU0VSVklDRSkge1xuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0aWYgKHRoaXMuX2RhdGFMZW5ndGggPT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBTZGxQc20uRklOSVNIRURfU1RBVEU7IC8vV2UgYXJlIGRvbmUgaWYgd2UgZG9uJ3QgaGF2ZSBhbnkgcGF5bG9hZFxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRpZiAodGhpcy5fZGF0YUxlbmd0aCA8PSBTZGxQcm90b2NvbEJhc2UuVjFfVjJfTVRVX1NJWkUgLSBTZGxQcm90b2NvbEJhc2UuVjFfSEVBREVSX1NJWkUpIHsgLy8gc2l6ZXMgZnJvbSBwcm90b2NvbC9TZGxQcm90b2NvbC5qc1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3BheWxvYWQgPSBuZXcgYnl0ZVt0aGlzLl9kYXRhTGVuZ3RoXTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gU2RsUHNtLkVSUk9SX1NUQVRFO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0dGhpcy5fZHVtcFNpemUgPSB0aGlzLl9kYXRhTGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gU2RsUHNtLkRBVEFfUFVNUF9TVEFURTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrOyBcblx0XHRcdFx0XG5cdFx0XHRcdFx0Y2FzZSBTZGxQYWNrZXQuRlJBTUVfVFlQRV9GSVJTVDpcblx0XHRcdFx0XHRcdGlmIChkYXRhTGVuZ3RoID09IFNkbFBzbS5GSVJTVF9GUkFNRV9EQVRBX1NJWkUpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRyZXR1cm4gU2RsUHNtLkVSUk9SX1NUQVRFO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRoaXMuX3ZlcnNpb24gPT0gMSkgeyAvL1ZlcnNpb24gMSBwYWNrZXRzIHdpbGwgbm90IGhhdmUgbWVzc2FnZSBpZCdzXG5cdFx0XHRcdFx0aWYgKHRoaXMuX2RhdGFMZW5ndGggPT0gMCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIFNkbFBzbS5GSU5JU0hFRF9TVEFURTsgLy9XZSBhcmUgZG9uZSBpZiB3ZSBkb24ndCBoYXZlIGFueSBwYXlsb2FkXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh0aGlzLl9kYXRhTGVuZ3RoIDw9IFNkbFByb3RvY29sQmFzZS5WMV9WMl9NVFVfU0laRSAtIFNkbFByb3RvY29sQmFzZS5WMV9IRUFERVJfU0laRSkgeyAvLyBzaXplcyBmcm9tIHByb3RvY29sL1NkbFByb3RvY29sLmphdmFcblx0XHRcdFx0XHRcdHRoaXMuX3BheWxvYWQgPSBuZXcgVWludDhBcnJheSh0aGlzLl9kYXRhTGVuZ3RoKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIFNkbFBzbS5FUlJPUl9TVEFURTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fZHVtcFNpemUgPSB0aGlzLl9kYXRhTGVuZ3RoO1xuXHRcdFx0XHRcdHJldHVybiBTZGxQc20uREFUQV9QVU1QX1NUQVRFO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBTZGxQc20uTUVTU0FHRV8xX1NUQVRFO1xuXHRcdFx0XHR9XG5cbiAgICAgICAgICAgIGNhc2UgU2RsUHNtLk1FU1NBR0VfMV9TVEFURTpcblx0XHRcdFx0XG5cdFx0XHRcdHRoaXMuX21lc3NhZ2VJRCArPSAocmF3Qnl0ZSAmIDB4RkYpIDw8IDI0OyAvLyBTaGlmdCAzIGJ5dGVzIHggOCBiaXRzXG5cdFx0XHRcdHJldHVybiBTZGxQc20uTUVTU0FHRV8yX1NUQVRFO1xuXHRcdFx0XHRcbiAgICAgICAgICAgIGNhc2UgU2RsUHNtLk1FU1NBR0VfMl9TVEFURTpcblx0XHRcdFx0XG5cdFx0XHRcdHRoaXMuX21lc3NhZ2VJRCArPSAocmF3Qnl0ZSAmIDB4RkYpIDw8IDE2OyAvLyBTaGlmdCAyIGJ5dGVzIHggOCBiaXRzXG5cdFx0XHRcdHJldHVybiBTZGxQc20uTUVTU0FHRV8zX1NUQVRFO1xuXG4gICAgICAgICAgICBjYXNlIFNkbFBzbS5NRVNTQUdFXzNfU1RBVEU6XG5cdFx0XHRcdFxuXHRcdFx0XHR0aGlzLl9tZXNzYWdlSUQgKz0gKHJhd0J5dGUgJiAweEZGKSA8PCA4OyAvLyBTaGlmdCAxIGJ5dGUgeCA4IGJpdHNcblx0XHRcdFx0cmV0dXJuIFNkbFBzbS5NRVNTQUdFXzRfU1RBVEU7XG5cbiAgICAgICAgICAgIGNhc2UgU2RsUHNtLk1FU1NBR0VfNF9TVEFURTpcblx0XHRcdFx0XG5cdFx0XHRcdHRoaXMuX21lc3NhZ2VJRCArPSAocmF3Qnl0ZSAmIDB4RkYpO1xuXHRcdFx0XHRpZiAodGhpcy5fZGF0YUxlbmd0aCA9PSAwKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFNkbFBzbS5GSU5JU0hFRF9TVEFURTsgLy9XZSBhcmUgZG9uZSBpZiB3ZSBkb24ndCBoYXZlIGFueSBwYXlsb2FkXG5cdFx0XHRcdH1cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR0aGlzLl9wYXlsb2FkID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5fZGF0YUxlbmd0aCk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7IC8vUG9zc2libGUgT3V0IG9mIE1lbW9yeSBlcnJvciBpZiBkYXRhIGxlbmd0aCBpcyBpbnZhbGlkXG5cdFx0XHRcdFx0cmV0dXJuIFNkbFBzbS5FUlJPUl9TVEFURTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkdW1wU2l6ZSA9IGRhdGFMZW5ndGg7XG5cdFx0XHRcdHJldHVybiBTZGxQc20uREFUQV9QVU1QX1NUQVRFO1xuXG4gICAgICAgICAgICBjYXNlIFNkbFBzbS5EQVRBX1BVTVBfU1RBVEU6XG5cdFx0XHRcdFxuXHRcdFx0XHR0aGlzLl9wYXlsb2FkW3RoaXMuX2RhdGFMZW5ndGggLSB0aGlzLl9kdW1wU2l6ZV0gPSByYXdCeXRlO1xuXHRcdFx0XHR0aGlzLl9kdW1wU2l6ZS0tO1xuXHRcdFx0XHQvL0RvIHdlIGhhdmUgYW55IG1vcmUgYnl0ZXMgdG8gcmVhZCBpbj9cblx0XHRcdFx0aWYodGhpcy5fZHVtcFNpemUgPiAwKXtcblx0XHRcdFx0XHRyZXR1cm4gU2RsUHNtLkRBVEFfUFVNUF9TVEFURTtcblx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLl9kdW1wU2l6ZSA9PSAwKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFNkbFBzbS5GSU5JU0hFRF9TVEFURTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gU2RsUHNtLkVSUk9SX1NUQVRFO1xuXHRcdFx0XHR9XG5cbiAgICAgICAgICAgIGNhc2UgU2RsUHNtLkZJTklTSEVEX1NUQVRFOlxuICAgICAgICAgICAgZGVmYXVsdDpcblx0XHRcdFx0Ly9TaG91bGQgbm90IGJlIGhhbmRsaW5nIGFueSBvdGhlciBieXRlcyB3aGlsZSBpbiB0aGUgZmluaXNoZWQgc3RhdGVcbiAgICAgICAgICAgICAgICByZXR1cm4gU2RsUHNtLkVSUk9SX1NUQVRFO1xuICAgICAgICB9XG4gICAgfSAgICBcbn1cblxuU2RsUHNtLlNUQVJUX1NUQVRFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAweDA7XG5TZGxQc20uU0VSVklDRV9UWVBFX1NUQVRFICAgICAgICAgICAgICAgICAgICAgICA9IDB4MDI7XG5TZGxQc20uQ09OVFJPTF9GUkFNRV9JTkZPX1NUQVRFICAgICAgICAgICAgICAgICA9IDB4MDM7XG5TZGxQc20uU0VTU0lPTl9JRF9TVEFURSAgICAgICAgICAgICAgICAgICAgICAgICA9IDB4MDQ7XG5TZGxQc20uREFUQV9TSVpFXzFfU1RBVEUgICAgICAgICAgICAgICAgICAgICAgICA9IDB4MDU7XG5TZGxQc20uREFUQV9TSVpFXzJfU1RBVEUgICAgICAgICAgICAgICAgICAgICAgICA9IDB4MDY7XG5TZGxQc20uREFUQV9TSVpFXzNfU1RBVEUgICAgICAgICAgICAgICAgICAgICAgICA9IDB4MDc7XG5TZGxQc20uREFUQV9TSVpFXzRfU1RBVEUgICAgICAgICAgICAgICAgICAgICAgICA9IDB4MDg7XG5TZGxQc20uTUVTU0FHRV8xX1NUQVRFICAgICAgICAgICAgICAgICAgICAgICAgICA9IDB4MDk7XG5TZGxQc20uTUVTU0FHRV8yX1NUQVRFICAgICAgICAgICAgICAgICAgICAgICAgICA9IDB4MEE7XG5TZGxQc20uTUVTU0FHRV8zX1NUQVRFICAgICAgICAgICAgICAgICAgICAgICAgICA9IDB4MEI7XG5TZGxQc20uTUVTU0FHRV80X1NUQVRFICAgICAgICAgICAgICAgICAgICAgICAgICA9IDB4MEM7XG5TZGxQc20uREFUQV9QVU1QX1NUQVRFICAgICAgICAgICAgICAgICAgICAgICAgICA9IDB4MEQ7XG5TZGxQc20uRklOSVNIRURfU1RBVEUgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDB4RkY7XG5TZGxQc20uRVJST1JfU1RBVEUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IC0xO1xuXG5TZGxQc20uRklSU1RfRlJBTUVfREFUQV9TSVpFICAgICAgICAgICAgICAgICAgICA9IDB4MDg7XG5TZGxQc20uVkVSU0lPTl9NQVNLICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDB4RjA7IC8vNCBoaWdoZXN0IGJpdHNcblNkbFBzbS5FTkNSWVBUSU9OX01BU0sgICAgICAgICAgICAgICAgICAgICAgICAgID0gMHgwODsgLy80dGggbG93ZXN0IGJpdFxuU2RsUHNtLkZSQU1FX1RZUEVfTUFTSyAgICAgICAgICAgICAgICAgICAgICAgICAgPSAweDA3OyAvLzMgbG93ZXN0IGJpdHNcblxuZXhwb3J0IHsgU2RsUHNtIH07XG4iLCIvKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTksIExpdmlvLCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbipcbiogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4qIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuKlxuKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4qIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4qIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZVxuKiBkaXN0cmlidXRpb24uXG4qXG4qIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIExpdmlvIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzXG4qIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZVxuKiB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbipcbiogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiogQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuKiBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFXG4qIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1JcbiogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcbiogU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXG4qIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOXG4qIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4qIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4qIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cblxuaW1wb3J0IHsgU2RsUHNtIH0gZnJvbSAnLi9TZGxQc20uanMnO1xuXG5jbGFzcyBUcmFuc3BvcnRCYXNlIHtcbiAgICBcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0Jhc2VUcmFuc3BvcnRDb25maWd9IGJhc2VUcmFuc3BvcnRDb25maWdcbiAgICAgKiBAcGFyYW0ge1RyYW5zcG9ydExpc3RlbmVyfSB0cmFuc3BvcnRMaXN0ZW5lclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGJhc2VUcmFuc3BvcnRDb25maWcsIHRyYW5zcG9ydExpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX3NkbFBzbSA9IG5ldyBTZGxQc20oKTtcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0TGlzdGVuZXIgPSB0cmFuc3BvcnRMaXN0ZW5lcjtcblxuICAgIH1cblxuICAgIHN0YXJ0KCkge1xuICAgICAgICB0aHJvdyBcInN0YXJ0IG1ldGhvZCBtdXN0IGJlIG92ZXJyaWRkZW5cIjtcbiAgICB9XG5cbiAgICBzdG9wKCkge1xuICAgICAgICB0aHJvdyBcInN0b3AgbWV0aG9kIG11c3QgYmUgb3ZlcnJpZGRlblwiO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U2RsUGFja2V0fSBzZGxQYWNrZXRcbiAgICAgKi9cbiAgICBzZW5kUGFja2V0KHNkbFBhY2tldCkge1xuICAgICAgICB0aHJvdyBcInNlbmRQYWNrZXQgbWV0aG9kIG11c3QgYmUgb3ZlcnJpZGRlblwiO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgVHJhbnNwb3J0QmFzZSB9O1xuIiwiLypcbiogQ29weXJpZ2h0IChjKSAyMDE5LCBMaXZpbywgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4qXG4qIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuKiBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbipcbiogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuKiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuKiBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGVcbiogZGlzdHJpYnV0aW9uLlxuKlxuKiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBMaXZpbyBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9yc1xuKiBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbiogd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4qXG4qIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4qIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiogQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRVxuKiBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4qIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GXG4qIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTU1xuKiBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTlxuKiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKVxuKiBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuKiBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cbmNsYXNzIFRyYW5zcG9ydE1hbmFnZXJCYXNlIHtcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QmFzZVRyYW5zcG9ydENvbmZpZ30gYmFzZVRyYW5zcG9ydENvbmZpZ1xuICAgICAqIEBwYXJhbSB7VHJhbnNwb3J0TGlzdGVuZXJ9IHRyYW5zcG9ydExpc3RlbmVyXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYmFzZVRyYW5zcG9ydENvbmZpZywgdHJhbnNwb3J0TGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0Q29uZmlnID0gYmFzZVRyYW5zcG9ydENvbmZpZztcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0TGlzdGVuZXIgPSB0cmFuc3BvcnRMaXN0ZW5lcjtcbiAgICB9XG5cbiAgICBvblRyYW5zcG9ydENvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0TGlzdGVuZXIub25UcmFuc3BvcnRDb25uZWN0ZWQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jXG4gICAgICovXG4gICAgb25UcmFuc3BvcnREaXNjb25uZWN0ZWQoZnVuYykge1xuICAgICAgICB0aGlzLl90cmFuc3BvcnRMaXN0ZW5lci5vblRyYW5zcG9ydERpc2Nvbm5lY3RlZCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmNcbiAgICAgKi9cbiAgICBvbkVycm9yKGZ1bmMpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0TGlzdGVuZXIub25FcnJvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U2RsUGFja2V0fSBzZGxQYWNrZXRcbiAgICAgKi9cbiAgICBvblBhY2tldFJlY2VpdmVkKHNkbFBhY2tldCkge1xuICAgICAgICB0aGlzLl90cmFuc3BvcnRMaXN0ZW5lci5vblBhY2tldFJlY2VpdmVkKHNkbFBhY2tldCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTZGxQYWNrZXR9IHNkbFBhY2tldFxuICAgICAqL1xuICAgIHNlbmRQYWNrZXQoc2RsUGFja2V0KSB7XG4gICAgICAgIHRocm93IFwic2VuZFBhY2tldCBtZXRob2QgbXVzdCBiZSBvdmVycmlkZGVuXCI7XG4gICAgfVxuXG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRocm93IFwic3RhcnQgbWV0aG9kIG11c3QgYmUgb3ZlcnJpZGRlblwiO1xuICAgIH1cblxuICAgIHN0b3AoKSB7XG4gICAgICAgIHRocm93IFwic3RvcCBtZXRob2QgbXVzdCBiZSBvdmVycmlkZGVuXCI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtUcmFuc3BvcnRUeXBlfSB0cmFuc3BvcnRUeXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3NcbiAgICAgKi9cbiAgICBpc0Nvbm5lY3RlZCh0cmFuc3BvcnRUeXBlLCBhZGRyZXNzKSB7XG4gICAgICAgIHRocm93IFwiaXNDb25uZWN0ZWQgbWV0aG9kIG11c3QgYmUgb3ZlcnJpZGRlblwiO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgVHJhbnNwb3J0TWFuYWdlckJhc2UgfTsiLCIvKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTksIExpdmlvLCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbipcbiogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4qIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuKlxuKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4qIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4qIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZVxuKiBkaXN0cmlidXRpb24uXG4qXG4qIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIExpdmlvIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzXG4qIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZVxuKiB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbipcbiogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiogQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuKiBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFXG4qIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1JcbiogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcbiogU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXG4qIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOXG4qIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4qIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4qIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cblxuaW1wb3J0IHsgRW51bSB9IGZyb20gJy4uLy4uL3V0aWwvRW51bS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge0VudW19IFRyYW5zcG9ydFR5cGVcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBNQVBcbiAqL1xuY2xhc3MgVHJhbnNwb3J0VHlwZSBleHRlbmRzIEVudW0ge1xuXG4gICAgLyoqXG4gICAgKiBAY29uc3RydWN0b3JcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQHBhcmFtIHtTdHJpbmd9XG4gICAgKi9cbiAgICBzdGF0aWMgZ2V0IFdFQlNPQ0tFVF9TRVJWRVIoKSB7XG4gICAgICAgIHJldHVybiBUcmFuc3BvcnRUeXBlLk1BUC5XRUJTT0NLRVRfU0VSVkVSO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQHBhcmFtIHtTdHJpbmd9XG4gICAgKi9cbiAgICBzdGF0aWMgZ2V0IFdFQlNPQ0tFVF9DTElFTlQoKSB7XG4gICAgICAgIHJldHVybiBUcmFuc3BvcnRUeXBlLk1BUC5XRUJTT0NLRVRfQ0xJRU5UO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQ29uZmlybXMgd2hldGhlciB0aGUgdmFsdWUgcGFzc2VkIGluIGV4aXN0cyBpbiB0aGUgRW51bXMgb2YgdGhpcyBjbGFzc1xuICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAgKiBAcmV0dXJuIHtudWxsfFN0cmluZ30gLSBSZXR1cm5zIG51bGwgaWYgdGhlIGVudW0gdmFsdWUgZG9lc24ndCBleGlzdFxuICAgICovXG4gICAgc3RhdGljIHZhbHVlRm9yU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBUcmFuc3BvcnRUeXBlLnZhbHVlRm9yU3RyaW5nSW50ZXJuYWwodmFsdWUsIFRyYW5zcG9ydFR5cGUuTUFQKTtcbiAgICB9XG59XG5cblRyYW5zcG9ydFR5cGUuTUFQID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgXCJXRUJTT0NLRVRfU0VSVkVSXCI6IFwiV0VCU09DS0VUX1NFUlZFUlwiLFxuICAgIFwiV0VCU09DS0VUX0NMSUVOVFwiOiBcIldFQlNPQ0tFVF9DTElFTlRcIixcbiAgICBcIkNVU1RPTVwiOiBcIkNVU1RPTVwiLFxufSk7XG5cbmV4cG9ydCB7IFRyYW5zcG9ydFR5cGUgfTsiLCIvKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTksIExpdmlvLCBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbipcbiogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4qIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuKlxuKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4qIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4qIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZVxuKiBkaXN0cmlidXRpb24uXG4qXG4qIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIExpdmlvIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzXG4qIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZVxuKiB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbipcbiogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiogQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuKiBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFXG4qIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1JcbiogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcbiogU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXG4qIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOXG4qIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpXG4qIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4qIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cblxuY2xhc3MgSnNvblJwY01hcnNoYWxsZXIge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgfVxuXG4gICAgLypcbmxldCB0ZXN0TWFwID0ge1wicnBjVHlwZVwiOlwiUmVxdWVzdFwiLCBcImZ1bmN0aW9uTmFtZVwiOlwiUkFJXCJ9XG51bmRlZmluZWRcbmxldCBzdHJpbmdlZCA9IEpTT04uc3RyaW5naWZ5KHRlc3RNYXApXG51bmRlZmluZWRcbnN0cmluZ2VkXG5cIntcInJwY1R5cGVcIjpcIlJlcXVlc3RcIixcImZ1bmN0aW9uTmFtZVwiOlwiUkFJXCJ9XCJcbmxldCBhcnJheSA9IG5ldyBVaW50OEFycmF5KHN0cmluZ2VkKVxudW5kZWZpbmVkXG5hcnJheVxuVWludDhBcnJhecKgW11idWZmZXI6ICguLi4pYnl0ZUxlbmd0aDogKC4uLilieXRlT2Zmc2V0OiAoLi4uKWxlbmd0aDogKC4uLilTeW1ib2woU3ltYm9sLnRvU3RyaW5nVGFnKTogKC4uLilfX3Byb3RvX186IFR5cGVkQXJyYXlcbnZhciBlbmMgPSBuZXcgVGV4dEVuY29kZXIoKTsgLy8gYWx3YXlzIHV0Zi04XG5cbnVuZGVmaW5lZFxuYXJyYXkgPSBlbmMuZW5jb2RlKHN0cmluZ2VkKVxuVWludDhBcnJheSg0MinCoFsxMjMsIDM0LCAxMTQsIDExMiwgOTksIDg0LCAxMjEsIDExMiwgMTAxLCAzNCwgNTgsIDM0LCA4MiwgMTAxLCAxMTMsIDExNywgMTAxLCAxMTUsIDExNiwgMzQsIDQ0LCAzNCwgMTAyLCAxMTcsIDExMCwgOTksIDExNiwgMTA1LCAxMTEsIDExMCwgNzgsIDk3LCAxMDksIDEwMSwgMzQsIDU4LCAzNCwgODIsIDY1LCA3MywgMzQsIDEyNV0wOiAxMjMxOiAzNDI6IDExNDM6IDExMjQ6IDk5NTogODQ2OiAxMjE3OiAxMTI4OiAxMDE5OiAzNDEwOiA1ODExOiAzNDEyOiA4MjEzOiAxMDExNDogMTEzMTU6IDExNzE2OiAxMDExNzogMTE1MTg6IDExNjE5OiAzNDIwOiA0NDIxOiAzNDIyOiAxMDIyMzogMTE3MjQ6IDExMDI1OiA5OTI2OiAxMTYyNzogMTA1Mjg6IDExMTI5OiAxMTAzMDogNzgzMTogOTczMjogMTA5MzM6IDEwMTM0OiAzNDM1OiA1ODM2OiAzNDM3OiA4MjM4OiA2NTM5OiA3MzQwOiAzNDQxOiAxMjVidWZmZXI6ICguLi4pYnl0ZUxlbmd0aDogKC4uLilieXRlT2Zmc2V0OiAoLi4uKWxlbmd0aDogKC4uLilTeW1ib2woU3ltYm9sLnRvU3RyaW5nVGFnKTogKC4uLilfX3Byb3RvX186IFR5cGVkQXJyYXlcbnZhciBlbmMgPSBuZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiKTtcblxudW5kZWZpbmVkXG5sZXQgc3RlcDIgPSBlbmMuZGVjb2RlKGFycmF5KVxudW5kZWZpbmVkXG5zdGVwMlxuXCJ7XCJycGNUeXBlXCI6XCJSZXF1ZXN0XCIsXCJmdW5jdGlvbk5hbWVcIjpcIlJBSVwifVwiXG5sZXQgbmV3SnNvbiA9IEpTT04ucGFyc2Uoc3RlcDIpXG51bmRlZmluZWRcbm5ld0pzb25cbntycGNUeXBlOiBcIlJlcXVlc3RcIiwgZnVuY3Rpb25OYW1lOiBcIlJBSVwifVxuXG5cblxuICAgICovXG5cbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge1JwY01lc3NhZ2V9IHJwY01lc3NhZ2UgXG4gICAgICovXG4gICAgc3RhdGljIG1hcnNoYWxsKHJwY01lc3NhZ2UpIHtcbiAgICAgICAgLy9SZXR1cm5zIFVpbnQ4QXJyYXkgXG4gICAgICAgIGxldCBqc29uQnl0ZXMgPSBudWxsO1xuICAgICAgICB0cnkge1xuXG4gICAgICAgICAgICBsZXQganNvbk9iamVjdCA9IHJwY01lc3NhZ2UuZ2V0UGFyYW1ldGVycygpO1xuICAgICAgICAgICAgLy9UT0RPIGRvIHdlIG5lZWQgdG8gZ28gdGhyb3VnaCBlYWNoIHBhcmFtIGFuZCBkbyB0aGlzP1xuICAgICAgICAgICAgbGV0IHN0cmluZ1ZlcnNpb24gPSBKU09OLnN0cmluZ2lmeShqc29uT2JqZWN0KTtcbiAgICAgICAgICAgIGxldCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICAgICAgICByZXR1cm4gZW5jb2Rlci5lbmNvZGUoc3RyaW5nVmVyc2lvbik7XG5cbiAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAvL1RPRE8gcHJpbnQgZXhjZXB0aW9uXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG59XG5cbmV4cG9ydCB7IEpzb25ScGNNYXJzaGFsbGVyIH07IiwiLypcbiogQ29weXJpZ2h0IChjKSAyMDE5LCBMaXZpbywgSW5jLlxuKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKlxuKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4qXG4qIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuKiBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbipcbiogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuKiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuKiBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGVcbiogZGlzdHJpYnV0aW9uLlxuKlxuKiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBMaXZpbyBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9yc1xuKiBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmVcbiogd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4qXG4qIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4qIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiogQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRVxuKiBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4qIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GXG4qIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTU1xuKiBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTlxuKiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKVxuKiBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRVxuKiBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cbmltcG9ydCB7IExpZmVjeWNsZU1hbmFnZXIgfSBmcm9tICcuL3NyYy9tYW5hZ2VyL2xpZmVjeWNsZS9MaWZlY3ljbGVNYW5hZ2VyLmpzJztcbmltcG9ydCB7IEJpbmFyeUZyYW1lSGVhZGVyIH0gZnJvbSAnLi9zcmMvcHJvdG9jb2wvQmluYXJ5RnJhbWVIZWFkZXIuanMnO1xuaW1wb3J0IHsgTWVzc2FnZUZyYW1lQXNzZW1ibGVyIH0gZnJvbSAnLi9zcmMvcHJvdG9jb2wvTWVzc2FnZUZyYW1lQXNzZW1ibGVyLmpzJztcbmltcG9ydCB7IFNkbFBhY2tldCB9IGZyb20gJy4vc3JjL3Byb3RvY29sL1NkbFBhY2tldC5qcyc7XG5pbXBvcnQgeyBTZGxQcm90b2NvbEJhc2UgfSBmcm9tICcuL3NyYy9wcm90b2NvbC9TZGxQcm90b2NvbEJhc2UuanMnO1xuaW1wb3J0IHsgU2RsUHJvdG9jb2xMaXN0ZW5lciB9IGZyb20gJy4vc3JjL3Byb3RvY29sL1NkbFByb3RvY29sTGlzdGVuZXIuanMnO1xuaW1wb3J0IHsgQ29udHJvbEZyYW1lVGFncyB9IGZyb20gJy4vc3JjL3Byb3RvY29sL2VudW1zL0NvbnRyb2xGcmFtZVRhZ3MuanMnO1xuaW1wb3J0IHsgRnJhbWVUeXBlIH0gZnJvbSAnLi9zcmMvcHJvdG9jb2wvZW51bXMvRnJhbWVUeXBlLmpzJztcbmltcG9ydCB7IFNlcnZpY2VUeXBlIH0gZnJvbSAnLi9zcmMvcHJvdG9jb2wvZW51bXMvU2VydmljZVR5cGUuanMnO1xuaW1wb3J0IHsgUnBjTWVzc2FnZSB9IGZyb20gJy4vc3JjL3JwYy9ScGNNZXNzYWdlLmpzJztcbmltcG9ydCB7IFJwY05vdGlmaWNhdGlvbiB9IGZyb20gJy4vc3JjL3JwYy9ScGNOb3RpZmljYXRpb24uanMnO1xuaW1wb3J0IHsgUnBjUmVxdWVzdCB9IGZyb20gJy4vc3JjL3JwYy9ScGNSZXF1ZXN0LmpzJztcbmltcG9ydCB7IFJwY1Jlc3BvbnNlIH0gZnJvbSAnLi9zcmMvcnBjL1JwY1Jlc3BvbnNlLmpzJztcbmltcG9ydCB7IFJwY1N0cnVjdCB9IGZyb20gJy4vc3JjL3JwYy9ScGNTdHJ1Y3QuanMnO1xuaW1wb3J0IHsgRnVuY3Rpb25JRCB9IGZyb20gJy4vc3JjL3JwYy9lbnVtcy9GdW5jdGlvbklELmpzJztcbmltcG9ydCB7IEltYWdlVHlwZSB9IGZyb20gJy4vc3JjL3JwYy9lbnVtcy9JbWFnZVR5cGUuanMnO1xuaW1wb3J0IHsgTGFuZ3VhZ2UgfSBmcm9tICcuL3NyYy9ycGMvZW51bXMvTGFuZ3VhZ2UuanMnO1xuaW1wb3J0IHsgUmVzdWx0IH0gZnJvbSAnLi9zcmMvcnBjL2VudW1zL1Jlc3VsdC5qcyc7XG5pbXBvcnQgeyBScGNUeXBlIH0gZnJvbSAnLi9zcmMvcnBjL2VudW1zL1JwY1R5cGUuanMnO1xuaW1wb3J0IHsgQWRkQ29tbWFuZCB9IGZyb20gJy4vc3JjL3JwYy9tZXNzYWdlcy9BZGRDb21tYW5kLmpzJztcbmltcG9ydCB7IEFkZENvbW1hbmRSZXNwb25zZSB9IGZyb20gJy4vc3JjL3JwYy9tZXNzYWdlcy9BZGRDb21tYW5kUmVzcG9uc2UuanMnO1xuaW1wb3J0IHsgT25MYW5ndWFnZUNoYW5nZSB9IGZyb20gJy4vc3JjL3JwYy9tZXNzYWdlcy9Pbkxhbmd1YWdlQ2hhbmdlLmpzJztcbmltcG9ydCB7IEltYWdlIH0gZnJvbSAnLi9zcmMvcnBjL3N0cnVjdHMvSW1hZ2UuanMnO1xuaW1wb3J0IHsgTWVudVBhcmFtcyB9IGZyb20gJy4vc3JjL3JwYy9zdHJ1Y3RzL01lbnVQYXJhbXMuanMnO1xuaW1wb3J0IHsgU2RsU2Vzc2lvbiB9IGZyb20gJy4vc3JjL3Nlc3Npb24vU2RsU2Vzc2lvbi5qcyc7XG5pbXBvcnQgeyBTZGxTZXNzaW9uTGlzdGVuZXIgfSBmcm9tICcuL3NyYy9zZXNzaW9uL1NkbFNlc3Npb25MaXN0ZW5lci5qcyc7XG5pbXBvcnQgeyBTZGxQc20gfSBmcm9tICcuL3NyYy90cmFuc3BvcnQvU2RsUHNtLmpzJztcbmltcG9ydCB7IFRyYW5zcG9ydEJhc2UgfSBmcm9tICcuL3NyYy90cmFuc3BvcnQvVHJhbnNwb3J0QmFzZS5qcyc7XG5pbXBvcnQgeyBUcmFuc3BvcnRDb25maWdCYXNlIH0gZnJvbSAnLi9zcmMvdHJhbnNwb3J0L1RyYW5zcG9ydENvbmZpZ0Jhc2UuanMnO1xuaW1wb3J0IHsgVHJhbnNwb3J0TGlzdGVuZXIgfSBmcm9tICcuL3NyYy90cmFuc3BvcnQvVHJhbnNwb3J0TGlzdGVuZXIuanMnO1xuaW1wb3J0IHsgVHJhbnNwb3J0TWFuYWdlckJhc2UgfSBmcm9tICcuL3NyYy90cmFuc3BvcnQvVHJhbnNwb3J0TWFuYWdlckJhc2UuanMnO1xuaW1wb3J0IHsgVHJhbnNwb3J0VHlwZSB9IGZyb20gJy4vc3JjL3RyYW5zcG9ydC9lbnVtcy9UcmFuc3BvcnRUeXBlLmpzJztcbmltcG9ydCB7IEJpdENvbnZlcnRlciB9IGZyb20gJy4vc3JjL3V0aWwvQml0Q29udmVydGVyLmpzJztcbmltcG9ydCB7IEJzb24gfSBmcm9tICcuL3NyYy91dGlsL0Jzb24uanMnO1xuaW1wb3J0IHsgRW51bSB9IGZyb20gJy4vc3JjL3V0aWwvRW51bS5qcyc7XG5pbXBvcnQgeyBKc29uUnBjTWFyc2hhbGxlciB9IGZyb20gJy4vc3JjL3V0aWwvSnNvblJwY01hcnNoYWxsZXIuanMnO1xuaW1wb3J0IHsgVmVyc2lvbiB9IGZyb20gJy4vc3JjL3V0aWwvVmVyc2lvbi5qcyc7XG5cbmNvbnN0IFNETCA9IHtcbiAgICBtYW5hZ2VyOiB7XG4gICAgICAgIGxpZmVjeWNsZToge1xuICAgICAgICAgICAgTGlmZWN5Y2xlTWFuYWdlclxuICAgICAgICB9XG4gICAgfSxcbiAgICBwcm90b2NvbDoge1xuICAgICAgICBCaW5hcnlGcmFtZUhlYWRlcixcbiAgICAgICAgTWVzc2FnZUZyYW1lQXNzZW1ibGVyLFxuICAgICAgICBTZGxQYWNrZXQsXG4gICAgICAgIFNkbFByb3RvY29sQmFzZSxcbiAgICAgICAgU2RsUHJvdG9jb2xMaXN0ZW5lcixcbiAgICAgICAgZW51bXM6IHtcbiAgICAgICAgICAgIENvbnRyb2xGcmFtZVRhZ3MsXG4gICAgICAgICAgICBGcmFtZVR5cGUsXG4gICAgICAgICAgICBTZXJ2aWNlVHlwZVxuICAgICAgICB9XG4gICAgfSxcbiAgICBycGM6IHtcbiAgICAgICAgUnBjTWVzc2FnZSxcbiAgICAgICAgUnBjTm90aWZpY2F0aW9uLFxuICAgICAgICBScGNSZXF1ZXN0LFxuICAgICAgICBScGNSZXNwb25zZSxcbiAgICAgICAgUnBjU3RydWN0LFxuICAgICAgICBlbnVtczoge1xuICAgICAgICAgICAgRnVuY3Rpb25JRCxcbiAgICAgICAgICAgIEltYWdlVHlwZSxcbiAgICAgICAgICAgIExhbmd1YWdlLFxuICAgICAgICAgICAgUmVzdWx0LFxuICAgICAgICAgICAgUnBjVHlwZVxuICAgICAgICB9LFxuICAgICAgICBtZXNzYWdlczoge1xuICAgICAgICAgICAgQWRkQ29tbWFuZCxcbiAgICAgICAgICAgIEFkZENvbW1hbmRSZXNwb25zZSxcbiAgICAgICAgICAgIE9uTGFuZ3VhZ2VDaGFuZ2VcbiAgICAgICAgfSxcbiAgICAgICAgc3RydWN0czoge1xuICAgICAgICAgICAgSW1hZ2UsXG4gICAgICAgICAgICBNZW51UGFyYW1zXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHNlc3Npb246IHtcbiAgICAgICAgU2RsU2Vzc2lvbixcbiAgICAgICAgU2RsU2Vzc2lvbkxpc3RlbmVyXG4gICAgfSxcbiAgICB0cmFuc3BvcnQ6IHtcbiAgICAgICAgU2RsUHNtLFxuICAgICAgICBUcmFuc3BvcnRCYXNlLFxuICAgICAgICBUcmFuc3BvcnRDb25maWdCYXNlLFxuICAgICAgICBUcmFuc3BvcnRMaXN0ZW5lcixcbiAgICAgICAgVHJhbnNwb3J0TWFuYWdlckJhc2UsXG4gICAgICAgIGVudW1zOiB7XG4gICAgICAgICAgICBUcmFuc3BvcnRUeXBlXG4gICAgICAgIH1cbiAgICB9LFxuICAgIHV0aWw6IHtcbiAgICAgICAgQml0Q29udmVydGVyLFxuICAgICAgICBCc29uLFxuICAgICAgICBFbnVtLFxuICAgICAgICBKc29uUnBjTWFyc2hhbGxlcixcbiAgICAgICAgVmVyc2lvblxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU0RMOyJdLCJuYW1lcyI6WyJMaWZlY3ljbGVNYW5hZ2VyIiwiQml0Q29udmVydGVyIiwiYnl0ZXMiLCJoZXhTdHJpbmciLCJidWZmZXIiLCJvZmZzZXQiLCJ2aWV3IiwiRGF0YVZpZXciLCJnZXRVaW50MzIiLCJ2YWx1ZSIsIkFycmF5QnVmZmVyIiwic2V0VWludDMyIiwiQmluYXJ5RnJhbWVIZWFkZXIiLCJycGNUeXBlIiwiZnVuY3Rpb25JZCIsImNvcnJlbGF0aW9uSWQiLCJqc29uU2l6ZSIsIl9ycGNUeXBlIiwiX2Z1bmN0aW9uSWQiLCJfY29ycmVsYXRpb25JZCIsIl9qc29uU2l6ZSIsIl9qc29uRGF0YSIsIl9idWxrRGF0YSIsImJpbkhlYWRlciIsInR5cGUiLCJpZCIsInNpemUiLCJkYXRhIiwiTWVzc2FnZUZyYW1lQXNzZW1ibGVyIiwiaGVhZGVyU2l6ZSIsImNhbGxiYWNrIiwiX2FjY3VtdWxhdG9yIiwiX2hlYWRlcnNpemUiLCJfdG90YWxTaXplIiwiX2NhbGxiYWNrIiwic2RsUGFja2V0IiwiRW51bSIsIm1hcCIsImtleSIsIkZyYW1lVHlwZSIsIk1BUCIsIkNPTlRST0wiLCJGSVJTVCIsIkNPTlNFQ1VUSVZFIiwiU0lOR0xFIiwiT2JqZWN0IiwiZnJlZXplIiwiZXhwb3J0cyIsIm1vZHVsZXMiLCJpbnN0YWxsZWRNb2R1bGVzIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIm1vZHVsZUlkIiwibW9kdWxlIiwiaSIsImwiLCJjYWxsIiwibSIsImMiLCJkIiwibmFtZSIsImdldHRlciIsIm8iLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXQiLCJuIiwiX19lc01vZHVsZSIsImdldERlZmF1bHQiLCJnZXRNb2R1bGVFeHBvcnRzIiwib2JqZWN0IiwicHJvcGVydHkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsInAiLCJzIiwiZyIsIkZ1bmN0aW9uIiwiZXZhbCIsImUiLCJ3aW5kb3ciLCJnbG9iYWwiLCJiYXNlNjQiLCJpZWVlNzU0IiwiaXNBcnJheSIsIkJ1ZmZlciIsIlNsb3dCdWZmZXIiLCJJTlNQRUNUX01BWF9CWVRFUyIsIlRZUEVEX0FSUkFZX1NVUFBPUlQiLCJ1bmRlZmluZWQiLCJ0eXBlZEFycmF5U3VwcG9ydCIsImtNYXhMZW5ndGgiLCJhcnIiLCJVaW50OEFycmF5IiwiX19wcm90b19fIiwiZm9vIiwic3ViYXJyYXkiLCJieXRlTGVuZ3RoIiwiY3JlYXRlQnVmZmVyIiwidGhhdCIsImxlbmd0aCIsIlJhbmdlRXJyb3IiLCJhcmciLCJlbmNvZGluZ09yT2Zmc2V0IiwiRXJyb3IiLCJhbGxvY1Vuc2FmZSIsImZyb20iLCJwb29sU2l6ZSIsIl9hdWdtZW50IiwiVHlwZUVycm9yIiwiZnJvbUFycmF5QnVmZmVyIiwiZnJvbVN0cmluZyIsImZyb21PYmplY3QiLCJTeW1ib2wiLCJzcGVjaWVzIiwiYXNzZXJ0U2l6ZSIsImFsbG9jIiwiZmlsbCIsImVuY29kaW5nIiwiY2hlY2tlZCIsImFsbG9jVW5zYWZlU2xvdyIsInN0cmluZyIsImlzRW5jb2RpbmciLCJhY3R1YWwiLCJ3cml0ZSIsInNsaWNlIiwiZnJvbUFycmF5TGlrZSIsImFycmF5IiwiYnl0ZU9mZnNldCIsIm9iaiIsImlzQnVmZmVyIiwibGVuIiwiY29weSIsImlzbmFuIiwidG9TdHJpbmciLCJiIiwiX2lzQnVmZmVyIiwiY29tcGFyZSIsImEiLCJ4IiwieSIsIk1hdGgiLCJtaW4iLCJTdHJpbmciLCJ0b0xvd2VyQ2FzZSIsImNvbmNhdCIsImxpc3QiLCJwb3MiLCJidWYiLCJpc1ZpZXciLCJsb3dlcmVkQ2FzZSIsInV0ZjhUb0J5dGVzIiwiYmFzZTY0VG9CeXRlcyIsInNsb3dUb1N0cmluZyIsInN0YXJ0IiwiZW5kIiwiaGV4U2xpY2UiLCJ1dGY4U2xpY2UiLCJhc2NpaVNsaWNlIiwibGF0aW4xU2xpY2UiLCJiYXNlNjRTbGljZSIsInV0ZjE2bGVTbGljZSIsInN3YXAiLCJzd2FwMTYiLCJzd2FwMzIiLCJzd2FwNjQiLCJhcmd1bWVudHMiLCJhcHBseSIsImVxdWFscyIsImluc3BlY3QiLCJzdHIiLCJtYXgiLCJtYXRjaCIsImpvaW4iLCJ0YXJnZXQiLCJ0aGlzU3RhcnQiLCJ0aGlzRW5kIiwidGhpc0NvcHkiLCJ0YXJnZXRDb3B5IiwiYmlkaXJlY3Rpb25hbEluZGV4T2YiLCJ2YWwiLCJkaXIiLCJpc05hTiIsImFycmF5SW5kZXhPZiIsImluZGV4T2YiLCJsYXN0SW5kZXhPZiIsImluZGV4U2l6ZSIsImFyckxlbmd0aCIsInZhbExlbmd0aCIsInJlYWQiLCJyZWFkVUludDE2QkUiLCJmb3VuZEluZGV4IiwiZm91bmQiLCJqIiwiaW5jbHVkZXMiLCJoZXhXcml0ZSIsIk51bWJlciIsInJlbWFpbmluZyIsInN0ckxlbiIsInBhcnNlZCIsInBhcnNlSW50Iiwic3Vic3RyIiwidXRmOFdyaXRlIiwiYmxpdEJ1ZmZlciIsImFzY2lpV3JpdGUiLCJhc2NpaVRvQnl0ZXMiLCJsYXRpbjFXcml0ZSIsImJhc2U2NFdyaXRlIiwidWNzMldyaXRlIiwidXRmMTZsZVRvQnl0ZXMiLCJpc0Zpbml0ZSIsInRvSlNPTiIsIkFycmF5IiwiX2FyciIsImZyb21CeXRlQXJyYXkiLCJyZXMiLCJmaXJzdEJ5dGUiLCJjb2RlUG9pbnQiLCJieXRlc1BlclNlcXVlbmNlIiwic2Vjb25kQnl0ZSIsInRoaXJkQnl0ZSIsImZvdXJ0aEJ5dGUiLCJ0ZW1wQ29kZVBvaW50IiwicHVzaCIsImRlY29kZUNvZGVQb2ludHNBcnJheSIsIk1BWF9BUkdVTUVOVFNfTEVOR1RIIiwiY29kZVBvaW50cyIsImZyb21DaGFyQ29kZSIsInJldCIsIm91dCIsInRvSGV4IiwibmV3QnVmIiwic2xpY2VMZW4iLCJjaGVja09mZnNldCIsImV4dCIsInJlYWRVSW50TEUiLCJub0Fzc2VydCIsIm11bCIsInJlYWRVSW50QkUiLCJyZWFkVUludDgiLCJyZWFkVUludDE2TEUiLCJyZWFkVUludDMyTEUiLCJyZWFkVUludDMyQkUiLCJyZWFkSW50TEUiLCJwb3ciLCJyZWFkSW50QkUiLCJyZWFkSW50OCIsInJlYWRJbnQxNkxFIiwicmVhZEludDE2QkUiLCJyZWFkSW50MzJMRSIsInJlYWRJbnQzMkJFIiwicmVhZEZsb2F0TEUiLCJyZWFkRmxvYXRCRSIsInJlYWREb3VibGVMRSIsInJlYWREb3VibGVCRSIsImNoZWNrSW50Iiwid3JpdGVVSW50TEUiLCJtYXhCeXRlcyIsIndyaXRlVUludEJFIiwid3JpdGVVSW50OCIsImZsb29yIiwib2JqZWN0V3JpdGVVSW50MTYiLCJsaXR0bGVFbmRpYW4iLCJ3cml0ZVVJbnQxNkxFIiwid3JpdGVVSW50MTZCRSIsIm9iamVjdFdyaXRlVUludDMyIiwid3JpdGVVSW50MzJMRSIsIndyaXRlVUludDMyQkUiLCJ3cml0ZUludExFIiwibGltaXQiLCJzdWIiLCJ3cml0ZUludEJFIiwid3JpdGVJbnQ4Iiwid3JpdGVJbnQxNkxFIiwid3JpdGVJbnQxNkJFIiwid3JpdGVJbnQzMkxFIiwid3JpdGVJbnQzMkJFIiwiY2hlY2tJRUVFNzU0Iiwid3JpdGVGbG9hdCIsIndyaXRlRmxvYXRMRSIsIndyaXRlRmxvYXRCRSIsIndyaXRlRG91YmxlIiwid3JpdGVEb3VibGVMRSIsIndyaXRlRG91YmxlQkUiLCJ0YXJnZXRTdGFydCIsInNldCIsImNvZGUiLCJjaGFyQ29kZUF0IiwiSU5WQUxJRF9CQVNFNjRfUkUiLCJiYXNlNjRjbGVhbiIsInN0cmluZ3RyaW0iLCJyZXBsYWNlIiwidHJpbSIsInVuaXRzIiwiSW5maW5pdHkiLCJsZWFkU3Vycm9nYXRlIiwiYnl0ZUFycmF5IiwiaGkiLCJsbyIsInRvQnl0ZUFycmF5Iiwic3JjIiwiZHN0IiwiZmFjdG9yeSIsImxvbmciLCJjb21tb25qc0dsb2JhbCIsInNlbGYiLCJjcmVhdGVDb21tb25qc01vZHVsZSIsImZuIiwiZ2V0Q2pzRXhwb3J0RnJvbU5hbWVzcGFjZSIsIk1hcCIsIl9rZXlzIiwiX3ZhbHVlcyIsImVudHJ5IiwidiIsImNsZWFyIiwic3BsaWNlIiwiZW50cmllcyIsImluZGV4IiwibmV4dCIsImRvbmUiLCJmb3JFYWNoIiwiaGFzIiwia2V5cyIsInZhbHVlcyIsIm1hcF8xIiwidG9FeHRlbmRlZEpTT04iLCJvcHRpb25zIiwicmVsYXhlZCIsInRvTnVtYmVyIiwiJG51bWJlckxvbmciLCJmcm9tRXh0ZW5kZWRKU09OIiwiZG9jIiwicmVzdWx0IiwibG9uZ18xIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwicHJvcHMiLCJkZXNjcmlwdG9yIiwid3JpdGFibGUiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJEb3VibGUiLCJ2YWx1ZU9mIiwiJG51bWJlckRvdWJsZSIsInBhcnNlRmxvYXQiLCJkb3VibGVfMSIsIl90eXBlb2YiLCJfdHlwZW9mMiIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJfY2xhc3NDYWxsQ2hlY2skMSIsIl9kZWZpbmVQcm9wZXJ0aWVzJDEiLCJfY3JlYXRlQ2xhc3MkMSIsIl9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsIlJlZmVyZW5jZUVycm9yIiwiX2dldFByb3RvdHlwZU9mIiwic2V0UHJvdG90eXBlT2YiLCJnZXRQcm90b3R5cGVPZiIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsIl9zZXRQcm90b3R5cGVPZiIsIlRpbWVzdGFtcCIsIl9Mb25nIiwibG93IiwiaGlnaCIsIl90aGlzIiwiaXNMb25nIiwiJHRpbWVzdGFtcCIsInQiLCJmcm9tSW50IiwiZnJvbU51bWJlciIsImZyb21CaXRzIiwibG93Qml0cyIsImhpZ2hCaXRzIiwib3B0X3JhZGl4IiwidGltZXN0YW1wIiwiZW1wdHkiLCJlbXB0eSQxIiwicmVxdWlyZSQkMCIsIm5vcm1hbGl6ZWRGdW5jdGlvblN0cmluZyIsImluc2VjdXJlUmFuZG9tQnl0ZXMiLCJyYW5kb20iLCJyYW5kb21CeXRlcyIsImNyeXB0byIsImdldFJhbmRvbVZhbHVlcyIsInV0aWxzIiwic2V0VGltZW91dCIsImNsZWFyVGltZW91dCIsInBlcmZvcm1hbmNlIiwicGVyZm9ybWFuY2VOb3ciLCJub3ciLCJtb3pOb3ciLCJtc05vdyIsIm9Ob3ciLCJ3ZWJraXROb3ciLCJEYXRlIiwiZ2V0VGltZSIsImluaGVyaXRzIiwiY3RvciIsInN1cGVyQ3RvciIsInN1cGVyXyIsIlRlbXBDdG9yIiwiaW5oZXJpdHMkMSIsIl90eXBlb2YkMSIsImZvcm1hdFJlZ0V4cCIsImZvcm1hdCIsImYiLCJpc1N0cmluZyIsIm9iamVjdHMiLCJhcmdzIiwiSlNPTiIsInN0cmluZ2lmeSIsIl8iLCJpc051bGwiLCJpc09iamVjdCIsImRlcHJlY2F0ZSIsIm1zZyIsImlzVW5kZWZpbmVkIiwicHJvY2VzcyIsIndhcm5lZCIsImRlcHJlY2F0ZWQiLCJjb25zb2xlIiwiZXJyb3IiLCJkZWJ1Z3MiLCJkZWJ1Z0Vudmlyb24iLCJkZWJ1Z2xvZyIsInRvVXBwZXJDYXNlIiwiUmVnRXhwIiwidGVzdCIsInBpZCIsIm9wdHMiLCJjdHgiLCJzZWVuIiwic3R5bGl6ZSIsInN0eWxpemVOb0NvbG9yIiwiZGVwdGgiLCJjb2xvcnMiLCJpc0Jvb2xlYW4iLCJzaG93SGlkZGVuIiwiX2V4dGVuZCIsImN1c3RvbUluc3BlY3QiLCJzdHlsaXplV2l0aENvbG9yIiwiZm9ybWF0VmFsdWUiLCJzdHlsZXMiLCJzdHlsZVR5cGUiLCJzdHlsZSIsImFycmF5VG9IYXNoIiwiaGFzaCIsImlkeCIsInJlY3Vyc2VUaW1lcyIsImlzRnVuY3Rpb24iLCJwcmltaXRpdmUiLCJmb3JtYXRQcmltaXRpdmUiLCJ2aXNpYmxlS2V5cyIsImdldE93blByb3BlcnR5TmFtZXMiLCJpc0Vycm9yIiwiZm9ybWF0RXJyb3IiLCJpc1JlZ0V4cCIsImlzRGF0ZSIsImJhc2UiLCJicmFjZXMiLCJ0b1VUQ1N0cmluZyIsIm91dHB1dCIsImZvcm1hdEFycmF5IiwiZm9ybWF0UHJvcGVydHkiLCJwb3AiLCJyZWR1Y2VUb1NpbmdsZVN0cmluZyIsInNpbXBsZSIsImlzTnVtYmVyIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInNwbGl0IiwibGluZSIsInJlZHVjZSIsInByZXYiLCJjdXIiLCJhciIsImlzTnVsbE9yVW5kZWZpbmVkIiwiaXNTeW1ib2wiLCJyZSIsIm9iamVjdFRvU3RyaW5nIiwiaXNQcmltaXRpdmUiLCJtYXliZUJ1ZiIsInBhZCIsIm1vbnRocyIsInRpbWVzdGFtcCQxIiwidGltZSIsImdldEhvdXJzIiwiZ2V0TWludXRlcyIsImdldFNlY29uZHMiLCJnZXREYXRlIiwiZ2V0TW9udGgiLCJsb2ciLCJvcmlnaW4iLCJhZGQiLCJwcm9wIiwidXRpbCIsInV0aWwkMSIsInV0aWwkMiIsIl9jbGFzc0NhbGxDaGVjayQyIiwiX2RlZmluZVByb3BlcnRpZXMkMiIsIl9jcmVhdGVDbGFzcyQyIiwiQnVmZmVyJDEiLCJyYW5kb21CeXRlcyQxIiwiZGVwcmVjYXRlJDEiLCJQUk9DRVNTX1VOSVFVRSIsImNoZWNrRm9ySGV4UmVnRXhwIiwiaGFzQnVmZmVyVHlwZSIsImVyciIsImhleFRhYmxlIiwiX2kiLCJkZWNvZGVMb29rdXAiLCJfQnVmZmVyIiwiY29udmVydFRvSGV4IiwibWFrZU9iamVjdElkRXJyb3IiLCJpbnZhbGlkU3RyaW5nIiwiaW52YWxpZENoYXJhY3RlciIsIk9iamVjdElkIiwiZ2VuZXJhdGUiLCJjYWNoZUhleFN0cmluZyIsIl9faWQiLCJ2YWxpZCIsImlzVmFsaWQiLCJjcmVhdGVGcm9tSGV4U3RyaW5nIiwidG9IZXhTdHJpbmciLCJfaTIiLCJoZXhDaGFyIiwib3RoZXJJZCIsImdldFRpbWVzdGFtcCIsInNldFRpbWUiLCIkb2lkIiwiZ2V0SW5jIiwiaW5jIiwiYnVmZmVyJCQxIiwiY3JlYXRlUGsiLCJjcmVhdGVGcm9tVGltZSIsImdldF9pbmMiLCJjdXN0b20iLCJvYmplY3RpZCIsIl9jbGFzc0NhbGxDaGVjayQzIiwiX2RlZmluZVByb3BlcnRpZXMkMyIsIl9jcmVhdGVDbGFzcyQzIiwiYWxwaGFiZXRpemUiLCJzb3J0IiwiQlNPTlJlZ0V4cCIsInBhdHRlcm4iLCIkcmVndWxhckV4cHJlc3Npb24iLCJyZWdleHAiLCJfY2xhc3NDYWxsQ2hlY2skNCIsIl9kZWZpbmVQcm9wZXJ0aWVzJDQiLCJfY3JlYXRlQ2xhc3MkNCIsIkJTT05TeW1ib2wiLCIkc3ltYm9sIiwic3ltYm9sIiwiX2NsYXNzQ2FsbENoZWNrJDUiLCJfZGVmaW5lUHJvcGVydGllcyQ1IiwiX2NyZWF0ZUNsYXNzJDUiLCJJbnQzMiIsIiRudW1iZXJJbnQiLCJpbnRfMzIiLCJfY2xhc3NDYWxsQ2hlY2skNiIsIl9kZWZpbmVQcm9wZXJ0aWVzJDYiLCJfY3JlYXRlQ2xhc3MkNiIsIkNvZGUiLCJzY29wZSIsIiRjb2RlIiwiJHNjb3BlIiwiQnVmZmVyJDIiLCJQQVJTRV9TVFJJTkdfUkVHRVhQIiwiUEFSU0VfSU5GX1JFR0VYUCIsIlBBUlNFX05BTl9SRUdFWFAiLCJFWFBPTkVOVF9NQVgiLCJFWFBPTkVOVF9NSU4iLCJFWFBPTkVOVF9CSUFTIiwiTUFYX0RJR0lUUyIsIk5BTl9CVUZGRVIiLCJyZXZlcnNlIiwiSU5GX05FR0FUSVZFX0JVRkZFUiIsIklORl9QT1NJVElWRV9CVUZGRVIiLCJFWFBPTkVOVF9SRUdFWCIsImlzRGlnaXQiLCJkaXZpZGV1MTI4IiwiRElWSVNPUiIsIl9yZW0iLCJwYXJ0cyIsInF1b3RpZW50IiwicmVtIiwic2hpZnRMZWZ0IiwiZGl2IiwibW9kdWxvIiwibXVsdGlwbHk2NHgyIiwibGVmdCIsInJpZ2h0IiwibGVmdEhpZ2giLCJzaGlmdFJpZ2h0VW5zaWduZWQiLCJsZWZ0TG93IiwiZ2V0TG93Qml0cyIsInJpZ2h0SGlnaCIsInJpZ2h0TG93IiwicHJvZHVjdEhpZ2giLCJtdWx0aXBseSIsInByb2R1Y3RNaWQiLCJwcm9kdWN0TWlkMiIsInByb2R1Y3RMb3ciLCJsZXNzVGhhbiIsInVobGVmdCIsInVocmlnaHQiLCJ1bGxlZnQiLCJ1bHJpZ2h0IiwiaW52YWxpZEVyciIsIm1lc3NhZ2UiLCJEZWNpbWFsMTI4IiwiaXNOZWdhdGl2ZSIsInNhd1JhZGl4IiwiZm91bmROb25aZXJvIiwic2lnbmlmaWNhbnREaWdpdHMiLCJuRGlnaXRzUmVhZCIsIm5EaWdpdHMiLCJyYWRpeFBvc2l0aW9uIiwiZmlyc3ROb25aZXJvIiwiZGlnaXRzIiwibkRpZ2l0c1N0b3JlZCIsImRpZ2l0c0luc2VydCIsImZpcnN0RGlnaXQiLCJsYXN0RGlnaXQiLCJleHBvbmVudCIsInNpZ25pZmljYW5kSGlnaCIsInNpZ25pZmljYW5kTG93IiwiYmlhc2VkRXhwb25lbnQiLCJzdHJpbmdNYXRjaCIsImluZk1hdGNoIiwibmFuTWF0Y2giLCJ1bnNpZ25lZE51bWJlciIsImV4cFNpZ24iLCJleHBOdW1iZXIiLCJkaWdpdHNTdHJpbmciLCJfZGlnaXRzU3RyaW5nIiwiZW5kT2ZTdHJpbmciLCJyb3VuZERpZ2l0Iiwicm91bmRCaXQiLCJkSWR4IiwiX2RJZHgiLCJfZElkeDIiLCJzaWduaWZpY2FuZCIsImRlYyIsImFuZCIsIm9yIiwiQ09NQklOQVRJT05fTUFTSyIsIkVYUE9ORU5UX01BU0siLCJDT01CSU5BVElPTl9JTkZJTklUWSIsIkNPTUJJTkFUSU9OX05BTiIsIm1pZGgiLCJtaWRsIiwiY29tYmluYXRpb24iLCJiaWFzZWRfZXhwb25lbnQiLCJzaWduaWZpY2FuZF9kaWdpdHMiLCJzY2llbnRpZmljX2V4cG9uZW50IiwiaXNfemVybyIsInNpZ25pZmljYW5kX21zYiIsInNpZ25pZmljYW5kMTI4IiwiayIsIlpFUk8iLCJsZWFzdF9kaWdpdHMiLCJyYWRpeF9wb3NpdGlvbiIsIl9pMyIsIl9pNCIsIiRudW1iZXJEZWNpbWFsIiwiZGVjaW1hbDEyOCIsIl9jbGFzc0NhbGxDaGVjayQ3IiwiX2RlZmluZVByb3BlcnRpZXMkNyIsIl9jcmVhdGVDbGFzcyQ3IiwiTWluS2V5IiwiJG1pbktleSIsIm1pbl9rZXkiLCJfY2xhc3NDYWxsQ2hlY2skOCIsIl9kZWZpbmVQcm9wZXJ0aWVzJDgiLCJfY3JlYXRlQ2xhc3MkOCIsIk1heEtleSIsIiRtYXhLZXkiLCJtYXhfa2V5IiwiX2NsYXNzQ2FsbENoZWNrJDkiLCJfZGVmaW5lUHJvcGVydGllcyQ5IiwiX2NyZWF0ZUNsYXNzJDkiLCJEQlJlZiIsImNvbGxlY3Rpb24iLCJvaWQiLCJkYiIsImZpZWxkcyIsInNoaWZ0IiwiYXNzaWduIiwiJHJlZiIsIiRpZCIsIiRkYiIsImRiX3JlZiIsIl9jbGFzc0NhbGxDaGVjayRhIiwiX2RlZmluZVByb3BlcnRpZXMkYSIsIl9jcmVhdGVDbGFzcyRhIiwiQnVmZmVyJDMiLCJCaW5hcnkiLCJzdWJUeXBlIiwic3ViX3R5cGUiLCJCU09OX0JJTkFSWV9TVUJUWVBFX0RFRkFVTFQiLCJwb3NpdGlvbiIsIndyaXRlU3RyaW5nVG9BcnJheSIsIkJVRkZFUl9TSVpFIiwicHV0IiwiYnl0ZV92YWx1ZSIsImRlY29kZWRfYnl0ZSIsIl9idWZmZXIiLCJpc1VpbnQ4QXJyYXkiLCJhc1JhdyIsIm5ld0J1ZmZlciIsImNvbnZlcnRBcnJheXRvVXRmOEJpbmFyeVN0cmluZyIsImJhc2U2NFN0cmluZyIsIiRiaW5hcnkiLCJzdGFydEluZGV4IiwiZW5kSW5kZXgiLCJTVUJUWVBFX0RFRkFVTFQiLCJTVUJUWVBFX0ZVTkNUSU9OIiwiU1VCVFlQRV9CWVRFX0FSUkFZIiwiU1VCVFlQRV9VVUlEX09MRCIsIlNVQlRZUEVfVVVJRCIsIlNVQlRZUEVfTUQ1IiwiU1VCVFlQRV9VU0VSX0RFRklORUQiLCJiaW5hcnkiLCJjb25zdGFudHMiLCJCU09OX0lOVDMyX01BWCIsIkJTT05fSU5UMzJfTUlOIiwiQlNPTl9JTlQ2NF9NQVgiLCJCU09OX0lOVDY0X01JTiIsIkpTX0lOVF9NQVgiLCJKU19JTlRfTUlOIiwiQlNPTl9EQVRBX05VTUJFUiIsIkJTT05fREFUQV9TVFJJTkciLCJCU09OX0RBVEFfT0JKRUNUIiwiQlNPTl9EQVRBX0FSUkFZIiwiQlNPTl9EQVRBX0JJTkFSWSIsIkJTT05fREFUQV9VTkRFRklORUQiLCJCU09OX0RBVEFfT0lEIiwiQlNPTl9EQVRBX0JPT0xFQU4iLCJCU09OX0RBVEFfREFURSIsIkJTT05fREFUQV9OVUxMIiwiQlNPTl9EQVRBX1JFR0VYUCIsIkJTT05fREFUQV9EQlBPSU5URVIiLCJCU09OX0RBVEFfQ09ERSIsIkJTT05fREFUQV9TWU1CT0wiLCJCU09OX0RBVEFfQ09ERV9XX1NDT1BFIiwiQlNPTl9EQVRBX0lOVCIsIkJTT05fREFUQV9USU1FU1RBTVAiLCJCU09OX0RBVEFfTE9ORyIsIkJTT05fREFUQV9ERUNJTUFMMTI4IiwiQlNPTl9EQVRBX01JTl9LRVkiLCJCU09OX0RBVEFfTUFYX0tFWSIsIkJTT05fQklOQVJZX1NVQlRZUEVfRlVOQ1RJT04iLCJCU09OX0JJTkFSWV9TVUJUWVBFX0JZVEVfQVJSQVkiLCJCU09OX0JJTkFSWV9TVUJUWVBFX1VVSUQiLCJCU09OX0JJTkFSWV9TVUJUWVBFX01ENSIsIkJTT05fQklOQVJZX1NVQlRZUEVfVVNFUl9ERUZJTkVEIiwiX3R5cGVvZiQyIiwia2V5c1RvQ29kZWNzIiwiZGVzZXJpYWxpemVWYWx1ZSIsIiR1bmRlZmluZWQiLCJmaWx0ZXIiLCJzdGFydHNXaXRoIiwiJGRhdGUiLCJkYXRlIiwicGFyc2UiLCIkZGJQb2ludGVyIiwiZG9sbGFyS2V5cyIsInRleHQiLCJzdHJpY3QiLCJyZXBsYWNlciIsInNwYWNlIiwic2VyaWFsaXplQXJyYXkiLCJzZXJpYWxpemVEb2N1bWVudCIsInNlcmlhbGl6ZSIsImJzb24iLCJkZXNlcmlhbGl6ZSIsImVqc29uIiwic2VyaWFsaXplVmFsdWUiLCJnZXRJU09TdHJpbmciLCJpc29TdHIiLCJ0b0lTT1N0cmluZyIsImdldFVUQ01pbGxpc2Vjb25kcyIsImRhdGVOdW0iLCJpblJhbmdlIiwiaW50MzJSYW5nZSIsImludDY0UmFuZ2UiLCJmbGFncyIsInJ4Iiwic291cmNlIiwiQlNPTl9UWVBFX01BUFBJTkdTIiwic3VidHlwZSIsIm5hbWVzcGFjZSIsIkxvbmciLCJsb3dfIiwiaGlnaF8iLCJ1bnNpZ25lZCIsInVuc2lnbmVkXyIsIk9iamVjdElEIiwiYnNvbnR5cGUiLCJfYnNvbnR5cGUiLCJfZG9jIiwiX2RvYzIiLCJtYXBwZXIiLCJleHRlbmRlZF9qc29uIiwiRklSU1RfQklUIiwiRklSU1RfVFdPX0JJVFMiLCJGSVJTVF9USFJFRV9CSVRTIiwiRklSU1RfRk9VUl9CSVRTIiwiRklSU1RfRklWRV9CSVRTIiwiVFdPX0JJVF9DSEFSIiwiVEhSRUVfQklUX0NIQVIiLCJGT1VSX0JJVF9DSEFSIiwiQ09OVElOVUlOR19DSEFSIiwidmFsaWRhdGVVdGY4IiwiY29udGludWF0aW9uIiwiYnl0ZSIsInZhbGlkYXRlVXRmOF8xIiwidmFsaWRhdGVfdXRmOCIsIkJ1ZmZlciQ0IiwidmFsaWRhdGVVdGY4JDEiLCJKU19JTlRfTUFYX0xPTkciLCJKU19JTlRfTUlOX0xPTkciLCJmdW5jdGlvbkNhY2hlIiwiZGVzZXJpYWxpemUkMSIsImFsbG93T2JqZWN0U21hbGxlclRoYW5CdWZmZXJTaXplIiwiZGVzZXJpYWxpemVPYmplY3QiLCJldmFsRnVuY3Rpb25zIiwiY2FjaGVGdW5jdGlvbnMiLCJjYWNoZUZ1bmN0aW9uc0NyYzMyIiwiY3JjMzIiLCJmaWVsZHNBc1JhdyIsInJhdyIsImJzb25SZWdFeHAiLCJwcm9tb3RlQnVmZmVycyIsInByb21vdGVMb25ncyIsInByb21vdGVWYWx1ZXMiLCJhcnJheUluZGV4IiwiZWxlbWVudFR5cGUiLCJzdHJpbmdTaXplIiwiX2luZGV4Iiwib2JqZWN0U2l6ZSIsIl9pbmRleDIiLCJfb2JqZWN0U2l6ZSIsImFycmF5T3B0aW9ucyIsInN0b3BJbmRleCIsIl9sb3dCaXRzIiwiX2hpZ2hCaXRzIiwibG9uZyQkMSIsImxlc3NUaGFuT3JFcXVhbCIsImdyZWF0ZXJUaGFuT3JFcXVhbCIsImRlY2ltYWwxMjgkJDEiLCJ0b09iamVjdCIsImJpbmFyeVNpemUiLCJ0b3RhbEJpbmFyeVNpemUiLCJyZWdFeHBPcHRpb25zIiwib3B0aW9uc0FycmF5IiwiX3NvdXJjZSIsIl9yZWdFeHBPcHRpb25zIiwiX3N0cmluZ1NpemUiLCJfbG93Qml0czIiLCJfaGlnaEJpdHMyIiwiX3N0cmluZ1NpemUyIiwiZnVuY3Rpb25TdHJpbmciLCJpc29sYXRlRXZhbFdpdGhIYXNoIiwiaXNvbGF0ZUV2YWwiLCJ0b3RhbFNpemUiLCJfc3RyaW5nU2l6ZTMiLCJfZnVuY3Rpb25TdHJpbmciLCJfaW5kZXgzIiwiX29iamVjdFNpemUyIiwic2NvcGVPYmplY3QiLCJfaGFzaCIsIl9zdHJpbmdTaXplNCIsIm9pZEJ1ZmZlciIsIl9vaWQiLCJiaW5kIiwiZGVzZXJpYWxpemVyIiwicmVhZElFRUU3NTQiLCJlbmRpYW4iLCJtTGVuIiwibkJ5dGVzIiwiYkJFIiwiZUxlbiIsImVNYXgiLCJlQmlhcyIsIm5CaXRzIiwiTmFOIiwid3JpdGVJRUVFNzU0IiwicnQiLCJhYnMiLCJMTjIiLCJmbG9hdF9wYXJzZXIiLCJfdHlwZW9mJDMiLCJCdWZmZXIkNSIsIndyaXRlSUVFRTc1NCQxIiwibm9ybWFsaXplZEZ1bmN0aW9uU3RyaW5nJDEiLCJyZWdleHAkMSIsImlnbm9yZUtleXMiLCJTZXQiLCJpc0RhdGUkMSIsImlzUmVnRXhwJDEiLCJzZXJpYWxpemVTdHJpbmciLCJudW1iZXJPZldyaXR0ZW5CeXRlcyIsInNlcmlhbGl6ZU51bWJlciIsIl9udW1iZXJPZldyaXR0ZW5CeXRlcyIsIl9udW1iZXJPZldyaXR0ZW5CeXRlczIiLCJsb25nVmFsIiwiZ2V0SGlnaEJpdHMiLCJfbnVtYmVyT2ZXcml0dGVuQnl0ZXMzIiwic2VyaWFsaXplTnVsbCIsInNlcmlhbGl6ZUJvb2xlYW4iLCJzZXJpYWxpemVEYXRlIiwiZGF0ZUluTWlsaXMiLCJzZXJpYWxpemVSZWdFeHAiLCJpZ25vcmVDYXNlIiwibXVsdGlsaW5lIiwic2VyaWFsaXplQlNPTlJlZ0V4cCIsInNlcmlhbGl6ZU1pbk1heCIsInNlcmlhbGl6ZU9iamVjdElkIiwic2VyaWFsaXplQnVmZmVyIiwic2VyaWFsaXplT2JqZWN0IiwiY2hlY2tLZXlzIiwic2VyaWFsaXplRnVuY3Rpb25zIiwiaWdub3JlVW5kZWZpbmVkIiwicGF0aCIsInNlcmlhbGl6ZUludG8iLCJzZXJpYWxpemVEZWNpbWFsMTI4Iiwic2VyaWFsaXplTG9uZyIsInNlcmlhbGl6ZUludDMyIiwic2VyaWFsaXplRG91YmxlIiwic2VyaWFsaXplRnVuY3Rpb24iLCJzZXJpYWxpemVDb2RlIiwiY29kZVNpemUiLCJfbnVtYmVyT2ZXcml0dGVuQnl0ZXM0Iiwic2VyaWFsaXplQmluYXJ5Iiwic2VyaWFsaXplU3ltYm9sIiwic2VyaWFsaXplREJSZWYiLCJzdGFydGluZ0luZGV4IiwidG9CU09OIiwiX2tleSIsIl92YWx1ZSIsIl90eXBlIiwiX2tleTIiLCJfdmFsdWUyIiwiX3R5cGUyIiwic2VyaWFsaXplciIsIl90eXBlb2YkNCIsIkJ1ZmZlciQ2Iiwibm9ybWFsaXplZEZ1bmN0aW9uU3RyaW5nJDIiLCJpc0RhdGUkMiIsImNhbGN1bGF0ZU9iamVjdFNpemUiLCJ0b3RhbExlbmd0aCIsImNhbGN1bGF0ZUVsZW1lbnQiLCJvcmRlcmVkX3ZhbHVlcyIsImNhbGN1bGF0ZV9zaXplIiwiQnVmZmVyJDciLCJlbnN1cmVfYnVmZmVyIiwiZW5zdXJlQnVmZmVyIiwicG90ZW50aWFsQnVmZmVyIiwiQnVmZmVyJDgiLCJNQVhTSVpFIiwiYnVmZmVyJDEiLCJzZXRJbnRlcm5hbEJ1ZmZlclNpemUiLCJzZXJpYWxpemUkMSIsIm1pbkludGVybmFsQnVmZmVyU2l6ZSIsInNlcmlhbGl6YXRpb25JbmRleCIsImZpbmlzaGVkQnVmZmVyIiwic2VyaWFsaXplV2l0aEJ1ZmZlckFuZEluZGV4IiwiZmluYWxCdWZmZXIiLCJkZXNlcmlhbGl6ZSQyIiwiY2FsY3VsYXRlT2JqZWN0U2l6ZSQxIiwiZGVzZXJpYWxpemVTdHJlYW0iLCJudW1iZXJPZkRvY3VtZW50cyIsImRvY3VtZW50cyIsImRvY1N0YXJ0SW5kZXgiLCJFSlNPTiIsImJzb25fMSIsImJzb25fMiIsImJzb25fMyIsImJzb25fNCIsImJzb25fNSIsImJzb25fNiIsImJzb25fNyIsImJzb25fOCIsImJzb25fOSIsImJzb25fMTAiLCJic29uXzExIiwiYnNvbl8xMiIsImJzb25fMTMiLCJic29uXzE0IiwiYnNvbl8xNSIsImJzb25fMTYiLCJic29uXzE3IiwiYnNvbl8xOCIsImJzb25fMTkiLCJic29uXzIwIiwiYnNvbl8yMSIsImJzb25fMjIiLCJic29uXzIzIiwiYnNvbl8yNCIsImJzb25fMjUiLCJic29uXzI2IiwiYnNvbl8yNyIsImJzb25fMjgiLCJic29uXzI5IiwiYnNvbl8zMCIsImJzb25fMzEiLCJic29uXzMyIiwiYnNvbl8zMyIsImJzb25fMzQiLCJic29uXzM1IiwiYnNvbl8zNiIsImJzb25fMzciLCJic29uXzM4IiwiYnNvbl8zOSIsImJzb25fNDAiLCJic29uXzQxIiwiYnNvbl80MiIsImJzb25fNDMiLCJic29uXzQ0IiwiYnNvbl80NSIsImJzb25fNDYiLCJic29uXzQ3IiwiYnNvbl80OCIsImJzb25fNDkiLCJic29uXzUwIiwiYnNvbl81MSIsImJzb25fNTIiLCJic29uXzUzIiwiYnNvbl81NCIsImxvb2t1cCIsInJldkxvb2t1cCIsIkFyciIsImdldExlbnMiLCJiNjQiLCJ2YWxpZExlbiIsInBsYWNlSG9sZGVyc0xlbiIsImxlbnMiLCJfYnl0ZUxlbmd0aCIsInRtcCIsImN1ckJ5dGUiLCJ0cmlwbGV0VG9CYXNlNjQiLCJudW0iLCJlbmNvZGVDaHVuayIsInVpbnQ4IiwiZXh0cmFCeXRlcyIsIm1heENodW5rTGVuZ3RoIiwibGVuMiIsImlzTEUiLCJ3YXNtIiwiV2ViQXNzZW1ibHkiLCJJbnN0YW5jZSIsIk1vZHVsZSIsIl9faXNMb25nX18iLCJJTlRfQ0FDSEUiLCJVSU5UX0NBQ0hFIiwiY2FjaGVkT2JqIiwiY2FjaGUiLCJVWkVSTyIsIlRXT19QV1JfNjRfREJMIiwiTUFYX1VOU0lHTkVEX1ZBTFVFIiwiVFdPX1BXUl82M19EQkwiLCJNSU5fVkFMVUUiLCJNQVhfVkFMVUUiLCJuZWciLCJUV09fUFdSXzMyX0RCTCIsInBvd19kYmwiLCJyYWRpeCIsInN1YnN0cmluZyIsInJhZGl4VG9Qb3dlciIsInBvd2VyIiwiZnJvbVZhbHVlIiwiVFdPX1BXUl8xNl9EQkwiLCJUV09fUFdSXzI0X0RCTCIsIlRXT19QV1JfMjQiLCJPTkUiLCJVT05FIiwiTkVHX09ORSIsIkxvbmdQcm90b3R5cGUiLCJ0b0ludCIsImlzWmVybyIsImVxIiwicmFkaXhMb25nIiwicmVtMSIsInJlbURpdiIsImludHZhbCIsImdldEhpZ2hCaXRzVW5zaWduZWQiLCJnZXRMb3dCaXRzVW5zaWduZWQiLCJnZXROdW1CaXRzQWJzIiwiYml0IiwiZXF6IiwiaXNQb3NpdGl2ZSIsImlzT2RkIiwiaXNFdmVuIiwib3RoZXIiLCJub3RFcXVhbHMiLCJuZXEiLCJuZSIsImNvbXAiLCJsdCIsImx0ZSIsImxlIiwiZ3JlYXRlclRoYW4iLCJndCIsImd0ZSIsImdlIiwidGhpc05lZyIsIm90aGVyTmVnIiwibmVnYXRlIiwibm90IiwiYWRkZW5kIiwiYTQ4IiwiYTMyIiwiYTE2IiwiYTAwIiwiYjQ4IiwiYjMyIiwiYjE2IiwiYjAwIiwiYzQ4IiwiYzMyIiwiYzE2IiwiYzAwIiwic3VidHJhY3QiLCJzdWJ0cmFoZW5kIiwibXVsdGlwbGllciIsImdldF9oaWdoIiwiZGl2aWRlIiwiZGl2aXNvciIsImRpdl91IiwiZGl2X3MiLCJhcHByb3giLCJoYWxmVGhpcyIsInNociIsInNobCIsInRvVW5zaWduZWQiLCJzaHJ1IiwibG9nMiIsImNlaWwiLCJkZWx0YSIsImFwcHJveFJlcyIsImFwcHJveFJlbSIsInJlbV91IiwicmVtX3MiLCJtb2QiLCJ4b3IiLCJudW1CaXRzIiwic2hpZnRSaWdodCIsInNocl91IiwidG9TaWduZWQiLCJ0b0J5dGVzIiwidG9CeXRlc0xFIiwidG9CeXRlc0JFIiwiZnJvbUJ5dGVzIiwiZnJvbUJ5dGVzTEUiLCJmcm9tQnl0ZXNCRSIsIkJTT04iLCJCc29uIiwiU2RsUGFja2V0IiwidmVyc2lvbiIsImVuY3J5cHRpb24iLCJmcmFtZVR5cGUiLCJzZXJ2aWNlVHlwZSIsImZyYW1lSW5mbyIsInNlc3Npb25JZCIsImRhdGFTaXplIiwibWVzc2FnZUlkIiwicGF5bG9hZCIsImJ5dGVzVG9Xcml0ZSIsIl92ZXJzaW9uIiwiX2VuY3J5cHRpb24iLCJfZnJhbWVUeXBlIiwiX3NlcnZpY2VUeXBlIiwiX2ZyYW1lSW5mbyIsIl9zZXNzaW9uSWQiLCJfZGF0YVNpemUiLCJfbWVzc2FnZUlkIiwiX3BheWxvYWQiLCJfb2Zmc2V0IiwiX2J5dGVzVG9Xcml0ZSIsIl9ic29uUGF5bG9hZCIsImdldEVuY3J5cHRpb25CaXQiLCJfc2Vzc2lvbklEIiwiX21lc3NhZ2VJRCIsImNvbnN0cnVjdFBhY2tldCIsInRhZyIsIkVOQ1JZUFRJT05fTUFTSyIsImNvbnRyb2xGcmFtZUluZm8iLCJkYXRhVmlldyIsImRhdGFWaWV3SW5kZXgiLCJIRUFERVJfU0laRSIsIkhFQURFUl9TSVpFX1YxIiwiRVhUUkFfUEFSQ0VMX0RBVEFfTEVOR1RIIiwiU0VSVklDRV9UWVBFX0NPTlRST0wiLCJTRVJWSUNFX1RZUEVfUlBDIiwiU0VSVklDRV9UWVBFX1BDTSIsIlNFUlZJQ0VfVFlQRV9WSURFTyIsIlNFUlZJQ0VfVFlQRV9CVUxLX0RBVEEiLCJGUkFNRV9JTkZPX0hFQVJUX0JFQVQiLCJGUkFNRV9JTkZPX1NUQVJUX1NFUlZJQ0UiLCJGUkFNRV9JTkZPX1NUQVJUX1NFUlZJQ0VfQUNLIiwiRlJBTUVfSU5GT19TVEFSVF9TRVJWSUNFX05BSyIsIkZSQU1FX0lORk9fRU5EX1NFUlZJQ0UiLCJGUkFNRV9JTkZPX0VORF9TRVJWSUNFX0FDSyIsIkZSQU1FX0lORk9fRU5EX1NFUlZJQ0VfTkFLIiwiRlJBTUVfSU5GT19SRUdJU1RFUl9TRUNPTkRBUllfVFJBTlNQT1JUIiwiRlJBTUVfSU5GT19SRUdJU1RFUl9TRUNPTkRBUllfVFJBTlNQT1JUX0FDSyIsIkZSQU1FX0lORk9fUkVHSVNURVJfU0VDT05EQVJZX1RSQU5TUE9SVF9OQUsiLCJGUkFNRV9JTkZPX1RSQU5TUE9SVF9FVkVOVF9VUERBVEUiLCJGUkFNRV9JTkZPX1NFUlZJQ0VfREFUQV9BQ0siLCJGUkFNRV9JTkZPX0hFQVJUX0JFQVRfQUNLIiwiRlJBTUVfSU5GT19GSU5BTF9DT05ORVNDVVRJVkVfRlJBTUUiLCJGUkFNRV9JTkZPX1JFU0VSVkVEIiwiUnBjU3RydWN0IiwicGFyYW1ldGVycyIsIl9pc0Zvcm1hdFJlcXVlc3RlZCIsIl9ycGNTcGVjVmVyc2lvbiIsIl9wYXJhbWV0ZXJzIiwidENsYXNzIiwiZm9ybWF0T2JqZWN0IiwiZ2V0UGFyYW1ldGVyIiwidmFsdWVGb3JTdHJpbmciLCJvdXRBcnJheSIsIml0ZW0iLCJ0Y2xhc3MiLCJScGNNZXNzYWdlIiwic3RvcmUiLCJfaXNFbmNyeXB0ZWQiLCJfZnVuY3Rpb25OYW1lIiwiZnVuY3Rpb25OYW1lIiwiX2NvcnJlbGF0aW9uSUQiLCJjb3JyZWxhdGlvbklEIiwic2V0QnVsa0RhdGEiLCJidWxrRGF0YSIsImJvb2wiLCJTZXJ2aWNlVHlwZSIsIlJQQyIsIkFVRElPIiwiVklERU8iLCJIWUJSSUQiLCJTZGxQcm90b2NvbExpc3RlbmVyIiwiX29uUnBjTWVzc2FnZVJlY2VpdmVkIiwiX29uQ29udHJvbFNlcnZpY2VNZXNzYWdlUmVjZWl2ZWQiLCJsaXN0ZW5lciIsIl9vbkRlY3J5cHRSZXF1ZXN0TGlzdGVuZXIiLCJycGNNZXNzYWdlIiwiX29uU3RhcnRTZXJ2aWNlQUNLUmVjZWl2ZWQiLCJfb25TdGFydFNlcnZpY2VOQUtSZWNlaXZlZCIsIl9vbkVuZFNlcnZpY2VBQ0tSZWNlaXZlZCIsIl9vbkVuZFNlcnZpY2VOQUtSZWNlaXZlZCIsIm9uU2VydmljZUVuY3J5cHRpb25TdGFydGVkIiwiVHJhbnNwb3J0TGlzdGVuZXIiLCJfb25UcmFuc3BvcnRDb25uZWN0ZWQiLCJfb25UcmFuc3BvcnREaXNjb25uZWN0ZWQiLCJfb25FcnJvciIsIl9vblBhY2tldFJlY2VpdmVkIiwiZnVuYyIsIlRyYW5zcG9ydENvbmZpZ0Jhc2UiLCJ0cmFuc3BvcnRUeXBlIiwiX3RyYW5zcG9ydFR5cGUiLCJWZXJzaW9uIiwibWFqb3IiLCJtaW5vciIsInBhdGNoIiwic2V0TWFqb3IiLCJzZXRNaW5vciIsInNldFBhdGNoIiwiX21ham9yIiwiX21pbm9yIiwiX3BhdGNoIiwidmVyc2lvbnMiLCJnZXRNYWpvciIsImdldE1pbm9yIiwiZ2V0UGF0Y2giLCJTZGxQcm90b2NvbEJhc2UiLCJiYXNlVHJhbnNwb3J0Q29uZmlnIiwic2RsUHJvdG9jb2xMaXN0ZW5lciIsIl90cmFuc3BvcnRDb25maWciLCJfc2RsUHJvdG9jb2xsaXN0ZW5lciIsInJlc2V0IiwiX2NyZWF0ZVRyYW5zcG9ydExpc3RlbmVyIiwiX3RyYW5zcG9ydE1hbmFnZXIiLCJfdHJhbnNwb3J0TGlzdGVuZXIiLCJzZXRPblRyYW5zcG9ydENvbm5lY3RlZCIsInNldE9uVHJhbnNwb3J0RGlzY29ubmVjdGVkIiwic2V0T25QYWNrZXRSZWNlaXZlZCIsIl9oYW5kbGVQYWNrZXRSZWNlaXZlZCIsInNldE9uRXJyb3IiLCJyZXRWYWwiLCJfbXR1cyIsIlYxX1YyX01UVV9TSVpFIiwiaXNDb25uZWN0ZWQiLCJfcHJvdG9jb2xfdmVyc2lvbiIsIl9oZWFkZXJTaXplIiwiVjFfSEVBREVSX1NJWkUiLCJzZXJ2aWNlU3RhdHVzIiwiX2hhc2hJRCIsIl9tZXNzYWdlRnJhbWVBc3NlbWJsZXJzIiwicHJvdG9jb2xWZXJzaW9uIiwiVjJfSEVBREVSX1NJWkUiLCJtdHVzIiwiVjNfVjRfTVRVX1NJWkUiLCJzZW5kUGFja2V0IiwicGFyYW1CeXRlcyIsImdldFBhcmFtZXRlcnMiLCJwcm90b2NvbE1lc3NhZ2UiLCJfc2V0VmVyc2lvbiIsInBhY2tldCIsImdldEZyYW1lVHlwZSIsIm1lc3NhZ2VGcmFtZUFzc2VtYmxlciIsIl9nZXRNZXNzYWdlRnJhbWVBc3NlbWJsZXIiLCJoYW5kbGVGcmFtZSIsIl9oYW5kbGVDb250cm9sUGFja2V0IiwiZ2V0U2VydmljZVR5cGUiLCJfaGFuZGxlUlBDUGFja2V0IiwiZ2V0TWVzc2FnZUlEIiwiZ2V0RnJhbWVJbmZvIiwiZ2V0UGF5bG9hZCIsIl9oYW5kbGVTdGFydFNlcnZpY2VBQ0siLCJfaGFuZGxlU3RhcnRTZXJ2aWNlTkFLIiwiX2hhbmRsZUVuZFNlcnZpY2VBQ0siLCJvblN0YXJ0U2VydmljZUFDS1JlY2VpdmVkIiwib25Db250cm9sU2VydmljZU1lc3NhZ2VSZWNlaXZlZCIsIm9uUnBjTWVzc2FnZVJlY2VpdmVkIiwic2Vzc2lvbklEIiwiTUFYX1BST1RPQ09MX1ZFUlNJT04iLCJDb250cm9sRnJhbWVUYWdzIiwiU3RhcnRTZXJ2aWNlQUNLQmFzZSIsIk1UVSIsIk5BS0Jhc2UiLCJSRUpFQ1RFRF9QQVJBTVMiLCJTdGFydFNlcnZpY2VQcm90b2NvbFZlcnNpb24iLCJQUk9UT0NPTF9WRVJTSU9OIiwiU3RhcnRTZXJ2aWNlSGFzaElkIiwiSEFTSF9JRCIsIlN0YXJ0U2VydmljZURpbWVuc2lvbnMiLCJIRUlHSFQiLCJXSURUSCIsIlN0YXJ0U2VydmljZSIsIlN0YXJ0U2VydmljZUFDSyIsIlNFQ09OREFSWV9UUkFOU1BPUlRTIiwiQVVESU9fU0VSVklDRV9UUkFOU1BPUlRTIiwiVklERU9fU0VSVklDRV9UUkFOU1BPUlRTIiwiQVVUSF9UT0tFTiIsIlN0YXJ0U2VydmljZU5BSyIsIkVuZFNlcnZpY2UiLCJFbmRTZXJ2aWNlQUNLIiwiRW5kU2VydmljZU5BSyIsIlRyYW5zcG9ydEV2ZW50VXBkYXRlIiwiVENQX0lQX0FERFJFU1MiLCJUQ1BfUE9SVCIsIlJlZ2lzdGVyU2Vjb25kYXJ5VHJhbnNwb3J0IiwiUmVnaXN0ZXJTZWNvbmRhcnlUcmFuc3BvcnRBQ0siLCJSZWdpc3RlclNlY29uZGFyeVRyYW5zcG9ydE5BSyIsIlJFQVNPTiIsIkF1ZGlvIiwiVmlkZW8iLCJWSURFT19QUk9UT0NPTCIsIlZJREVPX0NPREVDIiwiUnBjVHlwZSIsInZhbHVlRm9yU3RyaW5nSW50ZXJuYWwiLCJrZXlGb3JWYWx1ZUludGVybmFsIiwiTk9USUZJQ0FUSU9OIiwiUkVTUE9OU0UiLCJSRVFVRVNUIiwiUnBjTm90aWZpY2F0aW9uIiwic2V0UlBDVHlwZSIsIlJwY1JlcXVlc3QiLCJfcHJvbWlzZSIsInByb21pc2UiLCJ2YWxpZGF0ZVR5cGUiLCJQcm9taXNlIiwiUmVzdWx0IiwiU1VDQ0VTUyIsIlVOU1VQUE9SVEVEX1JFUVVFU1QiLCJESVNBTExPV0VEIiwiUkVKRUNURUQiLCJBQk9SVEVEIiwiSUdOT1JFRCIsIlJFVFJZIiwiSU5fVVNFIiwiVkVISUNMRV9EQVRBX05PVF9BVkFJTEFCTEUiLCJUSU1FRF9PVVQiLCJJTlZBTElEX0RBVEEiLCJDSEFSX0xJTUlUX0VYQ0VFREVEIiwiSU5WQUxJRF9JRCIsIkRVUExJQ0FURV9OQU1FIiwiQVBQTElDQVRJT05fTk9UX1JFR0lTVEVSRUQiLCJXUk9OR19MQU5HVUFHRSIsIk9VVF9PRl9NRU1PUlkiLCJUT09fTUFOWV9QRU5ESU5HX1JFUVVFU1RTIiwiVE9PX01BTllfQVBQTElDQVRJT05TIiwiQVBQTElDQVRJT05fUkVHSVNURVJFRF9BTFJFQURZIiwiV0FSTklOR1MiLCJHRU5FUklDX0VSUk9SIiwiVVNFUl9ESVNBTExPV0VEIiwiVFJVTkNBVEVEX0RBVEEiLCJVTlNVUFBPUlRFRF9WRVJTSU9OIiwiVkVISUNMRV9EQVRBX05PVF9BTExPV0VEIiwiRklMRV9OT1RfRk9VTkQiLCJDQU5DRUxfUk9VVEUiLCJTQVZFRCIsIklOVkFMSURfQ0VSVCIsIkVYUElSRURfQ0VSVCIsIlJFU1VNRV9GQUlMRUQiLCJEQVRBX05PVF9BVkFJTEFCTEUiLCJSRUFEX09OTFkiLCJDT1JSVVBURURfREFUQSIsIlJwY1Jlc3BvbnNlIiwiS0VZX1NVQ0NFU1MiLCJzdWNjZXNzIiwic2V0UGFyYW1ldGVyIiwiS0VZX0lORk8iLCJpbmZvIiwiZ2V0T2JqZWN0IiwiS0VZX1JFU1VMVF9DT0RFIiwicmVzdWx0Q29kZSIsIkZ1bmN0aW9uSUQiLCJBZGRDb21tYW5kIiwiT25MYW5ndWFnZUNoYW5nZSIsIkltYWdlVHlwZSIsIlNUQVRJQyIsIkRZTkFNSUMiLCJMYW5ndWFnZSIsIkVOX1NBIiwiSEVfSUwiLCJST19STyIsIlVLX1VBIiwiSURfSUQiLCJWSV9WTiIsIk1TX01ZIiwiSElfSU4iLCJOTF9CRSIsIkVMX0dSIiwiSFVfSFUiLCJGSV9GSSIsIlNLX1NLIiwiRU5fVVMiLCJFU19NWCIsIkZSX0NBIiwiREVfREUiLCJFU19FUyIsIkVOX0dCIiwiUlVfUlUiLCJUUl9UUiIsIlBMX1BMIiwiRlJfRlIiLCJJVF9JVCIsIlNWX1NFIiwiUFRfUFQiLCJOTF9OTCIsIkVOX0FVIiwiWkhfQ04iLCJaSF9UVyIsIkpBX0pQIiwiQVJfU0EiLCJLT19LUiIsIlBUX0JSIiwiQ1NfQ1oiLCJEQV9ESyIsIk5PX05PIiwiRU5fSU4iLCJUSF9USCIsIkltYWdlIiwiS0VZX1ZBTFVFIiwiS0VZX0lNQUdFX1RZUEUiLCJpc1RlbXBsYXRlIiwiS0VZX0lTX1RFTVBMQVRFIiwiTWVudVBhcmFtcyIsIktFWV9QQVJFTlRfSUQiLCJLRVlfUE9TSVRJT04iLCJtZW51TmFtZSIsIktFWV9NRU5VX05BTUUiLCJzZXRGdW5jdGlvbk5hbWUiLCJBRERfQ09NTUFORCIsIktFWV9DTURfSUQiLCJtZW51UGFyYW1zIiwiS0VZX01FTlVfUEFSQU1TIiwidnJDb21tYW5kcyIsIktFWV9WUl9DT01NQU5EUyIsImljb24iLCJLRVlfQ01EX0lDT04iLCJBZGRDb21tYW5kUmVzcG9uc2UiLCJPTl9MQU5HVUFHRV9DSEFOR0UiLCJsYW5nYXVnZSIsImxhbmd1YWdlIiwiS0VZX0xBTkdVQUdFIiwiS0VZX0hNSV9ESVNQTEFZX0xBTkdVQUdFIiwiU2RsU2Vzc2lvbkxpc3RlbmVyIiwiU2RsU2Vzc2lvbiIsInNkbFNlc3Npb25MaXN0ZW5lciIsIl9zZXJ2aWNlTGlzdGVuZXJzIiwiX3NkbFNlc3Npb25MaXN0ZW5lciIsIl9zZXR1cFNkbFByb3RvY29sTGlzdGVuZXIiLCJfc2RsUHJvdG9jb2wiLCJlbmRTZXNzaW9uIiwic2VydmljZUxpc3RlbmVyIiwiU2RsUHNtIiwiX3N0YXRlIiwiU1RBUlRfU1RBVEUiLCJfY29udHJvbEZyYW1lSW5mbyIsIl9kdW1wU2l6ZSIsIl9kYXRhTGVuZ3RoIiwiRklOSVNIRURfU1RBVEUiLCJfdHJhbnNpdGlvbk9uSW5wdXQiLCJFUlJPUl9TVEFURSIsInJhd0J5dGUiLCJzdGF0ZSIsIlZFUlNJT05fTUFTSyIsIkZSQU1FX1RZUEVfTUFTSyIsIkZSQU1FX1RZUEVfQ09OVFJPTCIsIkZSQU1FX1RZUEVfQ09OU0VDVVRJVkUiLCJTRVJWSUNFX1RZUEVfU1RBVEUiLCJDT05UUk9MX0ZSQU1FX0lORk9fU1RBVEUiLCJGUkFNRV9UWVBFX1NJTkdMRSIsIkZSQU1FX1RZUEVfRklSU1QiLCJTRVNTSU9OX0lEX1NUQVRFIiwiREFUQV9TSVpFXzFfU1RBVEUiLCJEQVRBX1NJWkVfMl9TVEFURSIsIkRBVEFfU0laRV8zX1NUQVRFIiwiREFUQV9TSVpFXzRfU1RBVEUiLCJEQVRBX1BVTVBfU1RBVEUiLCJkYXRhTGVuZ3RoIiwiRklSU1RfRlJBTUVfREFUQV9TSVpFIiwiTUVTU0FHRV8xX1NUQVRFIiwiTUVTU0FHRV8yX1NUQVRFIiwiTUVTU0FHRV8zX1NUQVRFIiwiTUVTU0FHRV80X1NUQVRFIiwiZHVtcFNpemUiLCJUcmFuc3BvcnRCYXNlIiwidHJhbnNwb3J0TGlzdGVuZXIiLCJfc2RsUHNtIiwiVHJhbnNwb3J0TWFuYWdlckJhc2UiLCJvblRyYW5zcG9ydENvbm5lY3RlZCIsIm9uVHJhbnNwb3J0RGlzY29ubmVjdGVkIiwib25FcnJvciIsIm9uUGFja2V0UmVjZWl2ZWQiLCJhZGRyZXNzIiwiVHJhbnNwb3J0VHlwZSIsIldFQlNPQ0tFVF9TRVJWRVIiLCJXRUJTT0NLRVRfQ0xJRU5UIiwiSnNvblJwY01hcnNoYWxsZXIiLCJqc29uT2JqZWN0Iiwic3RyaW5nVmVyc2lvbiIsImVuY29kZXIiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsImV4Y2VwdGlvbiIsIlNETCIsIm1hbmFnZXIiLCJsaWZlY3ljbGUiLCJwcm90b2NvbCIsImVudW1zIiwicnBjIiwibWVzc2FnZXMiLCJzdHJ1Y3RzIiwic2Vzc2lvbiIsInRyYW5zcG9ydCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztNQWdDTUE7Ozs7RUNoQ047Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7TUFnQ01DOzs7Ozs7Ozs7O0VBRUY7Ozs7Ozt1Q0FNaUJDLE9BQTJCO0FBQUEsRUFFM0M7O0VBRUQ7Ozs7Ozs7dUNBSWlCQyxXQUFXOztFQUk1Qjs7Ozs7Ozs7eUNBS21CQyxRQUFvQjtFQUFBLFVBQVpDLE1BQVksdUVBQUgsQ0FBRztFQUNuQztFQUNBLFVBQUcsQ0FBQ0QsTUFBSixFQUFZLE9BQU8sQ0FBQyxDQUFSO0VBQ1osVUFBSUUsSUFBSSxHQUFHLElBQUlDLFFBQUosQ0FBYUgsTUFBYixDQUFYO0VBQ0EsYUFBT0UsSUFBSSxDQUFDRSxTQUFMLENBQWVILE1BQWYsQ0FBUDtFQUNIO0VBRUQ7Ozs7Ozs7eUNBSW1CSSxPQUFPO0VBQ3RCLFVBQUlMLE1BQU0sR0FBRyxJQUFJTSxXQUFKLENBQWdCLENBQWhCLENBQWIsQ0FEc0I7O0VBRXRCLFVBQUlKLElBQUksR0FBRyxJQUFJQyxRQUFKLENBQWFILE1BQWIsQ0FBWDtFQUNBRSxNQUFBQSxJQUFJLENBQUNLLFNBQUwsQ0FBZSxDQUFmLEVBQWtCRixLQUFsQixFQUF5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RUFDRyxHQURILEVBQ1EsR0FEUixFQUNhLENBRGIsRUFDZ0IsR0FEaEIsRUFDcUIsQ0FEckIsRUFDd0IsQ0FEeEIsRUFDMkIsQ0FEM0IsRUFDOEIsQ0FEOUIsRUFDaUMsQ0FEakMsRUFDb0MsQ0FEcEMsRUFDdUMsQ0FEdkMsRUFDMEMsQ0FEMUMsRUFDNkMsQ0FEN0MsRUFDZ0QsQ0FEaEQsRUFDbUQsQ0FEbkQsRUFDc0QsQ0FEdEQsRUFDeUQsR0FEekQsRUFDOEQsQ0FEOUQsRUFDaUUsRUFEakUsRUFDcUUsQ0FEckUsRUFDd0UsRUFEeEUsRUFDNEUsQ0FENUUsRUFDK0UsRUFEL0UsRUFDbUYsQ0FEbkYsRUFDc0YsQ0FEdEYsRUFDeUYsR0FEekYsRUFDOEYsR0FEOUYsRUFDbUcsR0FEbkcsRUFDd0csQ0FEeEcsRUFDMkcsQ0FEM0csRUFDOEcsQ0FEOUcsRUFDaUgsR0FEakgsRUFDc0gsR0FEdEgsRUFDMkgsR0FEM0gsRUFDZ0ksRUFEaEksRUFDb0ksR0FEcEksRUFDeUksQ0FEekksRUFDNEksQ0FENUksRUFDK0ksQ0FEL0ksRUFDa0osR0FEbEosRUFDdUosR0FEdkosRUFDNEosR0FENUosRUFDaUssRUFEakssRUFDcUssR0FEckssRUFDMEssQ0FEMUssRUFDNkssQ0FEN0ssRUFDZ0wsQ0FEaEwsRUFDbUwsR0FEbkwsRUFDd0wsR0FEeEwsRUFDNkwsR0FEN0wsRUFDa00sRUFEbE0sRUFDc00sR0FEdE0sRUFDMk0sQ0FEM00sRUFDOE0sQ0FEOU0sRUFDaU4sQ0FEak4sRUFDb04sR0FEcE4sRUFDeU4sR0FEek4sRUFDOE4sR0FEOU4sRUFDbU8sRUFEbk8sRUFDdU8sR0FEdk8sRUFDNE8sQ0FENU8sRUFDK08sQ0FEL08sRUFDa1AsQ0FEbFAsRUFDcVAsR0FEclAsRUFDMFAsR0FEMVAsRUFDK1AsR0FEL1AsRUFDb1EsRUFEcFEsRUFDd1EsR0FEeFEsRUFDNlEsR0FEN1EsRUFDa1IsR0FEbFIsRUFDdVIsR0FEdlIsRUFDNFIsQ0FENVIsRUFDK1IsQ0FEL1IsRUFDa1MsRUFEbFMsRUFDc1MsR0FEdFMsRUFDMlMs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
